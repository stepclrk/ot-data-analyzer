<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Customer Data Analyzer - Exact Python Match</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        
        /* Menu styles */
        .menu-button {
            position: fixed;
            top: 20px;
            left: 20px;
            background: #1a365d;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            z-index: 1000;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            transition: all 0.3s ease;
        }
        
        .menu-button:hover {
            background: #2c5282;
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }
        
        .menu-dropdown {
            position: fixed;
            top: 60px;
            left: 20px;
            background: white;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            display: none;
            z-index: 999;
            min-width: 250px;
            overflow: visible;
        }
        
        .menu-dropdown.show {
            display: block;
            animation: slideDown 0.3s ease;
        }
        
        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .menu-item {
            padding: 15px 20px;
            cursor: pointer;
            transition: background 0.2s ease;
            border-bottom: 1px solid #e2e8f0;
            color: #2d3748;
            font-weight: 500;
        }
        
        .menu-item:hover {
            background: #f7fafc;
        }
        
        .menu-item:last-child {
            border-bottom: none;
        }
        
        /* Modal styles */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 1100;
            align-items: center;
            justify-content: center;
        }
        
        .modal.show {
            display: flex;
            animation: fadeIn 0.3s ease;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        .modal-content {
            background: white;
            border-radius: 15px;
            max-width: 800px;
            max-height: 90vh;
            overflow-y: auto;
            padding: 40px;
            margin: 20px;
            position: relative;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
        }
        
        .modal-close {
            position: absolute;
            top: 20px;
            right: 20px;
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #718096;
            transition: color 0.2s ease;
        }
        
        .modal-close:hover {
            color: #2d3748;
        }
        
        .modal h2 {
            color: #1a365d;
            margin-top: 0;
            margin-bottom: 20px;
            font-size: 2em;
        }
        
        .modal h3 {
            color: #2d3748;
            margin-top: 30px;
            margin-bottom: 15px;
        }
        
        .modal p {
            color: #4a5568;
            line-height: 1.6;
            margin-bottom: 15px;
        }
        
        .modal ul {
            color: #4a5568;
            line-height: 1.8;
            margin-left: 20px;
        }
        
        .modal code {
            background: #f7fafc;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: monospace;
            font-size: 0.9em;
        }
        .upload-container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            padding: 40px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .upload-area {
            border: 2px dashed #ccc;
            border-radius: 8px;
            padding: 40px;
            text-align: center;
            margin: 20px 0;
            cursor: pointer;
            transition: all 0.3s;
        }
        .upload-area:hover, .upload-area.dragover {
            border-color: #4CAF50;
            background-color: #f0f8f0;
        }
        .file-list {
            margin: 20px 0;
        }
        .file-item {
            background: #f9f9f9;
            padding: 10px;
            margin: 5px 0;
            border-radius: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .remove-btn {
            background: #f44336;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
        }
        .analyze-btn {
            background: #4CAF50;
            color: white;
            padding: 12px 30px;
            border: none;
            border-radius: 5px;
            font-size: 16px;
            cursor: pointer;
            width: 100%;
            margin-top: 20px;
        }
        .analyze-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        .status {
            margin: 20px 0;
            padding: 10px;
            border-radius: 5px;
            display: none;
        }
        .status.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .status.warning {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeeba;
        }
        
        /* Progress tracker styles */
        .progress-container {
            display: none;
            margin: 20px 0;
            padding: 20px;
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .progress-bar-wrapper {
            background: #e0e0e0;
            border-radius: 10px;
            height: 20px;
            margin: 15px 0;
            overflow: hidden;
            position: relative;
        }
        
        .progress-bar {
            background: linear-gradient(90deg, #4CAF50 0%, #45a049 100%);
            height: 100%;
            width: 0%;
            transition: width 0.3s ease;
            border-radius: 10px;
            position: relative;
            overflow: hidden;
        }
        
        .progress-bar::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            background: linear-gradient(
                45deg,
                rgba(255, 255, 255, 0.2) 25%,
                transparent 25%,
                transparent 50%,
                rgba(255, 255, 255, 0.2) 50%,
                rgba(255, 255, 255, 0.2) 75%,
                transparent 75%,
                transparent
            );
            background-size: 50px 50px;
            animation: progress-stripes 1s linear infinite;
        }
        
        @keyframes progress-stripes {
            0% { background-position: 0 0; }
            100% { background-position: 50px 50px; }
        }
        
        .progress-text {
            text-align: center;
            font-weight: bold;
            margin-top: 10px;
            color: #333;
        }
        
        .progress-status {
            text-align: center;
            color: #666;
            font-size: 14px;
            margin-top: 5px;
        }
        
        .progress-details {
            margin-top: 15px;
            padding: 10px;
            background: #f5f5f5;
            border-radius: 5px;
            font-size: 13px;
            color: #555;
            max-height: 100px;
            overflow-y: auto;
        }
        
        .progress-step {
            padding: 3px 0;
            display: flex;
            align-items: center;
        }
        
        .progress-step.completed {
            color: #4CAF50;
        }
        
        .progress-step.active {
            color: #2196F3;
            font-weight: bold;
        }
        
        .progress-step .step-icon {
            margin-right: 8px;
            width: 16px;
            display: inline-block;
        }
        #reportFrame {
            width: 100%;
            height: calc(100vh - 40px);
            border: none;
            margin-top: 20px;
            display: none;
            background: white;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            border-radius: 8px;
        }
        
        #reportFrame.maximized {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            margin: 0;
            z-index: 1000;
            border-radius: 0;
        }
        
        .maximize-btn {
            position: fixed;
            top: 10px;
            right: 10px;
            width: 40px;
            height: 40px;
            border: 1px solid #e0e0e0;
            background: #f5f5f5;
            color: #333;
            font-size: 18px;
            cursor: pointer;
            border-radius: 4px;
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1001;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        .maximize-btn:hover {
            background: #e8e8e8;
            transform: scale(1.05);
        }
        
        .maximize-btn.visible {
            display: flex;
        }
        
        .minimize-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 32px;
            height: 32px;
            border: 1px solid #e0e0e0;
            background: #f5f5f5;
            color: #333;
            font-size: 20px;
            font-weight: bold;
            line-height: 1;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .minimize-btn:hover {
            background: #e8e8e8;
            transform: translateY(-1px);
            box-shadow: 0 3px 6px rgba(0,0,0,0.15);
        }
        
        .minimize-btn:active {
            transform: translateY(0);
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
        }
        
        .upload-container.minimized {
            height: auto !important;
            min-height: auto !important;
            padding-bottom: 20px !important;
        }
        
        .upload-container.minimized #analyzerContent {
            display: none;
        }
        
        .upload-container.minimized #analyzerSubtitle {
            font-size: 0.9em;
            opacity: 0.8;
        }
        
        /* Submenu styles */
        .menu-item.has-submenu {
            position: relative;
        }
        
        .converter-submenu {
            display: none;
            position: absolute;
            top: 0;
            left: 100%;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            min-width: 200px;
            margin-left: 5px;
            z-index: 1000;
        }
        
        .submenu-item {
            padding: 12px 20px;
            cursor: pointer;
            transition: background 0.2s ease;
            border-bottom: 1px solid #e2e8f0;
            color: #2d3748;
            font-weight: 500;
        }
        
        .submenu-item:hover {
            background: #f7fafc;
        }
        
        .submenu-item:last-child {
            border-bottom: none;
        }
    </style>
</head>
<body>
    <!-- Menu Button -->
    <button class="menu-button" onclick="toggleMenu()">☰ Menu</button>
    
    <!-- Menu Dropdown -->
    <div id="menuDropdown" class="menu-dropdown">
        <div class="menu-item" onclick="showModal('instructionsModal')">📖 Instructions</div>
        <div class="menu-item" onclick="showModal('explanationsModal')">📊 Tool Explanations</div>
        <div class="menu-item" onclick="showModal('aboutModal')">ℹ️ About</div>
        <div class="menu-item has-submenu" onclick="toggleConverterSubmenu(event)">
            🔄 Converter ▶
            <div id="converterSubmenu" class="converter-submenu">
                <div class="submenu-item" onclick="window.open('Classic_to_TG_Billing_format_converter.html', '_blank')">MS Classic (EMEA) </div>
                <div class="submenu-item" onclick="window.open('csv_to_xlsx_converter.html', '_blank')">TG / Classic CSV (US)</div>
            </div>
        </div>
    </div>
    
    <!-- Instructions Modal -->
    <div id="instructionsModal" class="modal" onclick="if(event.target === this) closeModal('instructionsModal')">
        <div class="modal-content">
            <button class="modal-close" onclick="closeModal('instructionsModal')">✕</button>
            <h2>📖 Complete User Guide</h2>
            
            <h3>🚀 Quick Start Guide</h3>
            <p>Get your analysis running in under 2 minutes with these simple steps:</p>
            <ol style="background: #f0f9ff; padding: 15px; border-radius: 8px; margin: 10px 0;">
                <li>📁 Gather your Excel files (must be .xlsx format)</li>
                <li>📤 Drag files onto the upload area</li>
                <li>🔍 Click "Analyze Files" button</li>
                <li>📊 View your comprehensive analysis</li>
            </ol>
            
            <h3>📁 Step 1: Preparing Your Files</h3>
            
            <h4>File Requirements</h4>
            <ul>
                <li><strong>Format:</strong> Excel 2007+ (.xlsx) - no .xls or .csv files</li>
                <li><strong>Naming Convention:</strong> 
                    <ul style="margin-top: 5px; font-size: 0.9em;">
                        <li>Pattern: <code>CustomerName_DataType_YYYYMM.xlsx</code></li>
                        <li>✅ Good: <code>ACME_Reports_202307.xlsx</code></li>
                        <li>❌ Bad: <code>July 2023 ACME Data.xlsx</code></li>
                    </ul>
                </li>
                <li><strong>Size Limits:</strong> Each file should be under 50MB for optimal performance</li>
                <li><strong>Multiple Periods:</strong> Upload 3-12 months for best trend analysis</li>
            </ul>
            
            <h4>Data Validation Checklist</h4>
            <p>Before uploading, ensure each Excel file contains these sheets:</p>
            <ul style="background: #f7fafc; padding: 10px; border-radius: 5px;">
                <li>☑️ Date_Summary</li>
                <li>☑️ Doc_Summary</li>
                <li>☑️ Hub_Summary</li>
                <li>☑️ TP_Summary</li>
                <li>☑️ TP_Doc_Summary</li>
            </ul>
            
            <h4>ID Cross-Reference File (Optional)</h4>
            <p>You can upload an ID cross-reference file to enhance your reports with meaningful names and regions:</p>
            <ul style="background: #f7fafc; padding: 10px; border-radius: 5px;">
                <li>📋 <strong>File Format:</strong> Excel (.xlsx, .xls) or CSV (.csv)</li>
                <li>📊 <strong>Required Columns:</strong>
                    <ul style="margin-top: 5px;">
                        <li><strong>ID:</strong> The trading partner or hub identifier</li>
                        <li><strong>Name:</strong> The descriptive name for the ID</li>
                        <li><strong>Region:</strong> The geographical region or business unit</li>
                    </ul>
                </li>
                <li>🔄 <strong>Benefits:</strong>
                    <ul style="margin-top: 5px;">
                        <li>Switch between ID, Name, or Region display in tables</li>
                        <li>Better readability in reports</li>
                        <li>Enhanced filtering and sorting capabilities</li>
                    </ul>
                </li>
            </ul>
            
            <h3>📤 Step 2: Uploading Files</h3>
            
            <h4>Upload Methods</h4>
            <ul>
                <li><strong>🖱️ Drag & Drop (Recommended):</strong>
                    <ol style="margin-top: 5px; font-size: 0.9em;">
                        <li>Select all files in Windows Explorer/Mac Finder</li>
                        <li>Drag files over the dotted upload area</li>
                        <li>Release when area highlights in blue</li>
                    </ol>
                </li>
                <li><strong>📂 Click to Browse:</strong>
                    <ol style="margin-top: 5px; font-size: 0.9em;">
                        <li>Click anywhere in the upload area</li>
                        <li>Navigate to your files location</li>
                        <li>Select files (use Ctrl/Cmd for multiple)</li>
                        <li>Click "Open" to upload</li>
                    </ol>
                </li>
            </ul>
            
            <h4>Upload Feedback</h4>
            <ul>
                <li>✅ <strong>Green checkmarks:</strong> File successfully loaded</li>
                <li>❌ <strong>Red X:</strong> File format or naming issue</li>
                <li>📊 <strong>File counter:</strong> Shows total files uploaded</li>
            </ul>
            
            <h4>ID Cross-Reference Upload</h4>
            <p>After uploading your main data files, you can optionally upload an ID cross-reference file:</p>
            <ul>
                <li>📍 <strong>Location:</strong> Separate upload area below the main file upload section</li>
                <li>🔄 <strong>Dynamic Updates:</strong> Tables will immediately show filter buttons for ID/Name/Region switching</li>
                <li>❌ <strong>Remove Option:</strong> Click "Remove" to clear the cross-reference and revert to ID-only display</li>
            </ul>
            
            <h3>🔍 Step 3: Running the Analysis</h3>
            
            <h4>Pre-Analysis Checks</h4>
            <p>The tool automatically performs these validations:</p>
            <ul>
                <li>✓ Customer name detection from filenames</li>
                <li>✓ Period extraction (YYYYMM format)</li>
                <li>✓ Sheet availability verification</li>
                <li>✓ Data format consistency checks</li>
            </ul>
            
            <h4>Starting Analysis</h4>
            <ol>
                <li><strong>Review uploaded files:</strong> Check the file list shows all expected files</li>
                <li><strong>Click "Analyze Files":</strong> Button becomes active after successful uploads</li>
                <li><strong>Wait for processing:</strong> 
                    <ul style="margin-top: 5px; font-size: 0.9em;">
                        <li>Small datasets (< 10 files): 5-10 seconds</li>
                        <li>Large datasets (> 50 files): 30-60 seconds</li>
                    </ul>
                </li>
                <li><strong>View results:</strong> Report automatically displays when complete</li>
            </ol>
            
            <h3>📊 Step 4: Navigating Your Report</h3>
            
            <h4>Report Interface</h4>
            <ul>
                <li><strong>🔼 Minimize Button (-):</strong> Collapse upload area for more screen space</li>
                <li><strong>⛶ Maximize Button:</strong> Full-screen report view</li>
                <li><strong>📑 Navigation Tabs:</strong> Click to switch between analysis views
                    <ul style="margin-top: 5px; font-size: 0.9em;">
                        <li>Overview → Executive dashboard</li>
                        <li>Month over Month → Period comparisons</li>
                        <li>Hub Analysis → Network performance</li>
                        <li>TP Analysis → Partner insights</li>
                        <li>Document Analysis → Type breakdown</li>
                    </ul>
                </li>
            </ul>
            
            <h4>Interactive Features</h4>
            <ul>
                <li><strong>📈 Charts:</strong>
                    <ul style="margin-top: 5px; font-size: 0.9em;">
                        <li>Hover over data points for details</li>
                        <li>Click legend items to show/hide series</li>
                        <li>Zoom capability on trend charts</li>
                    </ul>
                </li>
                <li><strong>📋 Tables:</strong>
                    <ul style="margin-top: 5px; font-size: 0.9em;">
                        <li>Sortable columns (click headers)</li>
                        <li>Search boxes for filtering</li>
                        <li>Sticky headers/columns for scrolling</li>
                        <li>Export buttons (JSON/CSV) where available</li>
                        <li><strong>ID/Name/Region Toggle:</strong> When cross-reference file is loaded, filter buttons appear above tables to switch display</li>
                    </ul>
                </li>
                <li><strong>🎨 Color Coding:</strong>
                    <ul style="margin-top: 5px; font-size: 0.9em;">
                        <li>🟢 Green: Positive performance/growth</li>
                        <li>🔴 Red: Negative performance/decline</li>
                        <li>🔵 Blue: Neutral/informational</li>
                        <li>🟡 Yellow: Warning/attention needed</li>
                    </ul>
                </li>
            </ul>
            
            <h3>💾 Step 5: Exporting & Sharing</h3>
            
            <h4>Export Options</h4>
            <ul>
                <li><strong>📊 Table Data Export:</strong>
                    <ul style="margin-top: 5px; font-size: 0.9em;">
                        <li>Look for export buttons above tables</li>
                        <li>JSON format: For technical integration</li>
                        <li>CSV format: For Excel/spreadsheet use</li>
                    </ul>
                </li>
                <li><strong>💾 Full Report Export:</strong>
                    <ul style="margin-top: 5px; font-size: 0.9em;">
                        <li>Click the green save button (💾) in the top right corner</li>
                        <li>Report will download as an HTML file</li>
                        <li>File includes all charts, tables, and formatting</li>
                        <li>Can be opened in any web browser</li>
                    </ul>
                </li>
            </ul>
            
            <h3>🔧 Troubleshooting</h3>
            
            <h4>Common Issues & Solutions</h4>
            <ul>
                <li><strong>❌ "Invalid file format" error:</strong>
                    <ul style="margin-top: 5px; font-size: 0.9em;">
                        <li>Ensure files are .xlsx (not .xls or .csv)</li>
                        <li>Check file isn't corrupted or password-protected</li>
                    </ul>
                </li>
                <li><strong>❌ "Customer detection failed":</strong>
                    <ul style="margin-top: 5px; font-size: 0.9em;">
                        <li>Verify filename follows pattern: Customer_Type_YYYYMM.xlsx</li>
                        <li>Ensure consistent customer name across all files</li>
                    </ul>
                </li>
                <li><strong>❌ "Missing sheets" warning:</strong>
                    <ul style="margin-top: 5px; font-size: 0.9em;">
                        <li>Check Excel file contains all 5 required sheets</li>
                        <li>Verify sheet names match exactly (case-sensitive)</li>
                    </ul>
                </li>
                <li><strong>⚠️ Slow performance:</strong>
                    <ul style="margin-top: 5px; font-size: 0.9em;">
                        <li>Close other browser tabs</li>
                        <li>Use Chrome/Edge for best performance</li>
                        <li>Process files in batches of 12 or less</li>
                    </ul>
                </li>
            </ul>
            
            <h3>💡 Pro Tips</h3>
            <ul>
                <li>🎯 <strong>Optimal Analysis:</strong> Upload 6-12 months of consecutive data</li>
                <li>🔄 <strong>Regular Updates:</strong> Run analysis monthly for trend tracking</li>
                <li>📈 <strong>Focus Areas:</strong> Start with Overview, then drill into specific tabs</li>
                <li>🤝 <strong>Collaboration:</strong> Export key tables for team discussions</li>
            </ul>
        </div>
    </div>
    
    <!-- Explanations Modal -->
    <div id="explanationsModal" class="modal" onclick="if(event.target === this) closeModal('explanationsModal')">
        <div class="modal-content">
            <button class="modal-close" onclick="closeModal('explanationsModal')">✕</button>
            <h2>📊 Complete Guide to Analysis Tools</h2>
            
            <h3>🗂️ Data Structure & Requirements</h3>
            
            <h4>File Naming Convention</h4>
            <p>Files must follow this pattern: <code>CustomerName_DataType_YYYYMM.xlsx</code></p>
            <ul>
                <li>✅ Example: <code>ACME_Reports_202307.xlsx</code></li>
                <li>❌ Invalid: <code>July2023_ACME.xlsx</code></li>
            </ul>
            
            <h4>Required Excel Sheets</h4>
            <p>Each Excel file should contain these standardized sheets:</p>
            <ul>
                <li><strong>Date_Summary:</strong> Daily/period aggregated metrics
                    <ul style="margin-top: 5px; font-size: 0.9em;">
                        <li>Columns: DATE, TOTAL-DOC, TOTAL-KCS, INB-DOC, INB-KCS, OUT-DOC, OUT-KCS</li>
                        <li>Purpose: Time-series analysis and trend identification</li>
                    </ul>
                </li>
                <li><strong>Doc_Summary:</strong> Document type aggregations
                    <ul style="margin-top: 5px; font-size: 0.9em;">
                        <li>Columns: DOC, INB-DOC, INB-KCS, OUT-DOC, OUT-KCS, TOTAL-DOC, TOTAL-KCS</li>
                        <li>Purpose: Document type distribution and efficiency analysis</li>
                    </ul>
                </li>
                <li><strong>Hub_Summary:</strong> Hub performance metrics
                    <ul style="margin-top: 5px; font-size: 0.9em;">
                        <li>Columns: HUB ID, INB-DOC, INB-KCS, OUT-DOC, OUT-KCS, TOTAL-DOC, TOTAL-KCS</li>
                        <li>Purpose: Network hub efficiency and load distribution</li>
                    </ul>
                </li>
                <li><strong>TP_Summary:</strong> Trading partner summaries
                    <ul style="margin-top: 5px; font-size: 0.9em;">
                        <li>Columns: TP ID, INB-DOC, INB-KCS, OUT-DOC, OUT-KCS, TOTAL-DOC, TOTAL-KCS</li>
                        <li>Purpose: Partner relationship analysis and rankings</li>
                    </ul>
                </li>
                <li><strong>TP_Doc_Summary:</strong> Trading partner document matrix
                    <ul style="margin-top: 5px; font-size: 0.9em;">
                        <li>Columns: TP ID, DOCS, INB-DOC, INB-KCS, OUT-DOC, OUT-KCS, TOTAL-DOC, TOTAL-KCS</li>
                        <li>Purpose: Detailed TP-document type relationships</li>
                    </ul>
                </li>
            </ul>
            
            <h3>📈 Analysis Features - Detailed Guide</h3>
            
            <h4>🏠 Overview Tab - Executive Dashboard</h4>
            <ul>
                <li><strong>Key Business Insights:</strong> 
                    <ul style="margin-top: 5px; font-size: 0.9em;">
                        <li>Data-driven analysis based on entire period analyzed</li>
                        <li>Color-coded insights: Green (positive), Yellow (attention), Red (action needed)</li>
                        <li>Covers growth trends, efficiency, partner concentration, seasonality</li>
                        <li>Provides specific recommendations for each insight</li>
                    </ul>
                </li>
                <li><strong>Performance Scorecard:</strong> 
                    <ul style="margin-top: 5px; font-size: 0.9em;">
                        <li>Overall Health combining both Document and KC metrics</li>
                        <li>Health status: Excellent (🌟), Healthy (✅), Warning (⚠️), Critical (❌)</li>
                        <li>Volume Trend showing expansion, contraction, mixed, or stable patterns</li>
                        <li>3-month metrics with detailed growth analysis</li>
                    </ul>
                </li>
                <li><strong>Document & KC Summaries:</strong> 
                    <ul style="margin-top: 5px; font-size: 0.9em;">
                        <li>Current period volumes with growth indicators</li>
                        <li>Efficiency Score (formerly KC per Document) with info tooltips</li>
                        <li>Period averages and total volumes</li>
                        <li>Year-over-Year comparisons when available</li>
                    </ul>
                </li>
                <li><strong>Volume Charts:</strong> Dual-axis line charts showing document count and KC volume trends</li>
                <li><strong>Seasonality Pattern:</strong> 
                    <ul style="margin-top: 5px; font-size: 0.9em;">
                        <li>Monthly variation from average</li>
                        <li>Multi-year support with year filtering</li>
                        <li>Identifies seasonal peaks and valleys</li>
                    </ul>
                </li>
                <li><strong>Comparative Analysis:</strong> Side-by-side period comparisons with growth percentages</li>
            </ul>
            
            <h4>📅 Month over Month Tab - Trend Analysis</h4>
            <ul>
                <li><strong>Period Comparison Table:</strong> 
                    <ul style="margin-top: 5px; font-size: 0.9em;">
                        <li>All periods displayed with fully sortable columns (click headers to sort)</li>
                        <li>Growth rates calculated automatically</li>
                        <li>Efficiency ratios (Doc/KC) for each period</li>
                        <li>Color-coded performance indicators</li>
                        <li>Sort indicators show current sort direction (↕ ↑ ↓)</li>
                    </ul>
                </li>
                <li><strong>Trading Partner Monthly Performance:</strong> 
                    <ul style="margin-top: 5px; font-size: 0.9em;">
                        <li>Document counts by TP and month</li>
                        <li>KC volumes by TP and month</li>
                        <li>Sortable by total volume</li>
                        <li>Heat map coloring for quick pattern identification</li>
                    </ul>
                </li>
                <li><strong>Document Type Behavior:</strong> Interactive sparklines showing type trends over time</li>
            </ul>
            
            <h4>🌐 Hub Analysis Tab - Network Performance</h4>
            <ul>
                <li><strong>Hub Metrics Cards:</strong> 
                    <ul style="margin-top: 5px; font-size: 0.9em;">
                        <li>Identified Hubs: Count of unique hub IDs</li>
                        <li>Total Documents: Sum across all hubs</li>
                        <li>Total Kilocharacters: Aggregate KC volume</li>
                    </ul>
                </li>
                <li><strong>Distribution Pie Charts:</strong> 
                    <ul style="margin-top: 5px; font-size: 0.9em;">
                        <li>Document distribution by hub (% and counts)</li>
                        <li>KC distribution by hub (% and volumes)</li>
                        <li>Interactive hover details</li>
                    </ul>
                </li>
                <li><strong>Performance Analysis Cards:</strong> 
                    <ul style="margin-top: 5px; font-size: 0.9em;">
                        <li>Doc/KC Ratio: Higher = Better (green), Lower = Warning (red)</li>
                        <li>KC/Doc Ratio: Lower = Better (green), Higher = Warning (red)</li>
                        <li>Average Documents per Hub</li>
                    </ul>
                </li>
                <li><strong>Volume Trend Charts:</strong> 
                    <ul style="margin-top: 5px; font-size: 0.9em;">
                        <li>Multi-select hub filter</li>
                        <li>Document and KC volume over time</li>
                        <li>Trend lines and projections</li>
                    </ul>
                </li>
                <li><strong>Exportable Tables:</strong> 
                    <ul style="margin-top: 5px; font-size: 0.9em;">
                        <li>Hub Performance Details (JSON/CSV export)</li>
                        <li>Monthly Document Distribution (JSON/CSV export)</li>
                        <li>Monthly KC Distribution (JSON/CSV export)</li>
                    </ul>
                </li>
            </ul>
            
            <h4>🤝 TP Analysis Tab - Partner Intelligence</h4>
            <ul>
                <li><strong>Trading Partner Performance:</strong> 
                    <ul style="margin-top: 5px; font-size: 0.9em;">
                        <li>Comprehensive table with health scores and rankings</li>
                        <li>All columns sortable - click headers to sort</li>
                        <li>Health score badges (Excellent, Good, Fair, Needs Attention)</li>
                        <li>Growth trends with visual indicators</li>
                        <li>Inbound/Outbound volume breakdown</li>
                    </ul>
                </li>
                <li><strong>Partner Concentration Analysis:</strong> 
                    <ul style="margin-top: 5px; font-size: 0.9em;">
                        <li>Key insights based on actual data (not default values)</li>
                        <li>Shows actual percentages for top partners</li>
                        <li>80/20 Rule analysis with real partner counts</li>
                        <li>Distribution metrics showing partners above average</li>
                    </ul>
                </li>
                <li><strong>Growth & Trend Analysis:</strong> 
                    <ul style="margin-top: 5px; font-size: 0.9em;">
                        <li>Growing Partners and Declining Partners tables</li>
                        <li>Volume trend charts for top 5 partners</li>
                        <li>Partner seasonality analysis</li>
                    </ul>
                </li>
                <li><strong>Document Analysis by Partner:</strong> 
                    <ul style="margin-top: 5px; font-size: 0.9em;">
                        <li>Document type distribution charts</li>
                        <li>TP-Document matrix with search filters</li>
                        <li>Heat map visualization by volume</li>
                        <li>Export capabilities for all tables</li>
                    </ul>
                </li>
            </ul>
            
            <h4>📄 Document Analysis Tab - Type Intelligence</h4>
            <ul>
                <li><strong>Document Volume Summary:</strong> 
                    <ul style="margin-top: 5px; font-size: 0.9em;">
                        <li>Comprehensive table of all document types</li>
                        <li>Sortable columns - click any header to sort</li>
                        <li>Shows total documents, percentages, and growth trends</li>
                        <li>Inbound/Outbound breakdown with directional insights</li>
                        <li>Average KC per document for complexity analysis</li>
                    </ul>
                </li>
                <li><strong>Trend Analysis:</strong> 
                    <ul style="margin-top: 5px; font-size: 0.9em;">
                        <li>Dual-axis chart showing documents and KC volumes</li>
                        <li>Monthly breakdown tables with sortable columns</li>
                        <li>Seasonality Pattern with multi-year support and filtering</li>
                        <li>Period-over-period growth indicators</li>
                    </ul>
                </li>
                <li><strong>Advanced Analytics:</strong> 
                    <ul style="margin-top: 5px; font-size: 0.9em;">
                        <li>Document type distribution pie chart</li>
                        <li>Efficiency analysis by document type</li>
                        <li>Automated insights on document patterns</li>
                        <li>Export functionality (removed Export Analysis button as requested)</li>
                    </ul>
                </li>
            </ul>
            
            <h3>📐 Metrics & Calculations Explained</h3>
            
            <h4>Core Metrics</h4>
            <ul>
                <li><strong>Documents (DOC):</strong> 
                    <ul style="margin-top: 5px; font-size: 0.9em;">
                        <li>Definition: Total count of processed electronic documents</li>
                        <li>Components: INB-DOC (inbound) + OUT-DOC (outbound)</li>
                        <li>Usage: Volume tracking, capacity planning</li>
                    </ul>
                </li>
                <li><strong>Kilocharacters (KC):</strong> 
                    <ul style="margin-top: 5px; font-size: 0.9em;">
                        <li>Definition: Document size in thousands of characters (1 KC = 1,000 characters)</li>
                        <li>Components: INB-KCS (inbound) + OUT-KCS (outbound)</li>
                        <li>Usage: Data volume analysis, bandwidth planning</li>
                    </ul>
                </li>
            </ul>
            
            <h4>Performance Indicators</h4>
            <ul>
                <li><strong>Growth Rate (%):</strong> 
                    <ul style="margin-top: 5px; font-size: 0.9em;">
                        <li>Formula: ((Current - Previous) / Previous) × 100</li>
                        <li>Interpretation: Positive = Growth (green), Negative = Decline (red)</li>
                        <li>Usage: Trend identification, forecasting</li>
                    </ul>
                </li>
                <li><strong>Doc/KC Ratio:</strong> 
                    <ul style="margin-top: 5px; font-size: 0.9em;">
                        <li>Formula: Total Documents ÷ Total KCs</li>
                        <li>Interpretation: Higher ratio = Better efficiency (more docs per KC)</li>
                        <li>Color coding: >2.0 (green), 1.0-2.0 (yellow), <1.0 (red)</li>
                        <li>Usage: Processing efficiency measurement</li>
                    </ul>
                </li>
                <li><strong>Efficiency Score (KC/Doc Ratio):</strong> 
                    <ul style="margin-top: 5px; font-size: 0.9em;">
                        <li>Formula: Total KCs ÷ Total Documents</li>
                        <li>Interpretation: Lower scores (1-3 KC/doc) indicate efficient, streamlined documents</li>
                        <li>Higher scores (>5 KC/doc) may indicate verbose documents or data-heavy transmissions</li>
                        <li>Industry best practice targets 2-4 KC/doc for most document types</li>
                        <li>Now displayed with helpful info tooltips throughout the application</li>
                    </ul>
                </li>
            </ul>
            
            <h4>Advanced Metrics</h4>
            <ul>
                <li><strong>YoY (Year-over-Year):</strong> 
                    <ul style="margin-top: 5px; font-size: 0.9em;">
                        <li>Formula: ((Current Year - Previous Year) / Previous Year) × 100</li>
                        <li>Purpose: Long-term trend analysis</li>
                    </ul>
                </li>
                <li><strong>Market Share (%):</strong> 
                    <ul style="margin-top: 5px; font-size: 0.9em;">
                        <li>Formula: (Partner Volume / Total Volume) × 100</li>
                        <li>Purpose: Partner concentration analysis</li>
                    </ul>
                </li>
                <li><strong>Average Daily Volume:</strong> 
                    <ul style="margin-top: 5px; font-size: 0.9em;">
                        <li>Formula: Total Volume / Days in Period</li>
                        <li>Purpose: Capacity planning and forecasting</li>
                    </ul>
                </li>
            </ul>
            
            <h4>Network Identifiers</h4>
            <ul>
                <li><strong>Hub ID:</strong> Unique identifier for processing locations in the network</li>
                <li><strong>TP ID:</strong> Trading Partner identifier for B2B relationships</li>
                <li><strong>Document Type:</strong> Classification of document content (e.g., INV, ORD, DES)</li>
            </ul>
            
            <h3>🎯 Using the Analysis Effectively</h3>
            
            <h4>Best Practices</h4>
            <ul>
                <li>📊 <strong>Upload Multiple Periods:</strong> Include at least 3-6 months for meaningful trend analysis</li>
                <li>🔍 <strong>Check Data Quality:</strong> Ensure all required sheets are present in Excel files</li>
                <li>📈 <strong>Focus on Trends:</strong> Look for patterns rather than individual data points</li>
                <li>🎨 <strong>Use Color Coding:</strong> Green = Good performance, Red = Needs attention</li>
                <li>💾 <strong>Export Key Tables:</strong> Save important analyses for offline review</li>
            </ul>
            
            <h4>Common Analysis Scenarios</h4>
            <ul>
                <li><strong>Performance Review:</strong> Start with Overview tab for executive summary</li>
                <li><strong>Partner Analysis:</strong> Use TP Analysis to identify top performers</li>
                <li><strong>Efficiency Audit:</strong> Check Hub Analysis for Doc/KC ratios</li>
                <li><strong>Capacity Planning:</strong> Review Month over Month trends</li>
                <li><strong>Document Type Study:</strong> Analyze distribution in Document Analysis tab</li>
            </ul>
            
            <h3>✨ New Features & Enhancements</h3>
            
            <h4>Universal Table Sorting</h4>
            <ul>
                <li>🖱️ <strong>Click any column header</strong> to sort that table</li>
                <li>📊 <strong>Automatic detection</strong> of numeric vs text data</li>
                <li>🔄 <strong>Toggle between</strong> ascending (↑) and descending (↓) order</li>
                <li>👁️ <strong>Visual indicators</strong> show current sort column and direction</li>
                <li>💾 <strong>Persistent sorting</strong> within each session</li>
            </ul>
            
            <h4>Enhanced Health Metrics</h4>
            <ul>
                <li><strong>Combined Health Score:</strong> Now analyzes both Document AND KC trends together</li>
                <li><strong>Intelligent Interpretations:</strong> 
                    <ul style="margin-top: 5px; font-size: 0.9em;">
                        <li>Both growing = Business expansion</li>
                        <li>Docs up, KCs down = Efficiency improving</li>
                        <li>Docs down, KCs up = Complexity increasing</li>
                        <li>Both declining = Needs immediate attention</li>
                    </ul>
                </li>
                <li><strong>Detailed Explanations:</strong> Each health status includes comprehensive reasoning</li>
            </ul>
            
            <h4>Multi-Year Seasonality Support</h4>
            <ul>
                <li>📅 <strong>Automatic year detection</strong> when multiple years present</li>
                <li>🎚️ <strong>Year filter dropdown</strong> to analyze specific years or all data</li>
                <li>📈 <strong>Separate calculations</strong> for each year's seasonal patterns</li>
                <li>🔍 <strong>Available on both</strong> Overview and Document Analysis tabs</li>
            </ul>
            
            <h4>Converter Tools Integration</h4>
            <ul>
                <li>🔄 <strong>MS Classic Converter:</strong> Convert MS Classic CSV to TG Billing format</li>
                <li>📁 <strong>TG CSV Converter:</strong> Convert TG CSV files to Excel format</li>
                <li>📖 <strong>Built-in help guides</strong> for each converter tool</li>
                <li>🚀 <strong>Quick access</strong> from the main menu</li>
            </ul>
        </div>
    </div>
    
    <!-- About Modal -->
    <div id="aboutModal" class="modal" onclick="if(event.target === this) closeModal('aboutModal')">
        <div class="modal-content">
            <button class="modal-close" onclick="closeModal('aboutModal')">✕</button>
            <h2>ℹ️ About Customer Data Analyzer</h2>
            
            <h3>Overview</h3>
            <p>Customer Data Analyzer is an advanced browser-based analytics platform designed for comprehensive operational data analysis. It transforms raw Excel and CSV data into actionable insights through sophisticated visualizations, trend analysis, and performance metrics.</p>
            
            <h3>Created By</h3>
            <p><strong>Stephen Clarke</strong><br>
            Initial Release: July 24, 2025<br>
            Latest Update: July 26, 2025</p>
            
            <h3>Version</h3>
            <p><strong>3.0 - Enhanced Analytics Platform</strong><br>
            <em>Featuring Hub Analysis, Advanced Export Capabilities, and Performance Optimizations</em></p>
            
            <h3>🚀 Key Features</h3>
            
            <h4>Data Processing</h4>
            <ul>
                <li>🔒 100% client-side processing - your data never leaves your browser</li>
                <li>📊 Support for Excel (.xlsx)</li>
                <li>🤖 Intelligent customer and pattern detection</li>
                <li>⚡ Bulk file processing with automatic period detection</li>
                <li>🔍 Automatic data validation and error handling</li>
            </ul>
            
            <h4>Analysis Capabilities</h4>
            <ul>
                <li>📈 Multi-period trend analysis with growth calculations</li>
                <li>🎯 Five specialized analysis views: Overview, Month-over-Month, Hub, Trading Partner, and Document</li>
                <li>🌐 Hub network performance tracking and efficiency metrics</li>
                <li>🤝 Trading partner rankings and concentration analysis</li>
                <li>📄 Document type distribution and behavior patterns</li>
                <li>📊 Interactive charts with hover details and trend lines</li>
                <li>🔎 Searchable and filterable data matrices</li>
            </ul>
            
            <h4>Export & Reporting</h4>
            <ul>
                <li>💾 Export tables to JSON and CSV formats</li>
                <li>📱 Responsive design for all screen sizes</li>
            </ul>
            
            <h3>💻 Technical Architecture</h3>
            <ul>
                <li><strong>Core:</strong> Pure JavaScript (ES6+) with modular class architecture</li>
                <li><strong>Visualizations:</strong> Chart.js 3.9.1 with custom configurations</li>
                <li><strong>Excel Processing:</strong> SheetJS (XLSX) for robust file handling</li>
                <li><strong>UI Framework:</strong> Custom CSS with glassmorphism effects</li>
                <li><strong>Performance:</strong> Optimized for datasets with 100,000+ records</li>
            </ul>
            
            <h3>🔐 Privacy & Security</h3>
            <ul>
                <li>✅ All processing happens locally in your browser</li>
                <li>✅ No data transmission to external servers</li>
                <li>✅ No cookies or tracking mechanisms</li>
                <li>✅ No user data retention</li>
                <li>✅ Secure browser-based computation only</li>
            </ul>
            
            <h3>📋 Data Requirements</h3>
            <p>For optimal analysis, your Excel files should contain these sheets:</p>
            <ul>
                <li><strong>Date_Summary:</strong> Time-series operational metrics</li>
                <li><strong>Doc_Summary:</strong> Document type aggregations</li>
                <li><strong>Hub_Summary:</strong> Hub-level performance data</li>
                <li><strong>TP_Summary:</strong> Trading partner summaries</li>
                <li><strong>TP_Doc_Summary:</strong> Detailed TP-document relationships</li>
            </ul>
            
            <h3>🎯 Use Cases</h3>
            <ul>
                <li>Supply chain performance monitoring</li>
                <li>Trading partner relationship analysis</li>
                <li>Document processing efficiency tracking</li>
                <li>Network hub optimization</li>
                <li>Operational trend identification</li>
                <li>Period-over-period comparisons</li>
            </ul>
            
            <h3>🔄 Recent Updates</h3>
            <ul>
                <li><strong>v3.0 (July 2025):</strong> Added Hub Analysis, export capabilities, performance metrics</li>
                <li><strong>v2.0 (July 2025):</strong> Complete JavaScript rewrite, removed Python dependencies</li>
                <li><strong>v1.0 (July 2025):</strong> Initial release with basic analysis features</li>
            </ul>
            
            <h3>⚖️ License & Attribution</h3>
            <p>This tool is proprietary software. All rights reserved.<br>
            Built with open-source libraries under their respective licenses.</p>
        </div>
    </div>
    
    <div class="upload-container" id="analyzerSection">
        <div style="position: relative;">
            <button class="minimize-btn" onclick="toggleAnalyzerSection()" title="Minimize/Expand">
                <span id="minimizeIcon">−</span>
            </button>
            <h1>Customer Data Analyzer</h1>
            <p id="analyzerSubtitle">Upload Excel files to analyze customer data<br><small style="color: #e53e3e; font-weight: 500;">Required format: CustomerName_*_YYYYMM.xlsx</small></p>
        </div>
        
        <div id="analyzerContent">
            <div class="upload-area" id="uploadArea">
                <p>Drag and drop files here or click to select</p>
                <input type="file" id="fileInput" multiple accept=".xlsx,.xls,.xlsm,.csv" style="display: none;">
            </div>
            
            <div class="xref-upload-section" style="margin-top: 20px; padding: 20px; background: #f8f9fa; border-radius: 8px; border: 1px solid #dee2e6;">
                <h3 style="margin-top: 0; color: #2d3748;">ID Cross-Reference File (Optional)</h3>
                <p style="color: #4a5568; margin-bottom: 15px;">Upload a file containing ID, Name, and Region columns for cross-referencing</p>
                <div class="upload-area" id="xrefUploadArea" style="padding: 15px; background: white;">
                    <p>Drag and drop cross-reference file here or click to select</p>
                    <input type="file" id="xrefFileInput" accept=".xlsx,.xls,.xlsm,.csv" style="display: none;">
                </div>
                <div id="xrefFileInfo" style="margin-top: 10px; display: none;">
                    <span style="color: #38a169;">✓ Cross-reference file loaded: </span>
                    <span id="xrefFileName"></span>
                    <button id="removeXref" style="margin-left: 10px; padding: 5px 10px; background: #e53e3e; color: white; border: none; border-radius: 4px; cursor: pointer;">Remove</button>
                </div>
            </div>
        
        <div id="fileList" class="file-list"></div>
        
            <button id="analyzeBtn" class="analyze-btn" onclick="analyzeFiles()" disabled>Analyze Files</button>
            
            <div id="progressContainer" class="progress-container">
                <div class="progress-bar-wrapper">
                    <div id="progressBar" class="progress-bar"></div>
                </div>
                <div id="progressText" class="progress-text">0%</div>
                <div id="progressStatus" class="progress-status">Initializing...</div>
                <div id="progressDetails" class="progress-details"></div>
            </div>
            
            <div id="status" class="status"></div>
        </div>
    </div>
    
    <iframe id="reportFrame"></iframe>
    <button class="maximize-btn" id="maximizeBtn" onclick="toggleMaximize()" title="Maximize/Restore">⛶</button>
    <button class="maximize-btn" id="exportBtn" onclick="exportGeneratedReport()" title="Export Report" style="display: none; right: 60px; background: #4CAF50;">
        💾
    </button>

<script>
/**
 * Toggle minimize/expand analyzer section
 * Controls the visibility of the main analyzer content area
 * Allows users to minimize the upload section to see more of the report
 */
function toggleAnalyzerSection() {
    const analyzerSection = document.getElementById('analyzerSection');
    const minimizeIcon = document.getElementById('minimizeIcon');
    
    if (analyzerSection.classList.contains('minimized')) {
        // Expand the section
        analyzerSection.classList.remove('minimized');
        minimizeIcon.textContent = '−';
    } else {
        // Minimize the section
        analyzerSection.classList.add('minimized');
        minimizeIcon.textContent = '+';
    }
}

/**
 * Toggle maximize/restore report frame
 * Switches between fullscreen and normal view for the analysis report
 * Hides analyzer section when maximized for better viewing experience
 */
function toggleMaximize() {
    const reportFrame = document.getElementById('reportFrame');
    const maximizeBtn = document.getElementById('maximizeBtn');
    const analyzerSection = document.getElementById('analyzerSection');
    
    if (reportFrame.classList.contains('maximized')) {
        // Restore normal view
        reportFrame.classList.remove('maximized');
        maximizeBtn.innerHTML = '⛶';
        maximizeBtn.title = 'Maximize';
        analyzerSection.style.display = 'block';
    } else {
        // Maximize to fullscreen
        reportFrame.classList.add('maximized');
        maximizeBtn.innerHTML = '⛌';
        maximizeBtn.title = 'Restore';
        analyzerSection.style.display = 'none';
    }
}

/**
 * Utility function to create a debounced version of a function
 * Prevents rapid repeated calls by delaying execution
 * @param {Function} func - Function to debounce
 * @param {number} wait - Delay in milliseconds
 * @returns {Function} Debounced function
 */
function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
}

/**
 * Global variables for application state management
 * These maintain the state of uploaded files and UI references throughout the session
 */
let uploadedFiles = [];    // Array of File objects uploaded by user
let analyzer = null;       // Instance of DynamicDataAnalyzer class
let fileList = null;       // Reference to file list DOM element
let analyzeBtn = null;     // Reference to analyze button DOM element

/**
 * Initialize file handling after DOM is loaded
 * Sets up drag-and-drop and click-to-upload functionality
 * Ensures all required DOM elements are available before binding events
 */
document.addEventListener('DOMContentLoaded', function() {
    // Get references to file handling elements
    const uploadArea = document.getElementById('uploadArea');
    const fileInput = document.getElementById('fileInput');
    fileList = document.getElementById('fileList');
    analyzeBtn = document.getElementById('analyzeBtn');

    if (uploadArea && fileInput) {
        // Enable click-to-upload functionality
        uploadArea.addEventListener('click', () => {
            fileInput.click();
        });
        
        // Handle drag over event - show visual feedback
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault(); // Prevent default browser behavior
            uploadArea.classList.add('dragover');
        });
        
        // Handle drag leave event - remove visual feedback
        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });
        
        // Create debounced version of handleFiles to prevent rapid repeated calls
        const debouncedHandleFiles = debounce(handleFiles, 300);
        
        // Handle file drop event with debouncing
        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault(); // Prevent browser from opening the file
            uploadArea.classList.remove('dragover');
            debouncedHandleFiles(e.dataTransfer.files);
        });

        // Handle file selection via file picker dialog with debouncing
        fileInput.addEventListener('change', (e) => {
            debouncedHandleFiles(e.target.files);
        });
    } else {
        console.error('Upload area or file input not found');
    }
    
    // Handle cross-reference file upload
    const xrefUploadArea = document.getElementById('xrefUploadArea');
    const xrefFileInput = document.getElementById('xrefFileInput');
    const xrefFileInfo = document.getElementById('xrefFileInfo');
    const xrefFileName = document.getElementById('xrefFileName');
    const removeXrefBtn = document.getElementById('removeXref');
    
    if (xrefUploadArea && xrefFileInput) {
        // Enable click-to-upload functionality for xref
        xrefUploadArea.addEventListener('click', () => {
            xrefFileInput.click();
        });
        
        // Handle drag over event - show visual feedback
        xrefUploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            xrefUploadArea.classList.add('dragover');
        });
        
        // Handle drag leave event - remove visual feedback
        xrefUploadArea.addEventListener('dragleave', () => {
            xrefUploadArea.classList.remove('dragover');
        });
        
        // Handle file drop event
        xrefUploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            xrefUploadArea.classList.remove('dragover');
            if (e.dataTransfer.files.length > 0) {
                handleXrefFile(e.dataTransfer.files[0]);
            }
        });
        
        // Handle file selection via file picker dialog
        xrefFileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleXrefFile(e.target.files[0]);
            }
        });
        
        // Handle remove button
        removeXrefBtn.addEventListener('click', () => {
            window.idCrossReference = null;
            xrefFileInfo.style.display = 'none';
            xrefFileName.textContent = '';
            xrefFileInput.value = '';
            // Refresh any displayed tables if report is already generated
            const reportFrame = document.getElementById('reportFrame');
            if (reportFrame && reportFrame.srcdoc) {
                updateAllTablesWithCrossRef();
            }
        });
    }
});

/**
 * File validation constants
 */
const FILE_VALIDATION = {
    MAX_FILE_SIZE: 50 * 1024 * 1024, // 50MB
    ALLOWED_EXTENSIONS: /\.(xlsx?|xlsm?|csv)$/i,
    MAX_FILES: 50
};

/**
 * Handle file upload/drop events
 * Validates file types and adds unique files to the upload queue
 * @param {FileList} files - Files selected or dropped by user
 */
function handleFiles(files) {
    const errors = [];
    const validFiles = [];
    
    // Check total file count
    if (uploadedFiles.length + files.length > FILE_VALIDATION.MAX_FILES) {
        showStatus(`Maximum ${FILE_VALIDATION.MAX_FILES} files allowed`, 'error');
        return;
    }
    
    // Validate each file
    Array.from(files).forEach(file => {
        // Check file extension
        if (!file.name.match(FILE_VALIDATION.ALLOWED_EXTENSIONS)) {
            errors.push(`${file.name}: Invalid file type. Only Excel (.xlsx, .xls, .xlsm) and CSV files are allowed.`);
            return;
        }
        
        // Check file size
        if (file.size > FILE_VALIDATION.MAX_FILE_SIZE) {
            errors.push(`${file.name}: File too large. Maximum size is ${FILE_VALIDATION.MAX_FILE_SIZE / 1024 / 1024}MB.`);
            return;
        }
        
        // Check for duplicates
        if (uploadedFiles.find(f => f.name === file.name)) {
            errors.push(`${file.name}: File already uploaded.`);
            return;
        }
        
        // Validate filename format
        if (!validateFilenameFormat(file.name)) {
            errors.push(`${file.name}: Invalid filename format. Expected: CustomerName_Description_YYYYMM.xlsx`);
            return;
        }
        
        validFiles.push(file);
    });
    
    // Show errors if any
    if (errors.length > 0) {
        showStatus(errors.join(' | '), 'error');
    }
    
    // Add valid files
    validFiles.forEach(file => {
        uploadedFiles.push(file);
    });
    
    // Update UI
    updateFileList();
    
    // Enable analyze button if files are present
    if (analyzeBtn) {
        analyzeBtn.disabled = uploadedFiles.length === 0;
    }
    
    // Show success message
    if (validFiles.length > 0) {
        showStatus(`Added ${validFiles.length} file(s) successfully`, 'success');
    }
}

/**
 * Validate filename format
 * @param {string} filename - Filename to validate
 * @returns {boolean} True if valid format
 */
function validateFilenameFormat(filename) {
    // Accept various formats but warn if not ideal
    const idealFormat = /^[A-Za-z0-9]+_.*_\d{6,8}\.(xlsx?|csv)$/;
    const acceptableFormat = /^.+\.(xlsx?|xlsm?|csv)$/i;
    
    if (!idealFormat.test(filename) && acceptableFormat.test(filename)) {
        console.warn(`File "${filename}" may not follow expected naming convention`);
    }
    
    return acceptableFormat.test(filename);
}

/**
 * Update the file list display in the UI
 * Creates file items with remove buttons for each uploaded file
 * Provides visual feedback of uploaded files to the user
 */
function updateFileList() {
    // Ensure file list element exists
    if (!fileList) {
        console.error('File list element not found');
        return;
    }
    
    // Clear existing list
    fileList.innerHTML = '';
    
    // Create item for each uploaded file
    uploadedFiles.forEach((file, index) => {
        const item = document.createElement('div');
        item.className = 'file-item';
        item.innerHTML = `
            <span>${file.name}</span>
            <button class="remove-btn" onclick="removeFile(${index})">Remove</button>
        `;
        fileList.appendChild(item);
    });
}

/**
 * Remove a file from the upload queue
 * @param {number} index - Index of file to remove in uploadedFiles array
 */
function removeFile(index) {
    // Remove file from array
    uploadedFiles.splice(index, 1);
    
    // Update UI
    updateFileList();
    
    // Disable analyze button if no files remain
    if (analyzeBtn) {
        analyzeBtn.disabled = uploadedFiles.length === 0;
    }
}

/**
 * Display status messages to the user
 * @param {string} message - Message to display
 * @param {string} type - Message type: 'success', 'error', or 'info'
 */
function showStatus(message, type) {
    const status = document.getElementById('status');
    status.textContent = message;
    status.className = `status ${type}`;
    status.style.display = 'block';
}

/**
 * Handle cross-reference file upload
 * @param {File} file - The cross-reference file to process
 */
async function handleXrefFile(file) {
    try {
        const xrefFileInfo = document.getElementById('xrefFileInfo');
        const xrefFileName = document.getElementById('xrefFileName');
        
        // Show loading state
        xrefFileName.textContent = 'Loading...';
        xrefFileInfo.style.display = 'block';
        
        // Read the file
        const reader = new FileReader();
        const fileData = await new Promise((resolve, reject) => {
            reader.onload = (e) => resolve(e.target.result);
            reader.onerror = reject;
            
            if (file.name.toLowerCase().endsWith('.csv')) {
                reader.readAsText(file);
            } else {
                reader.readAsArrayBuffer(file);
            }
        });
        
        // Parse the file
        let data;
        if (file.name.toLowerCase().endsWith('.csv')) {
            // Parse CSV
            const parsed = Papa.parse(fileData, {
                header: true,
                skipEmptyLines: true,
                dynamicTyping: true
            });
            data = parsed.data;
        } else {
            // Parse Excel
            const workbook = XLSX.read(fileData, { type: 'array' });
            const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
            data = XLSX.utils.sheet_to_json(firstSheet);
        }
        
        // Validate the data has required columns
        if (!data || data.length === 0) {
            throw new Error('No data found in cross-reference file');
        }
        
        const firstRow = data[0];
        const hasID = 'ID' in firstRow || 'id' in firstRow || 'Id' in firstRow;
        const hasName = 'Name' in firstRow || 'name' in firstRow || 'NAME' in firstRow;
        const hasRegion = 'Region' in firstRow || 'region' in firstRow || 'REGION' in firstRow;
        
        if (!hasID || !hasName || !hasRegion) {
            throw new Error('Cross-reference file must contain ID, Name, and Region columns');
        }
        
        // Build the cross-reference map
        window.idCrossReference = {};
        data.forEach(row => {
            const id = String(row.ID || row.id || row.Id || '').trim();
            const name = String(row.Name || row.name || row.NAME || '').trim();
            const region = String(row.Region || row.region || row.REGION || '').trim();
            
            if (id) {
                window.idCrossReference[id] = {
                    name: name,
                    region: region
                };
            }
        });
        
        // Update UI
        xrefFileName.textContent = file.name + ` (${Object.keys(window.idCrossReference).length} IDs loaded)`;
        
        // If report is already generated, update tables
        const reportFrame = document.getElementById('reportFrame');
        if (reportFrame && reportFrame.srcdoc) {
            updateAllTablesWithCrossRef();
        }
        
    } catch (error) {
        console.error('Error processing cross-reference file:', error);
        alert('Error loading cross-reference file: ' + error.message);
        
        // Reset UI
        document.getElementById('xrefFileInfo').style.display = 'none';
        document.getElementById('xrefFileName').textContent = '';
        window.idCrossReference = null;
    }
}

/**
 * Progress tracking state variables
 * Used to manage the multi-step analysis progress display
 */
let progressSteps = [];    // Array of progress step objects
let currentStep = 0;       // Current step index
let totalSteps = 0;        // Total number of steps

/**
 * Initialize progress tracking display
 * Resets all progress indicators and shows the progress container
 * Called at the start of file analysis process
 */
function initializeProgress() {
    // Get DOM element references
    const progressContainer = document.getElementById('progressContainer');
    const progressBar = document.getElementById('progressBar');
    const progressText = document.getElementById('progressText');
    const progressStatus = document.getElementById('progressStatus');
    const progressDetails = document.getElementById('progressDetails');
    
    // Show progress container and reset visual elements
    progressContainer.style.display = 'block';
    progressBar.style.width = '0%';
    progressText.textContent = '0%';
    progressStatus.textContent = 'Initializing...';
    progressDetails.innerHTML = '';
    
    // Reset tracking variables
    progressSteps = [];
    currentStep = 0;
    totalSteps = 0;
}

/**
 * Update progress display with current status
 * Shows visual progress bar, percentage, and detailed step information
 * @param {number} percentage - Progress percentage (0-100)
 * @param {string} status - Current status message
 * @param {string} stepName - Optional name of current processing step
 */
function updateProgress(percentage, status, stepName = null) {
    // Get DOM element references
    const progressBar = document.getElementById('progressBar');
    const progressText = document.getElementById('progressText');
    const progressStatus = document.getElementById('progressStatus');
    const progressDetails = document.getElementById('progressDetails');
    
    // Update visual progress indicators
    progressBar.style.width = percentage + '%';
    progressText.textContent = percentage + '%';
    progressStatus.textContent = status;
    
    // Handle step tracking if step name provided
    if (stepName) {
        // Mark all previous steps as completed
        progressSteps.forEach((step, index) => {
            if (index < currentStep) {
                step.element.className = 'progress-step completed';
                step.element.innerHTML = '<span class="step-icon">✓</span>' + step.name;
            }
        });
        
        // Find or create element for current step
        let stepElement = progressSteps.find(s => s.name === stepName)?.element;
        if (!stepElement) {
            stepElement = document.createElement('div');
            progressDetails.appendChild(stepElement);
            progressSteps.push({ name: stepName, element: stepElement });
        }
        
        // Mark current step as active
        stepElement.className = 'progress-step active';
        stepElement.innerHTML = '<span class="step-icon">▶</span>' + stepName;
        
        currentStep++;
    }
}

/**
 * Hide progress tracking display
 * Called when analysis is complete or cancelled
 */
function hideProgress() {
    const progressContainer = document.getElementById('progressContainer');
    progressContainer.style.display = 'none';
}


// Main analyzer class
class DynamicDataAnalyzer {
    constructor() {
        this.dataFolder = "data";
        this.customerName = null;
        this.filePattern = null;
        this.fileType = null;
        this.sheetNames = [];
        this.allData = {};
        this.claudeApiKey = localStorage.getItem('claudeApiKey') || '';
        this.reportData = null;
        this.lazyLoadedSheets = new Map();            // Cache for lazy-loaded sheet data
        this.fileReferences = new Map();              // Store file references for lazy loading
        
        // Sheet patterns to look for
        this.sheetPatterns = ["hub", "tp", "doc", "summary", "date", "trading partner", "document", "hub id"];
        
        // Sheet name mappings
        this.sheetNameMapping = {
            'Date_Summary': 'DATE SUMMARY',
            'Doc_Summary': 'DOCUMENT SUMMARY',
            'Hub_Summary': 'HUB ID SUMMARY',
            'TP_Summary': 'TRADING PARTNER SUMMARY',
            'TP_Doc_Summary': 'TRADING PARTNER/DOCUMENT SUMMARY'
        };
        
        this.csvToExcelMapping = Object.fromEntries(
            Object.entries(this.sheetNameMapping).map(([k, v]) => [v, k])
        );
    }
    
    formatPeriodDisplay(periodStr) {
        if (typeof periodStr !== 'string') {
            periodStr = String(periodStr);
        }
        
        if ((this.fileType === "csv" || periodStr.match(/^\d{4}-\d{2}$/)) && periodStr.match(/^\d{4}-\d{2}$/)) {
            const [year, month] = periodStr.split('-');
            const date = new Date(year, month - 1);
            return date.toLocaleDateString('en-US', { year: 'numeric', month: 'long' });
        }
        return periodStr;
    }
    
    async detectCustomerAndPattern(files) {
        if (files.length === 0) return false;
        
        // Separate Excel and CSV files
        const excelFiles = files.filter(f => f.name.match(/\.(xlsx?|xlsm)$/i));
        const csvFiles = files.filter(f => f.name.match(/\.csv$/i));
        
        // Determine file type
        if (excelFiles.length > 0) {
            this.fileType = "excel";
        } else {
            this.fileType = "csv";
        }
        
        // Extract customer name from first file
        const firstFile = files[0];
        const match = firstFile.name.match(/^(.+?)_.*?_(\d{6,8})\.(xlsx?|csv)$/i);
        
        if (match) {
            this.customerName = match[1].toUpperCase();
        } else {
            // Fallback
            const parts = firstFile.name.split(/[_.-]/);
            this.customerName = parts[0].toUpperCase();
        }
        
        
        return true;
    }
    
    async detectSheetNames(files) {
        if (files.length === 0) return false;
        
        const firstFile = files[0];
        const detectedSheets = [];
        
        try {
            if (this.fileType === "excel") {
                const data = await this.readFileAsArrayBuffer(firstFile);
                const workbook = XLSX.read(data, { type: 'array' });
                
                for (const sheetName of workbook.SheetNames) {
                    const sheetLower = sheetName.toLowerCase();
                    for (const pattern of this.sheetPatterns) {
                        if (sheetLower.includes(pattern)) {
                            detectedSheets.push(sheetName);
                            break;
                        }
                    }
                }
            }
            
            this.sheetNames = detectedSheets;
            
            return true;
        } catch (error) {
            console.error('Error detecting sheets:', error);
            return false;
        }
    }
    
    extractPeriod(filename) {
        // Try to extract date from filename
        const patterns = [
            /(\d{6})\./, // YYYYMM
            /(\d{4}-\d{2})\./, // YYYY-MM
            /_(\d{4})(\d{2})\./, // _YYYYMM
        ];
        
        for (const pattern of patterns) {
            const match = filename.match(pattern);
            if (match) {
                if (match[2]) {
                    return `${match[1]}-${match[2]}`;
                }
                const dateStr = match[1];
                if (dateStr.length === 6) {
                    return `${dateStr.substring(0, 4)}-${dateStr.substring(4, 6)}`;
                }
                return dateStr;
            }
        }
        
        // Fallback
        return filename.split('.')[0].split('_').pop();
    }
    
    async processAllFiles(files) {
        // Sort files by name
        const sortedFiles = files.sort((a, b) => a.name.localeCompare(b.name));
        
        const totalFiles = sortedFiles.length;
        const baseProgress = 35;
        const progressRange = 35; // From 35% to 70%
        
        for (let fileIndex = 0; fileIndex < sortedFiles.length; fileIndex++) {
            const file = sortedFiles[fileIndex];
            const period = this.extractPeriod(file.name);
            
            // Update progress for each file
            const fileProgress = baseProgress + Math.floor((fileIndex / totalFiles) * progressRange);
            updateProgress(fileProgress, `Processing file ${fileIndex + 1} of ${totalFiles}: ${file.name}`, `Processing ${file.name}`);
            
            this.allData[period] = {};
            
            for (const sheetName of this.sheetNames) {
                const sheetData = await this.extractSheetData(file, sheetName);
                
                if (sheetData) {
                    this.allData[period][sheetName] = sheetData;
                }
            }
        }
        
        return this.allData;
    }
    
    async extractSheetData(file, sheetName) {
        try {
            const data = await this.readFileAsArrayBuffer(file);
            const workbook = XLSX.read(data, { type: 'array' });
            
            if (!workbook.Sheets[sheetName]) {
                return null;
            }
            
            const sheet = workbook.Sheets[sheetName];
            const jsonData = XLSX.utils.sheet_to_json(sheet, { header: 1 });
            
            if (jsonData.length === 0) {
                return null;
            }
            
            // Process data
            const headers = jsonData[0];
            const dataRows = [];
            
            for (let i = 1; i < jsonData.length; i++) {
                const row = jsonData[i];
                const rowData = {};
                
                for (let j = 0; j < headers.length; j++) {
                    rowData[headers[j]] = row[j] || '';
                }
                
                // Skip total rows
                const firstColValue = String(rowData[headers[0]] || '').toUpperCase();
                if (!firstColValue.includes('TOTAL') && !firstColValue.includes('TP-TOTAL')) {
                    dataRows.push(rowData);
                }
            }
            
            // Extract metrics
            const metrics = this.extractComprehensiveMetrics(dataRows, headers, sheetName);
            
            return {
                headers: headers,
                data: dataRows,
                total_rows: dataRows.length,
                totals: metrics.totals,
                statistics: metrics.statistics,
                categories: metrics.categories
            };
        } catch (error) {
            console.error(`Error extracting ${sheetName}:`, error);
            return null;
        }
    }
    
    extractComprehensiveMetrics(data, headers, sheetName = null) {
        const metrics = {
            totals: {},
            statistics: {},
            categories: {}
        };
        
        // Check if this is a Date_Summary sheet
        const isDateSummary = sheetName && sheetName.toLowerCase().includes('date') && 
                             sheetName.toLowerCase().includes('summary');
        
        // Find numeric columns
        const numericColumns = [];
        for (const header of headers) {
            const values = data.map(row => row[header])
                .filter(v => typeof v === 'number' || (!isNaN(parseFloat(v)) && v !== ''));
            
            // Changed: Accept columns with at least 1 numeric value (was > 5)
            if (values.length > 0) {
                numericColumns.push(header);
            }
        }
        
        // Calculate totals and statistics
        for (const col of numericColumns) {
            const values = data.map(row => {
                const val = row[col];
                // Handle empty strings and convert to 0
                if (val === '' || val === null || val === undefined) {
                    return 0;
                }
                return typeof val === 'number' ? val : parseFloat(val) || 0;
            }).filter(v => !isNaN(v));
            
            if (values.length > 0) {
                // Handle Date_Summary special case
                if (isDateSummary) {
                    const hasDateColumn = headers.some(h => h.toUpperCase().includes('DATE'));
                    // Changed: Check for daily data pattern (was > 20, now > 15 to handle smaller datasets)
                    if (hasDateColumn && data.length > 15) {
                        metrics.totals[col] = values.reduce((a, b) => a + b, 0) / 2;
                    } else {
                        metrics.totals[col] = values.reduce((a, b) => a + b, 0);
                    }
                } else {
                    metrics.totals[col] = values.reduce((a, b) => a + b, 0);
                }
                
                // Calculate statistics
                const sortedValues = [...values].sort((a, b) => a - b);
                const n = values.length;
                const mean = values.reduce((a, b) => a + b, 0) / n;
                
                // Median
                let median;
                if (n % 2 === 0) {
                    median = (sortedValues[n/2 - 1] + sortedValues[n/2]) / 2;
                } else {
                    median = sortedValues[Math.floor(n/2)];
                }
                
                // Standard deviation
                const variance = values.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0) / n;
                const std = Math.sqrt(variance);
                
                metrics.statistics[col] = {
                    mean: mean,
                    median: median,
                    std: std,
                    min: Math.min(...values),
                    max: Math.max(...values),
                    percentile_25: this.percentile(sortedValues, 25),
                    percentile_75: this.percentile(sortedValues, 75)
                };
            }
        }
        
        // Special handling for DOC and KCS columns
        const docColumns = headers.filter(col => col.toUpperCase().includes('DOC'));
        const kcsColumns = headers.filter(col => col.toUpperCase().includes('KCS'));
        
        // Calculate DOC totals
        let totalDoc = 0;
        for (const col of docColumns) {
            if (metrics.totals[col]) {
                totalDoc += metrics.totals[col];
            }
        }
        if (docColumns.length > 0) {
            metrics.totals['TOTAL-DOC'] = totalDoc;
        }
        
        // Calculate KCS totals
        let totalKcs = 0;
        for (const col of kcsColumns) {
            if (metrics.totals[col]) {
                totalKcs += metrics.totals[col];
            }
        }
        if (kcsColumns.length > 0) {
            metrics.totals['TOTAL-KCS'] = totalKcs;
        }
        
        return metrics;
    }
    
    percentile(data, p) {
        const n = data.length;
        const k = (n - 1) * p / 100;
        const f = Math.floor(k);
        const c = k - f;
        if (f + 1 < n) {
            return data[f] + c * (data[f + 1] - data[f]);
        } else {
            return data[f];
        }
    }
    
    saveAnalysisData() {
        const output = {
            customer: this.customerName,
            extraction_date: new Date().toISOString(),
            files_processed: Object.keys(this.allData).length,
            sheets_analyzed: this.sheetNames,
            summary: {},
            trends: {},
            sample_data: {},
            tp_data: {}
        };
        
        // Create trends for each sheet
        for (const sheetName of this.sheetNames) {
            output.trends[sheetName] = {
                periods: [],
                row_counts: [],
                metric_trends: {},
                statistics_summary: {}
            };
        }
        
        // Process each period
        const sortedPeriods = Object.keys(this.allData).sort();
        
        for (const period of sortedPeriods) {
            output.summary[period] = {};
            
            for (const [sheetName, sheetData] of Object.entries(this.allData[period])) {
                // Summary
                output.summary[period][sheetName] = {
                    headers: sheetData.headers,
                    total_rows: sheetData.total_rows,
                    columns_count: sheetData.headers.length
                };
                
                // Store TP data for analysis
                if ((sheetName.toLowerCase().includes('tp') || sheetName.toLowerCase().includes('doc') || sheetName.toLowerCase().includes('hub')) && sheetData.data) {
                    if (!output.tp_data[period]) {
                        output.tp_data[period] = {};
                    }
                    output.tp_data[period][sheetName] = sheetData.data;
                }
                
                // Trends
                output.trends[sheetName].periods.push(period);
                output.trends[sheetName].row_counts.push(sheetData.total_rows);
                
                // Add metric trends
                if (sheetData.totals) {
                    for (const [metric, value] of Object.entries(sheetData.totals)) {
                        if (!output.trends[sheetName].metric_trends[metric]) {
                            output.trends[sheetName].metric_trends[metric] = [];
                        }
                        output.trends[sheetName].metric_trends[metric].push(value);
                    }
                }
                
                // Add statistics
                if (sheetData.statistics) {
                    output.trends[sheetName].statistics_summary[period] = sheetData.statistics;
                }
            }
        }
        
        // Add data quality metrics
        output.data_quality = this.assessDataQuality();
        
        // Add docData if available
        if (this.docData) {
            output.docData = this.docData;
        }
        
        this.reportData = output;
        return output;
    }
    
    assessDataQuality() {
        const qualityMetrics = {
            completeness: 0,
            consistency: 0,
            files_with_errors: 0,
            missing_sheets: 0,
            data_gaps: []
        };
        
        const totalExpected = Object.keys(this.allData).length * this.sheetNames.length;
        let totalFound = 0;
        
        for (const [period, sheets] of Object.entries(this.allData)) {
            for (const sheetName of this.sheetNames) {
                if (sheets[sheetName]) {
                    totalFound++;
                } else {
                    qualityMetrics.missing_sheets++;
                }
            }
        }
        
        qualityMetrics.completeness = totalExpected > 0 ? 
            `${(totalFound / totalExpected * 100).toFixed(1)}%` : "0%";
        
        return qualityMetrics;
    }
    
    async generateClaudeAnalysis(data) {
        if (!this.claudeApiKey) {
            return this.generateDefaultInsights(data);
        }
        
        const prompt = this.buildClaudePrompt(data);
        
        try {
            const response = await fetch('https://api.anthropic.com/v1/messages', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'x-api-key': this.claudeApiKey,
                    'anthropic-version': '2023-06-01'
                },
                body: JSON.stringify({
                    model: 'claude-3-sonnet-20240229',
                    max_tokens: 4000,
                    messages: [{
                        role: 'user',
                        content: prompt
                    }]
                })
            });
            
            if (!response.ok) {
                throw new Error(`API request failed: ${response.status}`);
            }
            
            const result = await response.json();
            return result.content[0].text;
        } catch (error) {
            console.error('Error calling Claude API:', error);
            return this.generateDefaultInsights(data);
        }
    }
    
    buildClaudePrompt(data) {
        // Similar to Python implementation
        return `Analyze this operational data for ${this.customerName}...`;
    }
    
    generateDefaultInsights(data) {
        return `## OPERATIONAL PERFORMANCE

Based on the data processed, we have successfully analyzed **${data.files_processed}** files across **${data.sheets_analyzed.length}** data categories.

### Key Operational Metrics
- **Total Data Points**: ${this.calculateTotalDataPoints(data).toLocaleString()}
- **Time Period**: ${Object.keys(data.summary).sort()[0]} to ${Object.keys(data.summary).sort().pop()}
- **Data Completeness**: ${data.data_quality?.completeness || '100%'}

## PATTERN IDENTIFICATION

The data shows operational activity patterns across multiple dimensions...`;
    }
    
    calculateTotalDataPoints(data) {
        let total = 0;
        Object.values(data.trends).forEach(trend => {
            if (trend.row_counts) {
                total += trend.row_counts.reduce((a, b) => a + b, 0);
            }
        });
        return total;
    }
    
    readFileAsArrayBuffer(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = e => resolve(e.target.result);
            reader.onerror = reject;
            reader.readAsArrayBuffer(file);
        });
    }
    
    /**
     * Clear memory by removing cached data
     * Keeps only essential data for current view
     */
    clearMemory() {
        // Clear lazy loaded cache
        this.lazyLoadedSheets.clear();
        
        // Clear file references
        this.fileReferences.clear();
        
        // Clear non-essential data from allData
        Object.keys(this.allData).forEach(period => {
            Object.keys(this.allData[period]).forEach(sheet => {
                // Keep only totals and statistics, clear raw data
                if (this.allData[period][sheet] && this.allData[period][sheet].data) {
                    delete this.allData[period][sheet].data;
                }
            });
        });
        
        // Force garbage collection if available
        if (window.gc) {
            window.gc();
        }
    }
    
    /**
     * Get estimated memory usage
     * @returns {number} Estimated memory in bytes
     */
    getMemoryUsage() {
        let size = 0;
        
        // Estimate size of cached sheets
        this.lazyLoadedSheets.forEach(sheet => {
            size += JSON.stringify(sheet).length * 2; // Unicode chars = 2 bytes
        });
        
        // Estimate size of main data
        size += JSON.stringify(this.allData).length * 2;
        
        return size;
    }
    
    /**
     * Check if memory limit is exceeded and clear if necessary
     */
    checkMemoryLimit() {
        const usage = this.getMemoryUsage();
        const limitMB = this.memoryLimit / 1024 / 1024;
        const usageMB = usage / 1024 / 1024;
        
        if (usage > this.memoryLimit) {
            console.warn(`Memory usage (${usageMB.toFixed(2)}MB) exceeds limit (${limitMB}MB). Clearing cache.`);
            this.clearMemory();
        }
    }
    
    generateHtmlReport(data, insights) {
        // Store data reference
        this.reportData = data;
        
        // Extract document data first if not already done
        if (!this.docData) {
            this.docData = this.extractDocumentData(data);
        }
        
        // Ensure docData is available in the data object
        if (this.docData && !data.docData) {
            data.docData = this.docData;
        }
        
        // Generate individual sections
        const monthlyAnalysis = this.generateMonthlyAnalysis(data);
        const momAnalysis = this.generateMomAnalysis(data);
        const tpAnalysis = this.generateTpAnalysis(data);
        const docAnalysis = this.generateDocumentAnalysis(data);
        const hubAnalysis = this.generateHubAnalysis(data);
        const formattedInsights = this.formatAIInsights(insights);
        
        const insightsContent = `<div class="insights-section">
            <div class="ai-badge">📊 Data Analysis Insights (Not Functional)</div>
            <div class="insights-content">${formattedInsights}</div>
        </div>`;
        
        // Get sorted periods for date range
        const sortedPeriods = Object.keys(data.summary).sort();
        const firstPeriod = sortedPeriods[0];
        const lastPeriod = sortedPeriods[sortedPeriods.length - 1];
        
        const html = `<!DOCTYPE html>
<html>
<head>
    <title>${this.customerName} Customer Traffic Analysis</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap');
        
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            line-height: 1.6;
            color: #1a1a1a;
            margin: 0;
            padding: 0;
            background-color: #f8f9fa;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 40px 20px;
        }
        
        .header {
            background: linear-gradient(135deg, rgba(26, 54, 93, 0.85) 0%, rgba(44, 82, 130, 0.85) 100%);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.18);
            color: white;
            padding: 30px 30px;
            border-radius: 15px;
            margin-bottom: 30px;
            text-align: center;
            position: relative;
            overflow: visible;
            box-shadow: 0 8px 32px rgba(31, 38, 135, 0.15);
        }
        
        .header::before {
            content: '';
            position: absolute;
            top: -50%;
            right: -5%;
            width: 300px;
            height: 300px;
            background: radial-gradient(circle, rgba(255,255,255,0.08) 0%, transparent 70%);
            border-radius: 50%;
        }
        
        .header h1 {
            margin: 0;
            font-size: 2.2em;
            font-weight: 400;
            letter-spacing: 1px;
            text-transform: uppercase;
            position: relative;
            z-index: 1;
        }
        
        .subtitle {
            font-size: 1em;
            opacity: 0.85;
            margin-top: 5px;
            font-weight: 300;
        }
        
        .date-range {
            margin-top: 12px;
            opacity: 0.75;
            font-size: 0.9em;
        }
        
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 25px;
            margin-bottom: 40px;
        }
        
        .metric-card {
            background: white;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
            transition: all 0.3s ease;
            border-top: 4px solid #3182ce;
            position: relative;
        }
        
        .metric-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 30px rgba(0,0,0,0.12);
        }
        
        .metric-card.positive {
            border-top-color: #38a169;
        }
        
        .metric-card.negative {
            border-top-color: #e53e3e;
        }
        
        .metric-detail {
            font-size: 0.85em;
            color: #718096;
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #e2e8f0;
        }
        
        .metric-label {
            font-size: 0.9em;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 10px;
        }
        
        .metric-value {
            font-size: 2.5em;
            font-weight: 600;
            color: #1a365d;
            margin: 10px 0;
        }
        
        .metric-trend {
            font-size: 1.1em;
            font-weight: 500;
        }
        
        .trend-positive {
            color: #38a169;
        }
        
        .trend-negative {
            color: #e53e3e;
        }
        
        .insights-section {
            background: linear-gradient(135deg, #ffffff 0%, #f7fafc 100%);
            padding: 60px;
            border-radius: 20px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
            margin-bottom: 40px;
            position: relative;
            overflow: visible;
        }
        
        .insights-section::before {
            content: '';
            position: absolute;
            top: -50%;
            right: -10%;
            width: 400px;
            height: 400px;
            background: radial-gradient(circle, rgba(56, 161, 105, 0.05) 0%, transparent 70%);
            border-radius: 50%;
        }
        
        .ai-badge {
            display: inline-flex;
            align-items: center;
            background: linear-gradient(135deg, #1a365d 0%, #2c5282 100%);
            color: white;
            padding: 12px 30px;
            border-radius: 30px;
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 40px;
            box-shadow: 0 4px 15px rgba(26, 54, 93, 0.3);
        }
        
        .insights-content {
            font-size: 16px;
            line-height: 1.8;
            color: #2d3748;
            position: relative;
            z-index: 1;
        }
        
        .insights-content p {
            margin-bottom: 16px;
            color: #2d3748;
        }
        
        .insights-content br {
            display: block;
            margin-bottom: 8px;
        }
        
        .insights-content h1 {
            color: #1a365d;
            margin-top: 40px;
            margin-bottom: 24px;
            font-size: 2em;
            font-weight: 700;
            border-bottom: 3px solid #e2e8f0;
            padding-bottom: 12px;
        }
        
        .insights-content h2 {
            color: #2c5282;
            margin-top: 32px;
            margin-bottom: 20px;
            font-size: 1.5em;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .insights-content h3 {
            color: #3182ce;
            margin-top: 24px;
            margin-bottom: 16px;
            font-size: 1.2em;
            font-weight: 600;
        }
        
        .insight-section {
            background: white;
            border-radius: 12px;
            padding: 24px;
            margin: 20px 0;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
            border-left: 4px solid #3182ce;
        }
        
        .insight-highlight {
            background: #f0f9ff;
            border: 1px solid #90cdf4;
            border-radius: 8px;
            padding: 16px;
            margin: 16px 0;
        }
        
        .insight-warning {
            background: #fef3c7;
            border: 1px solid #fbbf24;
            border-radius: 8px;
            padding: 16px;
            margin: 16px 0;
            border-left: 4px solid #f59e0b;
        }
        
        .insight-success {
            background: #d1fae5;
            border: 1px solid #6ee7b7;
            border-radius: 8px;
            padding: 16px;
            margin: 16px 0;
            border-left: 4px solid #10b981;
        }
        
        .insight-metric {
            display: inline-flex;
            align-items: center;
            background: #edf2f7;
            padding: 6px 12px;
            border-radius: 6px;
            font-weight: 600;
            color: #2d3748;
            margin: 0 4px;
        }
        
        .insight-list {
            margin: 16px 0;
            padding-left: 24px;
            list-style-type: disc;
        }
        
        .insight-list li {
            margin-bottom: 12px;
            color: #4a5568;
            line-height: 1.6;
        }
        
        .insight-list li strong {
            color: #2d3748;
            font-weight: 600;
        }
        
        .insights-content strong {
            color: #1a365d;
            font-weight: 600;
        }
        
        .insights-content em {
            font-style: italic;
            color: #2d3748;
        }
        
        .mini-chart {
            margin-top: 15px;
            height: 60px;
            display: flex;
            align-items: flex-end;
            gap: 2px;
        }
        
        .charts-section {
            background: white;
            padding: 40px;
            border-radius: 20px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
            margin-bottom: 40px;
        }
        
        .chart-container {
            margin-bottom: 40px;
        }
        
        .chart-title {
            font-size: 1.3em;
            font-weight: 600;
            color: #1a365d;
            margin-bottom: 20px;
            text-align: center;
        }
        
        .bar {
            flex: 1;
            background: rgba(49, 130, 206, 0.6);
            border-radius: 2px 2px 0 0;
            transition: all 0.3s ease;
        }
        
        .bar:hover {
            background: rgba(49, 130, 206, 1);
        }
        
        .footer {
            text-align: center;
            padding: 40px;
            color: #666;
            font-size: 0.9em;
        }
        
        /* NOTE: Menu and Modal styles are already defined above in the main CSS section - removed duplicates */
        
        .info-box {
            background: #e6f3ff;
            border-left: 4px solid #3182ce;
            padding: 20px;
            margin: 20px 0;
            border-radius: 5px;
        }
        
        .quality-badge {
            display: inline-block;
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 0.85em;
            font-weight: 600;
            margin-left: 10px;
        }
        
        .quality-good {
            background: #c6f6d5;
            color: #22543d;
        }
        
        .quality-warning {
            background: #fefcbf;
            color: #744210;
        }
        
        .quality-poor {
            background: #fed7d7;
            color: #742a2a;
        }
        
        .stat-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        
        .stat-item {
            text-align: center;
            padding: 10px;
            background: #f7fafc;
            border-radius: 8px;
        }
        
        .stat-value {
            font-size: 1.2em;
            font-weight: 600;
            color: #2d3748;
        }
        
        .stat-label {
            font-size: 0.8em;
            color: #718096;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        /* Tab styles */
        .tabs {
            display: flex;
            background: white;
            border-radius: 15px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
            margin-bottom: 30px;
            overflow: visible;
        }
        
        .tab {
            flex: 1;
            padding: 20px 30px;
            text-align: center;
            cursor: pointer;
            background: white;
            color: #4a5568;
            font-weight: 600;
            transition: all 0.3s ease;
            border: none;
            outline: none;
            position: relative;
        }
        
        .tab:hover {
            background: #f7fafc;
        }
        
        .tab.active {
            background: #1a365d;
            color: white;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
            animation: fadeIn 0.3s ease;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        /* Monthly comparison table styles */
        .monthly-table {
            width: 100%;
            background: white;
            border-radius: 10px;
            overflow: visible;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        }
        
        .monthly-table th {
            background: #f7fafc;
            padding: 15px;
            text-align: left;
            font-weight: 600;
            color: #2d3748;
            border-bottom: 2px solid #e2e8f0;
        }
        
        .monthly-table td {
            padding: 15px;
            border-bottom: 1px solid #e2e8f0;
        }
        
        .monthly-table tr:last-child td {
            border-bottom: none;
        }
        
        .monthly-table tr:hover {
            background: #f7fafc;
        }
        
        .change-positive {
            color: #38a169;
            font-weight: 600;
        }
        
        .change-negative {
            color: #e53e3e;
            font-weight: 600;
        }
        
        /* Information icon styles */
        .info-icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 22px;
            height: 22px;
            background: #3182ce;
            color: white;
            border-radius: 50%;
            cursor: pointer;
            font-size: 13px;
            font-weight: bold;
            margin-left: 10px;
            position: relative;
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            font-family: Arial, sans-serif;
            user-select: none;
        }
        
        .info-icon:hover {
            background: #2563eb;
            transform: scale(1.1);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }
        
        .info-icon:active {
            transform: scale(0.95);
        }
        
        /* Popup modal styles */
        .info-popup-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 999998;
            backdrop-filter: blur(2px);
        }
        
        .info-popup {
            background: white;
            border-radius: 12px;
            padding: 0;
            width: 600px;
            max-width: 90vw;
            max-height: 80vh;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
            overflow: visible;
            position: relative;
            z-index: 999999;
        }
        
        .info-popup-header {
            background: #f7fafc;
            padding: 16px 20px;
            border-bottom: 1px solid #e2e8f0;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .info-popup-title {
            font-size: 18px;
            font-weight: 600;
            color: #1a202c;
            margin: 0;
        }
        
        .info-popup-close {
            width: 32px;
            height: 32px;
            border: none;
            background: transparent;
            color: #718096;
            font-size: 24px;
            cursor: pointer;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }
        
        .info-popup-close:hover {
            background: #e2e8f0;
            color: #2d3748;
        }
        
        .info-popup-content {
            padding: 20px;
            color: #4a5568;
            font-size: 15px;
            line-height: 1.6;
            overflow-y: auto;
            max-height: calc(80vh - 80px);
        }
        
        .info-popup-content p {
            margin: 0 0 12px 0;
        }
        
        .info-popup-content p:last-child {
            margin-bottom: 0;
        }
        
        /* Hide the old tooltip content */
        .tooltip {
            display: none !important;
        }
        
        /* Section header with info icon */
        .section-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 20px;
        }
        
        .section-title {
            display: flex;
            align-items: center;
            margin: 0;
            color: #2d3748;
        }
        
        .sparkline {
            display: inline-block;
            width: 100px;
            height: 30px;
            vertical-align: middle;
        }
        
        .month-badge {
            display: inline-block;
            padding: 4px 12px;
            background: #edf2f7;
            border-radius: 15px;
            font-size: 0.85em;
            font-weight: 600;
            color: #4a5568;
        }
        
        .month-badge.current {
            background: #3182ce;
            color: white;
        }
        
        /* TP Analysis styles */
        .tp-analysis-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }
        
        .tp-table {
            width: 100%;
            background: white;
            border-radius: 10px;
            overflow: visible;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
            margin-bottom: 20px;
        }
        
        .tp-table th {
            background: #f7fafc;
            padding: 12px;
            text-align: left;
            font-weight: 600;
            color: #2d3748;
            border-bottom: 2px solid #e2e8f0;
            font-size: 0.9em;
        }
        
        .tp-table td {
            padding: 12px;
            border-bottom: 1px solid #e2e8f0;
            font-size: 0.9em;
        }
        
        .tp-table tr:last-child td {
            border-bottom: none;
        }
        
        .tp-table tr:hover {
            background: #f7fafc;
        }
        
        .tp-rank {
            display: inline-block;
            width: 25px;
            height: 25px;
            background: #edf2f7;
            border-radius: 50%;
            text-align: center;
            line-height: 25px;
            font-weight: 600;
            font-size: 0.85em;
            color: #4a5568;
        }
        
        .tp-rank.top3 {
            background: #fbbf24;
            color: #78350f;
        }
        
        .tp-growth {
            font-weight: 600;
        }
        
        .tp-growth.positive {
            color: #10b981;
        }
        
        .tp-growth.negative {
            color: #ef4444;
        }
        
        .tp-chart-container {
            background: white;
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
            margin-bottom: 20px;
        }
        
        .tp-chart-title {
            font-size: 1.1em;
            font-weight: 600;
            color: #1a365d;
            margin-bottom: 20px;
        }
        
        .doc-type-badge {
            display: inline-block;
            padding: 3px 8px;
            background: #e0e7ff;
            color: #3730a3;
            border-radius: 12px;
            font-size: 0.75em;
            margin-right: 4px;
            margin-bottom: 4px;
        }
        
        /* Document Type Distribution styles */
        .doc-type-bar {
            display: grid;
            grid-template-columns: 200px 1fr 80px;
            gap: 15px;
            align-items: center;
            margin-bottom: 12px;
            padding: 8px 0;
        }
        
        .doc-type-label {
            font-weight: 600;
            color: #2d3748;
            font-size: 0.9em;
            text-align: right;
            overflow: visible;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .doc-type-bar-container {
            background: #f7fafc;
            border-radius: 20px;
            height: 25px;
            position: relative;
            overflow: visible;
        }
        
        .doc-type-bar-fill {
            background: linear-gradient(90deg, #4299e1 0%, #3182ce 100%);
            height: 100%;
            border-radius: 20px;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            padding-right: 10px;
            color: white;
            font-size: 0.8em;
            font-weight: 600;
            transition: width 0.5s ease-out;
            min-width: 40px;
        }
        
        .doc-type-count {
            font-weight: 600;
            color: #4a5568;
            font-size: 0.9em;
            text-align: right;
        }
        
        /* New Document Type Distribution styles */
        .doc-distribution-wrapper {
            background: #ffffff;
            border-radius: 12px;
            padding: 25px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
            margin-bottom: 20px;
        }
        
        .doc-type-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        
        .doc-type-card {
            background: linear-gradient(135deg, #f7fafc 0%, #ffffff 100%);
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            position: relative;
            overflow: visible;
            transition: all 0.3s ease;
            border: 1px solid #e2e8f0;
            min-height: 140px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        
        .doc-type-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(49, 130, 206, 0.15);
            border-color: #cbd5e0;
        }
        
        .doc-type-icon {
            width: 40px;
            height: 40px;
            margin: 0 auto 10px;
            background: linear-gradient(135deg, #4299e1 0%, #3182ce 100%);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 1.2em;
            font-weight: bold;
        }
        
        .doc-type-name {
            font-weight: 700;
            color: #2d3748;
            font-size: 1em;
            margin-bottom: 8px;
            line-height: 1.2;
        }
        
        .doc-type-card .doc-type-count {
            font-size: 1.8em;
            font-weight: 700;
            color: #3182ce;
            margin-bottom: 5px;
            text-align: center;
        }
        
        .doc-type-percentage {
            font-size: 0.85em;
            color: #718096;
            font-weight: 500;
        }
        
        .doc-type-progress-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: #e2e8f0;
        }
        
        .doc-type-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4299e1 0%, #3182ce 100%);
            transition: width 0.5s ease-out;
        }
        
        .matrix-table {
            border-collapse: collapse;
            font-size: 0.9em;
            background: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            border-radius: 8px;
            overflow: visible;
        }
        
        .matrix-table th,
        .matrix-table td {
            padding: 10px;
            border: 1px solid #e2e8f0;
        }
        
        .matrix-table th {
            font-weight: 600;
            text-align: left;
            color: #2d3748;
        }
        
        .matrix-table td {
            transition: all 0.2s ease;
        }
        
        .matrix-table tbody tr:hover td {
            background-color: #f7fafc !important;
        }
        
        .doc-analysis-container {
            background: white;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
            margin-bottom: 30px;
        }
        
        .doc-analysis-container h4 {
            margin-top: 30px;
            margin-bottom: 20px;
            color: #2d3748;
            font-size: 1.2em;
        }
        
        .doc-analysis-container:first-child h4 {
            margin-top: 0;
        }
        
        /* Tooltip styles */
        .tooltip {
            position: relative;
            display: inline-block;
            cursor: help;
        }
        
        .tooltip .tooltiptext {
            visibility: hidden;
            width: 280px;
            background-color: #2d3748;
            color: #fff;
            text-align: left;
            border-radius: 8px;
            padding: 12px;
            position: fixed;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 0.85em;
            line-height: 1.4;
            box-shadow: 0 4px 20px rgba(0,0,0,0.2);
            pointer-events: none;
        }
        
        .tooltip .tooltiptext::after {
            content: "";
            position: absolute;
            border-width: 5px;
            border-style: solid;
        }
        
        /* Arrow positions for different tooltip placements */
        .tooltip .tooltiptext.tooltip-top::after {
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border-color: #2d3748 transparent transparent transparent;
        }
        
        .tooltip .tooltiptext.tooltip-bottom::after {
            bottom: 100%;
            left: 50%;
            margin-left: -5px;
            border-color: transparent transparent #2d3748 transparent;
        }
        
        .tooltip .tooltiptext.tooltip-left::after {
            top: 50%;
            left: 100%;
            margin-top: -5px;
            border-color: transparent transparent transparent #2d3748;
        }
        
        .tooltip .tooltiptext.tooltip-right::after {
            top: 50%;
            right: 100%;
            margin-top: -5px;
            border-color: transparent #2d3748 transparent transparent;
        }
        
        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }
        
        .tp-growth.tooltip {
            text-decoration: underline dotted;
            text-underline-offset: 2px;
        }
        
        /* Sortable table headers */
        th.sortable {
            cursor: pointer;
            user-select: none;
            transition: background 0.2s;
            position: relative;
        }
        
        th.sortable:hover {
            background: #e5e7eb !important;
        }
        
        th.sortable.sorted {
            background: #f3f4f6;
        }
        
        .sort-indicator {
            font-size: 0.8em;
            margin-left: 5px;
            color: #6b7280;
        }
        
        th.sorted .sort-indicator {
            color: #3b82f6;
            font-weight: bold;
        }
    </style>
    <script>
        function showTab(tabName) {
            // Hide all tab contents
            const contents = document.querySelectorAll('.tab-content');
            contents.forEach(content => {
                content.classList.remove('active');
            });
            
            // Remove active class from all tabs
            const tabs = document.querySelectorAll('.tab');
            tabs.forEach(tab => {
                tab.classList.remove('active');
            });
            
            // Show selected tab content
            document.getElementById(tabName).classList.add('active');
            
            // Add active class to selected tab
            document.querySelector('[onclick="showTab(\\'' + tabName + '\\')"]').classList.add('active');
            
            // Re-initialize tooltips and sorting for the new tab
            setTimeout(() => {
                setupTooltips();
                // Make tables sortable in the newly displayed tab
                if (typeof makeAllTablesSortable === 'function') {
                    makeAllTablesSortable();
                }
            }, 100);
        }
        
        // Initialize first tab on load
        window.onload = function() {
            showTab('monthly');
            
            // Initialize tooltips and sorting after DOM is ready
            setTimeout(() => {
                setupTooltips();
                initializeCharts();
                // Make tables sortable after everything is loaded
                if (typeof makeAllTablesSortable === 'function') {
                    makeAllTablesSortable();
                }
            }, 500);
        };
        
        // Setup info popups
        function setupTooltips() {
            // Create popup overlay if it doesn't exist
            let overlay = document.getElementById('info-popup-overlay');
            if (!overlay) {
                overlay = document.createElement('div');
                overlay.id = 'info-popup-overlay';
                overlay.className = 'info-popup-overlay';
                document.body.appendChild(overlay);
                
                // Click overlay to close
                overlay.addEventListener('click', function(e) {
                    if (e.target === overlay) {
                        closeInfoPopup();
                    }
                });
            }
            
            // Setup click handlers for all info icons
            const infoIcons = document.querySelectorAll('.info-icon');
            
            infoIcons.forEach(icon => {
                // Remove existing listeners to prevent duplicates
                const newIcon = icon.cloneNode(true);
                icon.parentNode.replaceChild(newIcon, icon);
                
                newIcon.addEventListener('click', function(e) {
                    e.stopPropagation();
                    
                    // Get the tooltip content
                    const tooltip = newIcon.querySelector('.tooltip');
                    if (!tooltip) return;
                    
                    // Get the parent header text for the title
                    const parentHeader = newIcon.closest('h3, h4, .tp-chart-title');
                    let title = 'Information';
                    if (parentHeader) {
                        // Get only the text content before the info icon
                        const headerClone = parentHeader.cloneNode(true);
                        const infoIcon = headerClone.querySelector('.info-icon');
                        if (infoIcon) {
                            infoIcon.remove();
                        }
                        title = headerClone.textContent.trim();
                    }
                    
                    // Show the popup with the content
                    showInfoPopup(title, tooltip.textContent.trim());
                });
            });
        }
        
        function showInfoPopup(title, content) {
            const overlay = document.getElementById('info-popup-overlay');
            if (!overlay) return;
            
            // Create popup HTML
            const popupHTML = '<div class="info-popup">' +
                '<div class="info-popup-header">' +
                '<h3 class="info-popup-title">' + title + '</h3>' +
                '<button class="info-popup-close" onclick="window.closeInfoPopup()">×</button>' +
                '</div>' +
                '<div class="info-popup-content">' +
                '<p>' + content + '</p>' +
                '</div>' +
                '</div>';
            
            overlay.innerHTML = popupHTML;
            overlay.style.display = 'flex';
            
            // Add escape key handler
            document.addEventListener('keydown', handleEscKey);
        }
        
        function closeInfoPopup() {
            const overlay = document.getElementById('info-popup-overlay');
            if (overlay) {
                overlay.style.display = 'none';
                overlay.innerHTML = '';
            }
            
            // Remove escape key handler
            document.removeEventListener('keydown', handleEscKey);
        }
        
        function handleEscKey(e) {
            if (e.key === 'Escape') {
                closeInfoPopup();
            }
        }
        
        // Make popup functions globally accessible
        window.showInfoPopup = showInfoPopup;
        window.closeInfoPopup = closeInfoPopup;
        
        // Table sorting functionality - Replaced by universal sorting
        let sortDirection = {};
        
        /*
        function sortTPTable(tableId, columnIndex) {
            const table = document.getElementById(tableId);
            const tbody = table.querySelector('tbody');
            const rows = Array.from(tbody.querySelectorAll('tr'));
            
            // Toggle sort direction
            const key = tableId + '_' + columnIndex;
            sortDirection[key] = sortDirection[key] === 'asc' ? 'desc' : 'asc';
            
            // Sort rows
            rows.sort((a, b) => {
                let aValue, bValue;
                
                if (columnIndex === 0) { // Rank
                    aValue = parseInt(a.cells[columnIndex].textContent.trim());
                    bValue = parseInt(b.cells[columnIndex].textContent.trim());
                } else if (columnIndex === 2) { // Health Score
                    // Extract score from the badge
                    const aMatch = a.cells[columnIndex].querySelector('span').getAttribute('title').match(/Score: (\d+)/);
                    const bMatch = b.cells[columnIndex].querySelector('span').getAttribute('title').match(/Score: (\d+)/);
                    aValue = aMatch ? parseInt(aMatch[1]) : 0;
                    bValue = bMatch ? parseInt(bMatch[1]) : 0;
                } else if (columnIndex >= 3 && columnIndex <= 5) { // Numeric columns
                    aValue = parseInt(a.cells[columnIndex].textContent.replace(/,/g, '').trim());
                    bValue = parseInt(b.cells[columnIndex].textContent.replace(/,/g, '').trim());
                } else if (columnIndex === 6) { // Growth Trend
                    const aMatch = a.cells[columnIndex].textContent.match(/([\d.]+)%/);
                    const bMatch = b.cells[columnIndex].textContent.match(/([\d.]+)%/);
                    aValue = aMatch ? parseFloat(aMatch[1]) : 0;
                    bValue = bMatch ? parseFloat(bMatch[1]) : 0;
                    // Consider direction
                    if (a.cells[columnIndex].textContent.includes('↓')) aValue = -aValue;
                    if (b.cells[columnIndex].textContent.includes('↓')) bValue = -bValue;
                } else { // Text columns
                    aValue = a.cells[columnIndex].textContent.trim().toLowerCase();
                    bValue = b.cells[columnIndex].textContent.trim().toLowerCase();
                }
                
                if (sortDirection[key] === 'asc') {
                    return aValue > bValue ? 1 : aValue < bValue ? -1 : 0;
                } else {
                    return aValue < bValue ? 1 : aValue > bValue ? -1 : 0;
                }
            });
            
            // Clear tbody and append sorted rows
            tbody.innerHTML = '';
            rows.forEach(row => tbody.appendChild(row));
            
            // Update header to show sort direction
            const headers = table.querySelectorAll('th');
            headers.forEach((header, index) => {
                if (header.classList.contains('sortable')) {
                    const text = header.textContent.replace(' ↑', '').replace(' ↓', '').replace(' ↕', '');
                    if (index === columnIndex) {
                        header.textContent = text + (sortDirection[key] === 'asc' ? ' ↑' : ' ↓');
                    } else {
                        header.textContent = text + ' ↕';
                    }
                }
            });
        }
        
        window.sortTPTable = sortTPTable;
        */
        
        // Initialize sorting when document is ready
        document.addEventListener('DOMContentLoaded', function() {
            // Small delay to ensure all dynamic content is loaded
            setTimeout(() => {
                if (typeof makeAllTablesSortable === 'function') {
                    makeAllTablesSortable();
                }
            }, 500);
        });
        
        function initializeCharts() {
            // Initialize all charts
            if (window.chartConfigs) {
                window.chartConfigs.forEach(config => {
                    const ctx = document.getElementById(config.id);
                    if (ctx) {
                        new Chart(ctx.getContext('2d'), config.config);
                    }
                });
            }
        }
        
        // TP-Document Type Matrix filter functions
        function filterTPDocMatrix() {
            const tpSearch = document.getElementById('tp-search').value.toLowerCase();
            const docTypeSearch = document.getElementById('doctype-search').value.toLowerCase();
            
            const table = document.querySelector('.matrix-table');
            if (!table) return;
            
            // Filter rows (TPs)
            const rows = table.querySelectorAll('tbody tr');
            rows.forEach(row => {
                const tpCell = row.querySelector('td:first-child');
                const tpText = tpCell ? tpCell.textContent.toLowerCase() : '';
                const matchesTP = !tpSearch || tpText.includes(tpSearch);
                
                if (matchesTP) {
                    row.style.display = '';
                } else {
                    row.style.display = 'none';
                }
            });
            
            // Filter columns (Doc Types)
            const headerCells = table.querySelectorAll('thead th');
            const columnIndexesToHide = [];
            
            headerCells.forEach((th, index) => {
                if (index === 0 || index === headerCells.length - 1) return; // Skip TP column and Total column
                
                const docTypeText = th.textContent.toLowerCase();
                const matchesDocType = !docTypeSearch || docTypeText.includes(docTypeSearch);
                
                if (!matchesDocType) {
                    columnIndexesToHide.push(index);
                    th.style.display = 'none';
                } else {
                    th.style.display = '';
                }
            });
            
            // Hide/show corresponding cells in all rows
            rows.forEach(row => {
                const cells = row.querySelectorAll('td');
                cells.forEach((td, index) => {
                    if (columnIndexesToHide.includes(index)) {
                        td.style.display = 'none';
                    } else {
                        td.style.display = '';
                    }
                });
            });
        }
        
        function clearTPDocFilters() {
            document.getElementById('tp-search').value = '';
            document.getElementById('doctype-search').value = '';
            filterTPDocMatrix();
        }
        
        function exportReport() {
            // Get the complete HTML content
            const htmlContent = document.documentElement.outerHTML;
            
            // Create a Blob with the HTML content
            const blob = new Blob([htmlContent], { type: 'text/html' });
            
            // Create a download link
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            
            // Generate filename with customer name and date
            const customerName = document.querySelector('.header h1').textContent.replace(/[^a-z0-9]/gi, '_');
            const date = new Date().toISOString().split('T')[0];
            link.download = customerName + '_Report_' + date + '.html';
            
            // Trigger download
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            // Clean up
            URL.revokeObjectURL(link.href);
        }
        
        // Placeholder for export functions - will be injected after iframe loads
        
        // Table sorting functionality
        const tableSortStates = {};
        
        function makeAllTablesSortable() {
            const tables = document.querySelectorAll('table');
            
            tables.forEach((table, tableIndex) => {
                if (!table.id) {
                    table.id = 'sortable-table-' + tableIndex;
                }
                
                const headers = table.querySelectorAll('thead th');
                
                headers.forEach((header, index) => {
                    if (!header.classList.contains('no-sort') && !header.onclick) {
                        header.style.cursor = 'pointer';
                        header.classList.add('sortable');
                        if (!header.innerHTML.includes('↕') && !header.innerHTML.includes('↑') && !header.innerHTML.includes('↓')) {
                            header.innerHTML += ' <span class="sort-indicator">↕</span>';
                        }
                        header.onclick = function() {
                            sortTable(table, index);
                        };
                    }
                });
            });
        }
        
        function sortTable(table, column) {
            const tbody = table.querySelector('tbody');
            if (!tbody) return;
            
            const rows = Array.from(tbody.querySelectorAll('tr'));
            if (rows.length === 0) return;
            
            const tableId = table.id || 'anonymous';
            if (!tableSortStates[tableId]) {
                tableSortStates[tableId] = {};
            }
            
            const currentSort = tableSortStates[tableId][column] || 'none';
            const newSort = currentSort === 'asc' ? 'desc' : 'asc';
            tableSortStates[tableId][column] = newSort;
            
            // Detect if column contains numeric data
            const isNumeric = rows.every(row => {
                const cellText = row.cells[column]?.textContent.trim() || '';
                const cleanedText = cellText.replace(/[$,%]/g, '').replace(/[()]/g, '');
                return !isNaN(parseFloat(cleanedText)) && isFinite(cleanedText);
            });
            
            rows.sort((a, b) => {
                const aCell = a.cells[column];
                const bCell = b.cells[column];
                if (!aCell || !bCell) return 0;
                
                let aVal = aCell.textContent.trim();
                let bVal = bCell.textContent.trim();
                
                if (isNumeric) {
                    const aNum = parseFloat(aVal.replace(/[$,%()]/g, '').replace(/[^0-9.-]/g, ''));
                    const bNum = parseFloat(bVal.replace(/[$,%()]/g, '').replace(/[^0-9.-]/g, ''));
                    
                    if (isNaN(aNum) && isNaN(bNum)) return 0;
                    if (isNaN(aNum)) return 1;
                    if (isNaN(bNum)) return -1;
                    
                    return newSort === 'asc' ? aNum - bNum : bNum - aNum;
                } else {
                    if (/^\\d{4}-\\d{2}$/.test(aVal) && /^\\d{4}-\\d{2}$/.test(bVal)) {
                        return newSort === 'asc' ? aVal.localeCompare(bVal) : bVal.localeCompare(aVal);
                    }
                    return newSort === 'asc' ? aVal.localeCompare(bVal) : bVal.localeCompare(aVal);
                }
            });
            
            rows.forEach(row => tbody.appendChild(row));
            
            const headers = table.querySelectorAll('thead th');
            headers.forEach((header, idx) => {
                const indicator = header.querySelector('.sort-indicator');
                if (indicator) {
                    if (idx === column) {
                        indicator.textContent = newSort === 'asc' ? '↑' : '↓';
                        header.classList.add('sorted');
                    } else {
                        indicator.textContent = '↕';
                        header.classList.remove('sorted');
                    }
                }
            });
        }
        
        // Initialize sorting when window loads
        if (window.addEventListener) {
            window.addEventListener('load', function() {
                setTimeout(function() {
                    makeAllTablesSortable();
                }, 500);
            });
        }
    </scr` + `ipt>
    <scr` + `ipt src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></scr` + `ipt>
</head>
<body>
    <div class="container">
        <div class="header">
            <div style="position: absolute; top: 15px; left: 20px; z-index: 10;">
                <svg width="180" height="30" viewBox="0 0 180 30" style="fill: white; opacity: 0.9;">
                    <text x="0" y="20" style="font-family: Arial, sans-serif; font-size: 16px; font-weight: normal;">
                        Opentext - Confidential
                    </text>
                </svg>
            </div>
            <div style="position: absolute; top: 10px; right: 15px; background: rgba(251, 191, 36, 0.15); backdrop-filter: blur(8px); border: 1px solid rgba(251, 191, 36, 0.2); padding: 4px 12px; border-radius: 20px; font-size: 0.8em; font-weight: 600; letter-spacing: 0.5px; color: #fef3c7;">
                ⚠️ INTERNAL USE ONLY
            </div>
            <h1>${this.customerName}</h1>
            <div class="subtitle">Customer Traffic Analysis</div>
            <div class="date-range">
                ${this.formatPeriodDisplay(firstPeriod)} — ${this.formatPeriodDisplay(lastPeriod)}
            </div>
        </div>
        
        <!-- Tabs Navigation -->
        <div class="tabs">
            <button class="tab active" onclick="showTab('monthly')">📊 Overview</button>
            <button class="tab" onclick="showTab('mom')">📈 Month over Month</button>
            <button class="tab" onclick="showTab('hubanalysis')">🌐 Hub Analysis</button>
            <button class="tab" onclick="showTab('tpanalysis')">🤝 TP Analysis</button>
            <button class="tab" onclick="showTab('docanalysis')">📄 Document Analysis</button>
        </div>
        
        
        <!-- Tab Contents -->
        <!-- Overview Tab -->
        <div id="monthly" class="tab-content active">
            ${monthlyAnalysis}
        </div>
        
        <!-- Month over Month Tab -->
        <div id="mom" class="tab-content">
            ${momAnalysis}
        </div>
        
        <!-- Hub Analysis Tab -->
        <div id="hubanalysis" class="tab-content">
            ${hubAnalysis}
        </div>
        
        <!-- TP Analysis Tab -->
        <div id="tpanalysis" class="tab-content">
            ${tpAnalysis}
        </div>
        
        <!-- Document Analysis Tab -->
        <div id="docanalysis" class="tab-content">
            ${docAnalysis}
        </div>
        
        <div class="footer">
            <p><strong>${this.customerName}</strong> | Operational Excellence Through Data</p>
            <p>Report Generated: ${new Date().toLocaleString('en-US', { 
                year: 'numeric', 
                month: 'long', 
                day: 'numeric',
                hour: 'numeric',
                minute: '2-digit',
                hour12: true 
            })}</p>
        </div>
    </div>
</body>
</html>`;
        
        return html;
    }
    
    generateMonthlyAnalysis(data) {
        if (!data.trends) {
            return "<p>No data available for monthly analysis.</p>";
        }
        
        // Get all periods and sort them
        const allPeriods = new Set();
        for (const [sheetName, trends] of Object.entries(data.trends)) {
            if (trends.periods) {
                trends.periods.forEach(p => allPeriods.add(p));
            }
        }
        
        const sortedPeriods = Array.from(allPeriods).sort();
        
        // Calculate key metrics
        const insights = this.calculateMonthlyInsights(data, sortedPeriods);
        
        let html = `<div style="background: white; padding: 30px; border-radius: 15px; box-shadow: 0 4px 20px rgba(0,0,0,0.08);">
            <h3 style="margin-top: 0; color: #1a365d; margin-bottom: 30px;">📊 Performance Overview
                <span class="info-icon">i
                    <div class="tooltip">
                        The Performance Overview tab provides a high-level summary of your business metrics.
                        It includes scorecards, executive summaries, volume trends, and AI-generated insights.
                        This tab is designed to give you a quick understanding of overall performance.
                        Use this as your starting point for daily monitoring and strategic planning.
                    </div>
                </span>
            </h3>`;
        
        // Add Intelligent Insights at the top
        html += this.generateIntelligentInsights(data, sortedPeriods);
        
        // Performance Scorecard
        html += this.generatePerformanceScorecard(insights, data, sortedPeriods);
        
        // Executive Summary
        html += this.generateExecutiveSummary(insights, sortedPeriods[sortedPeriods.length - 1]);
        
        // KC Executive Summary
        const kcInsights = this.calculateMonthlyKCInsights(data, sortedPeriods);
        html += this.generateKCExecutiveSummary(kcInsights, sortedPeriods[sortedPeriods.length - 1]);
        
        // Volume Trend Charts
        html += this.generateVolumeTrendCharts(data, sortedPeriods);
        
        // Seasonality Pattern
        html += this.generateOverviewSeasonalityPattern(data, sortedPeriods);
        
        // Comparative Analysis
        html += this.generateComparativeAnalysis(data, sortedPeriods);
        
        html += "</div>";
        return html;
    }
    
    calculateMonthlyInsights(data, sortedPeriods) {
        const insights = {
            current_volume: 0,
            prev_volume: 0,
            yoy_volume: 0,
            growth_rate: 0,
            yoy_growth: 0,
            efficiency_score: 0,
            anomalies: [],
            top_contributors: [],
            avg_volume: 0,
            avg_growth_rate: 0,
            total_volume: 0,
            period_count: 0
        };
        
        if (!sortedPeriods || sortedPeriods.length === 0) {
            return insights;
        }
        
        // Calculate volumes for different periods
        const currentPeriod = sortedPeriods[sortedPeriods.length - 1];
        const prevPeriod = sortedPeriods.length >= 2 ? sortedPeriods[sortedPeriods.length - 2] : null;
        const yearAgo = sortedPeriods.length >= 13 ? sortedPeriods[sortedPeriods.length - 13] : sortedPeriods[0];
        
        // Sum up total documents only from Date_Summary sheet
        for (const [sheetName, trends] of Object.entries(data.trends || {})) {
            if (sheetName === 'Date_Summary' && trends.metric_trends && trends.metric_trends['TOTAL-DOC']) {
                const docTrend = trends.metric_trends['TOTAL-DOC'];
                const periods = trends.periods;
                
                if (periods.includes(currentPeriod)) {
                    const idx = periods.indexOf(currentPeriod);
                    insights.current_volume += docTrend[idx] || 0;
                }
                
                if (prevPeriod && periods.includes(prevPeriod)) {
                    const idx = periods.indexOf(prevPeriod);
                    insights.prev_volume += docTrend[idx] || 0;
                }
                
                if (periods.includes(yearAgo)) {
                    const idx = periods.indexOf(yearAgo);
                    insights.yoy_volume += docTrend[idx] || 0;
                }
                
                // Calculate totals and averages
                insights.total_volume = docTrend.reduce((a, b) => a + b, 0);
                insights.period_count = docTrend.length;
                insights.avg_volume = insights.period_count > 0 ? insights.total_volume / insights.period_count : 0;
                
                // Calculate average growth rate
                const growthRates = [];
                for (let i = 1; i < docTrend.length; i++) {
                    if (docTrend[i-1] > 0) {
                        const growth = ((docTrend[i] - docTrend[i-1]) / docTrend[i-1]) * 100;
                        growthRates.push(growth);
                    }
                }
                insights.avg_growth_rate = growthRates.length > 0 ? 
                    growthRates.reduce((a, b) => a + b, 0) / growthRates.length : 0;
            }
        }
        
        // Calculate growth rates
        if (insights.prev_volume > 0) {
            insights.growth_rate = ((insights.current_volume - insights.prev_volume) / insights.prev_volume) * 100;
        }
        
        if (insights.yoy_volume > 0) {
            insights.yoy_growth = ((insights.current_volume - insights.yoy_volume) / insights.yoy_volume) * 100;
        }
        
        // Calculate efficiency score
        let currentKcs = 0;
        for (const [sheetName, trends] of Object.entries(data.trends || {})) {
            if (sheetName === 'Date_Summary' && trends.metric_trends && trends.metric_trends['TOTAL-KCS']) {
                const kcsTrend = trends.metric_trends['TOTAL-KCS'];
                const periods = trends.periods;
                if (periods.includes(currentPeriod)) {
                    const idx = periods.indexOf(currentPeriod);
                    currentKcs += kcsTrend[idx] || 0;
                }
            }
        }
        
        if (currentKcs > 0) {
            insights.efficiency_score = insights.current_volume / currentKcs;
        }
        
        return insights;
    }
    
    generatePerformanceScorecard(insights, data, sortedPeriods) {
        // Get last 3 months of data
        const last3Months = sortedPeriods.slice(-3);
        
        // Calculate 3-month metrics
        const docVolumes3mo = [];
        const kcVolumes3mo = [];
        
        if (data.trends && data.trends.Date_Summary) {
            const dateTrends = data.trends.Date_Summary;
            if (dateTrends.metric_trends && dateTrends.periods) {
                const periods = dateTrends.periods;
                const docTrend = dateTrends.metric_trends['TOTAL-DOC'] || [];
                const kcTrend = dateTrends.metric_trends['TOTAL-KCS'] || [];
                
                for (const month of last3Months) {
                    const idx = periods.indexOf(month);
                    if (idx >= 0) {
                        if (idx < docTrend.length) {
                            docVolumes3mo.push(docTrend[idx]);
                        }
                        if (idx < kcTrend.length) {
                            kcVolumes3mo.push(kcTrend[idx]);
                        }
                    }
                }
            }
        }
        
        // Calculate growth rates for both documents and KCs
        const docGrowthRates = [];
        const kcGrowthRates = [];
        
        if (docVolumes3mo.length >= 2) {
            for (let i = 1; i < docVolumes3mo.length; i++) {
                if (docVolumes3mo[i-1] > 0) {
                    const growth = ((docVolumes3mo[i] - docVolumes3mo[i-1]) / docVolumes3mo[i-1]) * 100;
                    docGrowthRates.push(growth);
                }
            }
        }
        
        if (kcVolumes3mo.length >= 2) {
            for (let i = 1; i < kcVolumes3mo.length; i++) {
                if (kcVolumes3mo[i-1] > 0) {
                    const growth = ((kcVolumes3mo[i] - kcVolumes3mo[i-1]) / kcVolumes3mo[i-1]) * 100;
                    kcGrowthRates.push(growth);
                }
            }
        }
        
        const avgDocGrowth3mo = docGrowthRates.length > 0 ? 
            docGrowthRates.reduce((a, b) => a + b, 0) / docGrowthRates.length : 0;
        const avgKcGrowth3mo = kcGrowthRates.length > 0 ? 
            kcGrowthRates.reduce((a, b) => a + b, 0) / kcGrowthRates.length : 0;
        
        // Combined average growth
        const avgGrowth3mo = (avgDocGrowth3mo + avgKcGrowth3mo) / 2;
        
        // Determine health status based on both metrics
        let healthStatus = "healthy";
        let healthReason = "";
        
        // Analyze the combination of doc and KC growth
        const docTrend = avgDocGrowth3mo > 1 ? "growing" : avgDocGrowth3mo < -1 ? "declining" : "stable";
        const kcTrend = avgKcGrowth3mo > 1 ? "growing" : avgKcGrowth3mo < -1 ? "declining" : "stable";
        
        if (docTrend === "growing" && kcTrend === "growing") {
            healthStatus = avgGrowth3mo > 10 ? "excellent" : "healthy";
            healthReason = `Strong business expansion detected. Document volume is increasing by ${avgDocGrowth3mo.toFixed(1)}% monthly while data volume (KCs) grows by ${avgKcGrowth3mo.toFixed(1)}% monthly. This indicates both more transactions and potentially new business relationships or expanded services.`;
        } else if (docTrend === "declining" && kcTrend === "declining") {
            healthStatus = avgGrowth3mo < -10 ? "critical" : "warning";
            healthReason = `Business contraction observed. Document volume declining by ${Math.abs(avgDocGrowth3mo).toFixed(1)}% monthly and data volume (KCs) declining by ${Math.abs(avgKcGrowth3mo).toFixed(1)}% monthly. This suggests reduced trading activity and requires investigation into root causes such as partner attrition or market conditions.`;
        } else if (docTrend === "growing" && kcTrend === "declining") {
            healthStatus = "healthy";
            healthReason = `Efficiency improvements detected. Document count increasing by ${avgDocGrowth3mo.toFixed(1)}% monthly while data volume decreasing by ${Math.abs(avgKcGrowth3mo).toFixed(1)}% monthly. This positive trend indicates streamlined processes, optimized document formats, or shift towards smaller transaction types.`;
        } else if (docTrend === "declining" && kcTrend === "growing") {
            healthStatus = "warning";
            healthReason = `Document complexity increasing. Document count declining by ${Math.abs(avgDocGrowth3mo).toFixed(1)}% monthly while data volume growing by ${avgKcGrowth3mo.toFixed(1)}% monthly. This may indicate consolidation of transactions, shift to larger documents, or increased data requirements per transaction.`;
        } else if ((docTrend === "stable" && kcTrend === "growing") || (docTrend === "growing" && kcTrend === "stable")) {
            healthStatus = "healthy";
            healthReason = `Mixed performance signals. Documents ${docTrend} (${avgDocGrowth3mo.toFixed(1)}% monthly) while KCs ${kcTrend} (${avgKcGrowth3mo.toFixed(1)}% monthly). This suggests changing business patterns that may require further analysis to determine if adjustments are needed.`;
        } else {
            healthStatus = "healthy";
            healthReason = `Business operations stable. Document volume changing by ${avgDocGrowth3mo.toFixed(1)}% monthly and data volume by ${avgKcGrowth3mo.toFixed(1)}% monthly. Both metrics remain within normal operating ranges, indicating consistent business performance.`;
        }
        
        const healthColor = {"excellent": "#059669", "healthy": "#16a34a", "warning": "#f59e0b", "critical": "#dc2626"}[healthStatus];
        const healthIcon = {"excellent": "🌟", "healthy": "✅", "warning": "⚠️", "critical": "❌"}[healthStatus];
        
        // Determine volume trend for both metrics
        let trendDirection = "";
        let trendIcon = "";
        let trendReason = "";
        
        // Calculate total changes over 3 months
        let docTotalChange3mo = 0;
        let kcTotalChange3mo = 0;
        
        if (docVolumes3mo.length >= 2) {
            docTotalChange3mo = ((docVolumes3mo[docVolumes3mo.length - 1] - docVolumes3mo[0]) / docVolumes3mo[0]) * 100;
        }
        if (kcVolumes3mo.length >= 2) {
            kcTotalChange3mo = ((kcVolumes3mo[kcVolumes3mo.length - 1] - kcVolumes3mo[0]) / kcVolumes3mo[0]) * 100;
        }
        
        // Determine combined trend direction
        if (docTrend === "growing" && kcTrend === "growing") {
            trendDirection = "Expanding";
            trendIcon = "📈📈";
            trendReason = `Business volume expanding across both dimensions. Document count increased ${docTotalChange3mo >= 0 ? '+' : ''}${docTotalChange3mo.toFixed(1)}% and data volume (KCs) increased ${kcTotalChange3mo >= 0 ? '+' : ''}${kcTotalChange3mo.toFixed(1)}% over the 3-month period. This synchronized growth suggests increased market activity and business opportunities.`;
        } else if (docTrend === "declining" && kcTrend === "declining") {
            trendDirection = "Contracting";
            trendIcon = "📉📉";
            trendReason = `Volume contraction across both metrics. Document count decreased ${Math.abs(docTotalChange3mo).toFixed(1)}% and data volume decreased ${Math.abs(kcTotalChange3mo).toFixed(1)}% over the 3-month period. This aligned decline indicates reduced business activity that warrants strategic review.`;
        } else if (docTrend !== kcTrend) {
            trendDirection = "Mixed";
            trendIcon = "📊";
            const interpretation = docTotalChange3mo > 0 && kcTotalChange3mo < 0 ? 
                "This divergence suggests operational efficiency gains with more streamlined document processing." :
                docTotalChange3mo < 0 && kcTotalChange3mo > 0 ?
                "This pattern indicates shift towards larger, more complex documents or data-rich transactions." :
                "This mixed pattern suggests evolving business requirements.";
            trendReason = `Divergent trend patterns observed. Documents changed ${docTotalChange3mo >= 0 ? '+' : ''}${docTotalChange3mo.toFixed(1)}% while KCs changed ${kcTotalChange3mo >= 0 ? '+' : ''}${kcTotalChange3mo.toFixed(1)}% over the period. ${interpretation}`;
        } else {
            trendDirection = "Stable";
            trendIcon = "➡️";
            trendReason = `Volume metrics remain stable. Document count varied ${docTotalChange3mo >= 0 ? '+' : ''}${docTotalChange3mo.toFixed(1)}% and data volume varied ${kcTotalChange3mo >= 0 ? '+' : ''}${kcTotalChange3mo.toFixed(1)}% over the 3-month period. This stability indicates consistent operational performance within normal business fluctuations.`;
        }
        
        const scorecard = `
        <div style="margin-bottom: 30px;">
            <h4 style="color: #2d3748;">🎯 Performance Scorecard
                <span class="info-icon">i
                    <div class="tooltip">
                        The Performance Scorecard provides a comprehensive health assessment combining both document and kilocharacter metrics.
                        It analyzes trends over the last 3 months to identify business expansion, contraction, or efficiency changes.
                        Health status considers both metrics: Excellent (both growing >10%), Healthy (positive patterns), 
                        Warning (mixed signals or decline), Critical (both declining significantly).
                        Mixed trends are interpreted: growing docs with declining KCs suggests efficiency improvements,
                        while declining docs with growing KCs may indicate increasing document complexity.
                    </div>
                </span>
            </h4>
            <p style="color: #718096; font-size: 0.9em; margin-bottom: 20px;">
                Assessment based on the last 3 months of data (${this.formatPeriodDisplay(last3Months[0])} - ${this.formatPeriodDisplay(last3Months[last3Months.length - 1])})
            </p>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px;">
                <div class="metric-card" style="border-top-color: ${healthColor};">
                    <div class="metric-label">Overall Health</div>
                    <div class="metric-value" style="color: ${healthColor};">${healthIcon} ${healthStatus.charAt(0).toUpperCase() + healthStatus.slice(1)}</div>
                    <div class="metric-detail" style="margin-top: 10px;">
                        <strong>Assessment:</strong> ${healthReason}
                    </div>
                    <div style="margin-top: 10px; font-size: 0.85em; color: #94a3b8;">
                        <strong>3-Month Metrics:</strong><br>
                        • Document growth: ${avgDocGrowth3mo >= 0 ? '+' : ''}${avgDocGrowth3mo.toFixed(1)}% monthly<br>
                        • KC growth: ${avgKcGrowth3mo >= 0 ? '+' : ''}${avgKcGrowth3mo.toFixed(1)}% monthly<br>
                        • Combined growth: ${avgGrowth3mo >= 0 ? '+' : ''}${avgGrowth3mo.toFixed(1)}% monthly
                    </div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Volume Trend</div>
                    <div class="metric-value">${trendIcon} ${trendDirection}</div>
                    <div class="metric-detail" style="margin-top: 10px;">
                        <strong>Assessment:</strong> ${trendReason}
                    </div>
                    <div style="margin-top: 10px; font-size: 0.85em; color: #94a3b8;">
                        <strong>Document Changes:</strong><br>
                        ${this.formatMonthlyChanges(last3Months, docVolumes3mo)}
                        <br><strong style="margin-top: 10px; display: inline-block;">KC Changes:</strong><br>
                        ${this.formatMonthlyChanges(last3Months, kcVolumes3mo)}
                    </div>
                </div>
            </div>
        </div>`;
        
        return scorecard;
    }
    
    generateExecutiveSummary(insights, currentPeriod) {
        const growthIcon = insights.growth_rate > 0 ? "📈" : insights.growth_rate < 0 ? "📉" : "➡️";
        const currentDisplay = this.formatPeriodDisplay(currentPeriod);
        
        const summaryText = `
        <div class="info-box" style="margin-bottom: 30px; background: #f0f9ff; border-left: 4px solid #3182ce;">
            <h4 style="margin-top: 0; color: #1e40af;">📋 Document Summary - ${currentDisplay}
                <span class="info-icon">i
                    <div class="tooltip">
                        The Document Summary provides key insights about your document processing performance.
                        It includes document volumes, growth rates, and efficiency metrics for the last 3 months.
                        Total documents are calculated by summing all columns containing 'DOC' in their names.
                        Efficiency ratio (Docs/KC) shows how many documents are processed per kilocharacter.
                    </div>
                </span>
            </h4>
            <p style="color: #64748b; margin: 10px 0 20px 0; font-size: 0.9em;">
                This summary shows document processing metrics for the most recent period (${currentDisplay}) compared to previous periods. 
                All volume metrics represent total documents processed during each period.
            </p>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin-top: 15px;">
                <div>
                    <strong style="color: #64748b;">Current Volume</strong><br>
                    <span style="font-size: 1.5em; color: #1e40af;">${insights.current_volume.toLocaleString()}</span> documents
                    <div style="font-size: 0.8em; color: #94a3b8; margin-top: 5px;">Total for ${currentDisplay}</div>
                </div>
                <div>
                    <strong style="color: #64748b;">Month-over-Month</strong><br>
                    <span style="font-size: 1.5em; color: ${insights.growth_rate > 0 ? '#16a34a' : insights.growth_rate < 0 ? '#dc2626' : '#64748b'};">
                        ${growthIcon} ${insights.growth_rate >= 0 ? '+' : ''}${insights.growth_rate.toFixed(1)}%
                    </span>
                    <div style="font-size: 0.8em; color: #94a3b8; margin-top: 5px;">vs previous month</div>
                </div>
                <div>
                    <strong style="color: #64748b;">Efficiency Score
                        <span class="info-icon" style="font-size: 0.8em; margin-left: 5px;">i
                            <div class="tooltip">
                                Efficiency Score (docs/KC) measures document processing efficiency.
                                Higher scores (>1.0) indicate efficient processing with smaller documents.
                                Lower scores (<0.5) suggest larger, data-intensive documents.
                                This metric helps identify opportunities to optimize document size and structure.
                            </div>
                        </span>
                    </strong><br>
                    <span style="font-size: 1.5em; color: #1e40af;">${insights.efficiency_score.toFixed(2)}</span> docs/KC
                    <div style="font-size: 0.8em; color: #94a3b8; margin-top: 5px;">Documents per kilocharacter</div>
                </div>
            </div>
            
            <!-- Period Averages Section -->
            <div style="margin-top: 25px; padding-top: 25px; border-top: 1px solid #e2e8f0;">
                <h5 style="color: #64748b; margin: 0 0 15px 0; font-size: 0.95em;">📊 Period Averages (${insights.period_count} months analyzed)</h5>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px;">
                    <div>
                        <strong style="color: #64748b;">Average Volume</strong><br>
                        <span style="font-size: 1.3em; color: #4a5568;">${insights.avg_volume.toLocaleString()}</span> docs/month
                        <div style="font-size: 0.8em; color: #94a3b8; margin-top: 5px;">Across all periods</div>
                    </div>
                    <div>
                        <strong style="color: #64748b;">Average Growth Rate</strong><br>
                        <span style="font-size: 1.3em; color: ${insights.avg_growth_rate > 0 ? '#16a34a' : insights.avg_growth_rate < 0 ? '#dc2626' : '#64748b'};">
                            ${insights.avg_growth_rate > 0 ? '📈' : insights.avg_growth_rate < 0 ? '📉' : '➡️'} ${insights.avg_growth_rate >= 0 ? '+' : ''}${insights.avg_growth_rate.toFixed(1)}%
                        </span>
                        <div style="font-size: 0.8em; color: #94a3b8; margin-top: 5px;">Month-over-month average</div>
                    </div>
                    <div>
                        <strong style="color: #64748b;">Total Volume</strong><br>
                        <span style="font-size: 1.3em; color: #4a5568;">${insights.total_volume.toLocaleString()}</span> documents
                        <div style="font-size: 0.8em; color: #94a3b8; margin-top: 5px;">All periods combined</div>
                    </div>
                </div>
            </div>
        </div>`;
        
        return summaryText;
    }
    
    calculateMonthlyKCInsights(data, sortedPeriods) {
        const insights = {
            current_kc: 0,
            prev_kc: 0,
            yoy_kc: 0,
            growth_rate: 0,
            yoy_growth: 0,
            kc_per_doc: 0,
            anomalies: [],
            top_contributors: [],
            avg_kc: 0,
            avg_growth_rate: 0,
            total_kc: 0,
            period_count: 0
        };
        
        if (!sortedPeriods || sortedPeriods.length === 0) {
            return insights;
        }
        
        // Calculate volumes for different periods
        const currentPeriod = sortedPeriods[sortedPeriods.length - 1];
        const prevPeriod = sortedPeriods.length >= 2 ? sortedPeriods[sortedPeriods.length - 2] : null;
        const yearAgo = sortedPeriods.length >= 13 ? sortedPeriods[sortedPeriods.length - 13] : sortedPeriods[0];
        
        // Sum up total KCs only from Date_Summary sheet
        for (const [sheetName, trends] of Object.entries(data.trends || {})) {
            if (sheetName === 'Date_Summary' && trends.metric_trends && trends.metric_trends['TOTAL-KCS']) {
                const kcTrend = trends.metric_trends['TOTAL-KCS'];
                const periods = trends.periods;
                
                if (periods.includes(currentPeriod)) {
                    const idx = periods.indexOf(currentPeriod);
                    insights.current_kc += kcTrend[idx] || 0;
                }
                
                if (prevPeriod && periods.includes(prevPeriod)) {
                    const idx = periods.indexOf(prevPeriod);
                    insights.prev_kc += kcTrend[idx] || 0;
                }
                
                if (periods.includes(yearAgo)) {
                    const idx = periods.indexOf(yearAgo);
                    insights.yoy_kc += kcTrend[idx] || 0;
                }
            }
        }
        
        // Calculate growth rates
        if (insights.prev_kc > 0) {
            insights.growth_rate = ((insights.current_kc - insights.prev_kc) / insights.prev_kc) * 100;
        }
        
        if (insights.yoy_kc > 0) {
            insights.yoy_growth = ((insights.current_kc - insights.yoy_kc) / insights.yoy_kc) * 100;
        }
        
        // Calculate period averages and totals
        if (data.trends && data.trends.Date_Summary && data.trends.Date_Summary.metric_trends) {
            if (data.trends.Date_Summary.metric_trends['TOTAL-KCS']) {
                const kcValues = data.trends.Date_Summary.metric_trends['TOTAL-KCS'];
                insights.period_count = kcValues.length;
                insights.total_kc = kcValues.reduce((a, b) => a + b, 0);
                insights.avg_kc = insights.period_count > 0 ? insights.total_kc / insights.period_count : 0;
                
                // Calculate average growth rate
                const growthRates = [];
                for (let i = 1; i < kcValues.length; i++) {
                    if (kcValues[i-1] > 0) {
                        const growth = ((kcValues[i] - kcValues[i-1]) / kcValues[i-1]) * 100;
                        growthRates.push(growth);
                    }
                }
                
                if (growthRates.length > 0) {
                    insights.avg_growth_rate = growthRates.reduce((a, b) => a + b, 0) / growthRates.length;
                }
            }
        }
        
        // Calculate KC per document ratio
        for (const [sheetName, trends] of Object.entries(data.trends || {})) {
            if (sheetName === 'Date_Summary' && trends.metric_trends && trends.metric_trends['TOTAL-DOC']) {
                const docTrend = trends.metric_trends['TOTAL-DOC'];
                const periods = trends.periods;
                if (periods.includes(currentPeriod)) {
                    const idx = periods.indexOf(currentPeriod);
                    const currentDocs = docTrend[idx] || 0;
                    if (currentDocs > 0) {
                        insights.kc_per_doc = insights.current_kc / currentDocs;
                    }
                }
            }
        }
        
        return insights;
    }
    
    generateKCExecutiveSummary(kcInsights, currentPeriod) {
        const growthIcon = kcInsights.growth_rate > 0 ? "📈" : kcInsights.growth_rate < 0 ? "📉" : "➡️";
        const currentDisplay = this.formatPeriodDisplay(currentPeriod);
        
        const summaryText = `
        <div class="info-box" style="margin-bottom: 30px; background: #f0fdf4; border-left: 4px solid #16a34a;">
            <h4 style="margin-top: 0; color: #166534;">📈 KC (Kilocharacter) Summary - ${currentDisplay}
                <span class="info-icon">i
                    <div class="tooltip">
                        The KC Summary tracks kilocharacter volumes and trends.
                        Kilocharacters (KC) represent data volume in thousands of characters.
                        This metric helps understand data processing capacity and efficiency.
                        Growth trends show how your data volume is changing over time.
                    </div>
                </span>
            </h4>
            <p style="color: #64748b; margin: 10px 0 20px 0; font-size: 0.9em;">
                This summary shows kilocharacter (KC) processing metrics for the most recent period (${currentDisplay}) compared to previous periods. 
                KC metrics represent the total character volume processed, indicating data complexity and processing load.
            </p>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin-top: 15px;">
                <div>
                    <strong style="color: #64748b;">Current KC Volume</strong><br>
                    <span style="font-size: 1.5em; color: #166534;">${kcInsights.current_kc.toLocaleString()}</span> KCs
                    <div style="font-size: 0.8em; color: #94a3b8; margin-top: 5px;">Total for ${currentDisplay}</div>
                </div>
                <div>
                    <strong style="color: #64748b;">Month-over-Month</strong><br>
                    <span style="font-size: 1.5em; color: ${kcInsights.growth_rate > 0 ? '#16a34a' : kcInsights.growth_rate < 0 ? '#dc2626' : '#64748b'};">
                        ${growthIcon} ${kcInsights.growth_rate >= 0 ? '+' : ''}${kcInsights.growth_rate.toFixed(1)}%
                    </span>
                    <div style="font-size: 0.8em; color: #94a3b8; margin-top: 5px;">vs previous month</div>
                </div>
                <div>
                    <strong style="color: #64748b;">Efficiency Score
                        <span class="info-icon" style="font-size: 0.8em; margin-left: 5px;">i
                            <div class="tooltip">
                                Efficiency Score measures average document size in kilocharacters (KC).
                                Lower scores (1-3 KC/doc) indicate efficient, streamlined documents.
                                Higher scores (>5 KC/doc) may indicate verbose documents or data-heavy transmissions.
                                Industry best practice targets 2-4 KC/doc for most document types.
                            </div>
                        </span>
                    </strong><br>
                    <span style="font-size: 1.5em; color: #166534;">${kcInsights.kc_per_doc.toFixed(2)}</span> KC/doc
                    <div style="font-size: 0.8em; color: #94a3b8; margin-top: 5px;">Average document size</div>
                </div>
            </div>
            
            <!-- Period Averages Section -->
            <div style="margin-top: 25px; padding-top: 25px; border-top: 1px solid #e2e8f0;">
                <h5 style="color: #64748b; margin: 0 0 15px 0; font-size: 0.95em;">📊 KC Period Averages (${kcInsights.period_count} months analyzed)</h5>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px;">
                    <div>
                        <strong style="color: #64748b;">Average KC Volume</strong><br>
                        <span style="font-size: 1.3em; color: #4a5568;">${kcInsights.avg_kc.toLocaleString()}</span> KCs/month
                        <div style="font-size: 0.8em; color: #94a3b8; margin-top: 5px;">Across all periods</div>
                    </div>
                    <div>
                        <strong style="color: #64748b;">Average KC Growth Rate</strong><br>
                        <span style="font-size: 1.3em; color: ${kcInsights.avg_growth_rate > 0 ? '#16a34a' : kcInsights.avg_growth_rate < 0 ? '#dc2626' : '#64748b'};">
                            ${kcInsights.avg_growth_rate > 0 ? '📈' : kcInsights.avg_growth_rate < 0 ? '📉' : '➡️'} ${kcInsights.avg_growth_rate >= 0 ? '+' : ''}${kcInsights.avg_growth_rate.toFixed(1)}%
                        </span>
                        <div style="font-size: 0.8em; color: #94a3b8; margin-top: 5px;">Month-over-month average</div>
                    </div>
                    <div>
                        <strong style="color: #64748b;">Total KC Volume</strong><br>
                        <span style="font-size: 1.3em; color: #4a5568;">${kcInsights.total_kc.toLocaleString()}</span> KCs
                        <div style="font-size: 0.8em; color: #94a3b8; margin-top: 5px;">All periods combined</div>
                    </div>
                </div>
            </div>
        </div>`;
        
        return summaryText;
    }
    
    generateIntelligentInsights(data, sortedPeriods) {
        // Gather all available data
        const docInsights = this.calculateMonthlyInsights(data, sortedPeriods);
        const kcInsights = this.calculateMonthlyKCInsights(data, sortedPeriods);
        const tpData = this.extractTPData(data);
        const docData = this.extractDocumentData(data);
        
        // Generate insights
        const insights = [];
        
        // Growth insights
        const growthInsight = this.generateGrowthInsight(docInsights, kcInsights, sortedPeriods);
        if (growthInsight) insights.push(growthInsight);
        
        // Efficiency insights
        const efficiencyInsight = this.generateEfficiencyInsight(docInsights, kcInsights);
        if (efficiencyInsight) insights.push(efficiencyInsight);
        
        // Partner concentration insights
        const partnerInsight = this.generatePartnerConcentrationInsight(tpData);
        if (partnerInsight) insights.push(partnerInsight);
        
        // Seasonality insights
        const seasonalityInsight = this.generateSeasonalityInsight(data, sortedPeriods);
        if (seasonalityInsight) insights.push(seasonalityInsight);
        
        // Trend insights
        const trendInsight = this.generateTrendInsight(docInsights, sortedPeriods);
        if (trendInsight) insights.push(trendInsight);
        
        // Sort insights by priority
        insights.sort((a, b) => b.priority - a.priority);
        
        // Generate HTML
        let html = `
        <div style="margin-bottom: 30px; background: #f8f9fa; padding: 25px; border-radius: 10px; border: 1px solid #e9ecef;">
            <div style="margin-bottom: 20px;">
                <h3 style="margin: 0; color: #1a365d; font-size: 1.3em;">📊 Key Business Insights
                    <span class="info-icon">i
                        <div class="tooltip">
                            Key insights analyze your data to provide actionable recommendations.
                            Insights are prioritized by importance and color-coded: green (positive), yellow (attention), red (action needed).
                            These insights update dynamically based on your latest data patterns.
                        </div>
                    </span>
                </h3>
                <p style="margin: 8px 0 0 0; color: #718096; font-size: 0.9em;">
                    Data-driven analysis based on the entire ${sortedPeriods.length}-month period (${this.formatPeriodDisplay(sortedPeriods[0])} to ${this.formatPeriodDisplay(sortedPeriods[sortedPeriods.length - 1])})
                </p>
            </div>
            
            <div>
                <div style="display: grid; gap: 10px;">
                    ${insights.slice(0, 5).map(insight => `
                        <div style="display: flex; align-items: start; gap: 12px; background: white; padding: 15px; border-radius: 8px; border: 1px solid #e2e8f0;">
                            <div style="font-size: 1.5em;">${insight.icon}</div>
                            <div style="flex: 1;">
                                <div style="font-weight: 600; margin-bottom: 4px; color: ${insight.color === '#4ade80' ? '#16a34a' : insight.color === '#fbbf24' ? '#d97706' : insight.color === '#f87171' ? '#dc2626' : '#1e40af'};">
                                    ${insight.title}
                                </div>
                                <div style="font-size: 0.9em; color: #4b5563; line-height: 1.4;">
                                    ${insight.message}
                                </div>
                                ${insight.recommendation ? `
                                    <div style="font-size: 0.85em; margin-top: 8px; padding-top: 8px; border-top: 1px solid #e5e7eb; color: #6b7280;">
                                        💡 ${insight.recommendation}
                                    </div>
                                ` : ''}
                            </div>
                        </div>
                    `).join('')}
                </div>
            </div>
        </div>`;
        
        return html;
    }
    
    // Commented out - Business Health Score no longer displayed
    /*
    calculateBusinessHealthScore(docInsights, kcInsights, tpData, sortedPeriods) {
        let score = 50; // Base score
        
        // Growth component (0-25 points)
        const docGrowth = docInsights.growth_rate;
        const kcGrowth = kcInsights.growth_rate;
        const avgGrowth = (docGrowth + kcGrowth) / 2;
        
        if (avgGrowth > 10) score += 25;
        else if (avgGrowth > 5) score += 20;
        else if (avgGrowth > 0) score += 15;
        else if (avgGrowth > -5) score += 10;
        else if (avgGrowth > -10) score += 5;
        
        // Efficiency component (0-25 points)
        const efficiency = docInsights.efficiency_score;
        const kcPerDoc = kcInsights.kc_per_doc;
        
        if (efficiency > 5) score += 25;
        else if (efficiency > 3) score += 20;
        else if (efficiency > 2) score += 15;
        else if (efficiency > 1) score += 10;
        else score += 5;
        
        // Partner diversity component (0-25 points)
        if (tpData) {
            const tpAnalysis = this.analyzeTPData(tpData);
            const topPartnerShare = tpAnalysis.top_partner_percentage || 0;
            
            if (topPartnerShare < 20) score += 25;
            else if (topPartnerShare < 30) score += 20;
            else if (topPartnerShare < 40) score += 15;
            else if (topPartnerShare < 50) score += 10;
            else score += 5;
        }
        
        // Stability component (0-25 points based on volatility)
        const volatility = this.calculateVolatility(sortedPeriods, docInsights);
        if (volatility < 10) score += 25;
        else if (volatility < 20) score += 20;
        else if (volatility < 30) score += 15;
        else if (volatility < 40) score += 10;
        else score += 5;
        
        // Ensure score is within bounds
        return Math.max(0, Math.min(100, Math.round(score)));
    }
    */
    
    generateGrowthInsight(docInsights, kcInsights, sortedPeriods) {
        const avgGrowth = (docInsights.growth_rate + kcInsights.growth_rate) / 2;
        const yoyGrowth = docInsights.yoy_growth;
        
        let insight = {
            priority: 0,
            icon: '',
            title: '',
            message: '',
            recommendation: '',
            color: '#ffffff'
        };
        
        if (avgGrowth > 15) {
            insight.priority = 9;
            insight.icon = '🚀';
            insight.title = 'Exceptional Growth';
            insight.message = `Your business is growing rapidly at ${avgGrowth.toFixed(1)}% month-over-month. Document volume increased by ${docInsights.growth_rate.toFixed(1)}% and KC volume by ${kcInsights.growth_rate.toFixed(1)}%.`;
            insight.recommendation = 'Monitor capacity constraints and ensure infrastructure can handle continued growth.';
            insight.color = '#10b981';
        } else if (avgGrowth > 5) {
            insight.priority = 7;
            insight.icon = '📈';
            insight.title = 'Steady Growth';
            insight.message = `Healthy growth trajectory with ${avgGrowth.toFixed(1)}% average monthly increase across key metrics.`;
            insight.recommendation = 'Maintain current strategies while exploring opportunities for acceleration.';
            insight.color = '#10b981';
        } else if (avgGrowth > -5) {
            insight.priority = 5;
            insight.icon = '➡️';
            insight.title = 'Stable Performance';
            insight.message = `Business volumes are relatively stable with ${avgGrowth > 0 ? '+' : ''}${avgGrowth.toFixed(1)}% average monthly change.`;
            insight.recommendation = 'Consider new initiatives to stimulate growth and expand market share.';
            insight.color = '#fbbf24';
        } else {
            insight.priority = 10;
            insight.icon = '⚠️';
            insight.title = 'Declining Volumes';
            insight.message = `Business volumes are declining at ${avgGrowth.toFixed(1)}% per month. This requires immediate attention.`;
            insight.recommendation = 'Investigate root causes and implement corrective actions to reverse the trend.';
            insight.color = '#ef4444';
        }
        
        return insight;
    }
    
    generateEfficiencyInsight(docInsights, kcInsights) {
        const efficiency = docInsights.efficiency_score;
        const kcPerDoc = kcInsights.kc_per_doc;
        const efficiencyTrend = docInsights.efficiency_trend || 0;
        
        let insight = {
            priority: 0,
            icon: '',
            title: '',
            message: '',
            recommendation: '',
            color: '#ffffff'
        };
        
        if (efficiency > 5 && kcPerDoc < 2) {
            insight.priority = 8;
            insight.icon = '⚡';
            insight.title = 'High Processing Efficiency';
            insight.message = `Excellent efficiency with ${efficiency.toFixed(2)} documents per KC. Your average document size is ${kcPerDoc.toFixed(2)} KC, indicating streamlined processing.`;
            insight.recommendation = 'Document and share best practices to maintain this efficiency level.';
            insight.color = '#10b981';
        } else if (efficiency > 3) {
            insight.priority = 4;
            insight.icon = '✅';
            insight.title = 'Good Efficiency';
            insight.message = `Processing efficiency is healthy at ${efficiency.toFixed(2)} docs/KC with average document size of ${kcPerDoc.toFixed(2)} KC.`;
            insight.recommendation = 'Look for opportunities to optimize document types with larger KC footprints.';
            insight.color = '#10b981';
        } else {
            insight.priority = 7;
            insight.icon = '🔧';
            insight.title = 'Efficiency Opportunity';
            insight.message = `Current efficiency of ${efficiency.toFixed(2)} docs/KC suggests room for improvement. Documents average ${kcPerDoc.toFixed(2)} KC each.`;
            insight.recommendation = 'Analyze high-KC document types and consider process optimization or data compression strategies.';
            insight.color = '#fbbf24';
        }
        
        return insight;
    }
    
    generatePartnerConcentrationInsight(tpData) {
        if (!tpData) return null;
        
        const tpAnalysis = this.analyzeTPData(tpData);
        const sortedTPs = Object.entries(tpAnalysis.tp_totals || {})
            .sort((a, b) => b[1].total_docs - a[1].total_docs);
        
        if (sortedTPs.length === 0) return null;
        
        const totalDocs = sortedTPs.reduce((sum, [, tp]) => sum + tp.total_docs, 0);
        const topPartnerDocs = sortedTPs[0][1].total_docs;
        const topPartnerShare = (topPartnerDocs / totalDocs) * 100;
        const topPartnerId = sortedTPs[0][0];
        
        // Calculate how many partners make up 80% of volume
        let cumulative = 0;
        let partners80 = 0;
        for (const [, tp] of sortedTPs) {
            cumulative += tp.total_docs;
            partners80++;
            if (cumulative >= totalDocs * 0.8) break;
        }
        
        let insight = {
            priority: 0,
            icon: '',
            title: '',
            message: '',
            recommendation: '',
            color: '#ffffff'
        };
        
        if (topPartnerShare > 50) {
            insight.priority = 9;
            insight.icon = '🎯';
            insight.title = 'High Partner Concentration Risk';
            insight.message = `Your top partner (${topPartnerId}) accounts for ${topPartnerShare.toFixed(1)}% of total volume. Only ${partners80} partners drive 80% of your business.`;
            insight.recommendation = 'Diversify your partner base to reduce dependency risk and explore new partnership opportunities.';
            insight.color = '#ef4444';
        } else if (topPartnerShare > 30) {
            insight.priority = 6;
            insight.icon = '⚖️';
            insight.title = 'Moderate Partner Concentration';
            insight.message = `Top partner represents ${topPartnerShare.toFixed(1)}% of volume. ${partners80} partners account for 80% of business.`;
            insight.recommendation = 'Monitor concentration levels and continue developing secondary partnerships.';
            insight.color = '#fbbf24';
        } else {
            insight.priority = 5;
            insight.icon = '🌐';
            insight.title = 'Well-Diversified Partner Base';
            insight.message = `Healthy partner distribution with top partner at ${topPartnerShare.toFixed(1)}% of volume. ${partners80} partners contribute to 80% of business.`;
            insight.recommendation = 'Maintain this diversification while focusing on growing key partnerships.';
            insight.color = '#10b981';
        }
        
        return insight;
    }
    
    generateSeasonalityInsight(data, sortedPeriods) {
        // Calculate seasonality
        const monthlyVolumes = {};
        const monthCounts = {};
        
        if (data.trends && data.trends['Date_Summary']) {
            const trends = data.trends['Date_Summary'];
            if (trends.periods && trends.metric_trends && trends.metric_trends['TOTAL-DOC']) {
                const docTrend = trends.metric_trends['TOTAL-DOC'];
                trends.periods.forEach((period, idx) => {
                    const month = period.split('-')[1];
                    if (!monthlyVolumes[month]) {
                        monthlyVolumes[month] = 0;
                        monthCounts[month] = 0;
                    }
                    monthlyVolumes[month] += docTrend[idx] || 0;
                    monthCounts[month]++;
                });
            }
        }
        
        // Calculate monthly averages
        const monthlyAverages = {};
        Object.keys(monthlyVolumes).forEach(month => {
            if (monthCounts[month] > 0) {
                monthlyAverages[month] = monthlyVolumes[month] / monthCounts[month];
            }
        });
        
        const values = Object.values(monthlyAverages);
        if (values.length < 6) return null; // Not enough data for seasonality
        
        const overallAverage = values.reduce((a, b) => a + b, 0) / values.length;
        
        // Find months with significant variation
        const strongMonths = [];
        const weakMonths = [];
        
        Object.entries(monthlyAverages).forEach(([month, avg]) => {
            const variation = ((avg - overallAverage) / overallAverage) * 100;
            if (variation > 15) {
                strongMonths.push({ month, variation });
            } else if (variation < -15) {
                weakMonths.push({ month, variation });
            }
        });
        
        if (strongMonths.length === 0 && weakMonths.length === 0) return null;
        
        const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
        
        let insight = {
            priority: 6,
            icon: '📊',
            title: 'Seasonal Patterns Detected',
            message: '',
            recommendation: '',
            color: '#fbbf24'
        };
        
        if (strongMonths.length > 0) {
            const topMonth = strongMonths.sort((a, b) => b.variation - a.variation)[0];
            const monthName = monthNames[parseInt(topMonth.month) - 1];
            insight.message = `Strong seasonal peaks in ${monthName} with ${topMonth.variation.toFixed(1)}% above average volume. `;
        }
        
        if (weakMonths.length > 0) {
            const bottomMonth = weakMonths.sort((a, b) => a.variation - b.variation)[0];
            const monthName = monthNames[parseInt(bottomMonth.month) - 1];
            insight.message += `Lowest activity in ${monthName} at ${Math.abs(bottomMonth.variation).toFixed(1)}% below average.`;
        }
        
        insight.recommendation = 'Plan resource allocation and capacity based on these seasonal patterns.';
        
        return insight;
    }
    
    generateTrendInsight(docInsights, sortedPeriods) {
        if (sortedPeriods.length < 6) return null;
        
        const recentGrowth = docInsights.growth_rate;
        const avgGrowth = docInsights.avg_growth_rate;
        const volatility = this.calculateVolatility(sortedPeriods, docInsights);
        
        let insight = {
            priority: 0,
            icon: '',
            title: '',
            message: '',
            recommendation: '',
            color: '#ffffff'
        };
        
        if (Math.abs(recentGrowth - avgGrowth) > 10 && recentGrowth > avgGrowth) {
            insight.priority = 7;
            insight.icon = '📊';
            insight.title = 'Accelerating Growth Trend';
            insight.message = `Recent growth of ${recentGrowth.toFixed(1)}% significantly exceeds your ${sortedPeriods.length}-month average of ${avgGrowth.toFixed(1)}%.`;
            insight.recommendation = 'Investigate drivers of acceleration and ensure sustainable growth practices.';
            insight.color = '#10b981';
        } else if (Math.abs(recentGrowth - avgGrowth) > 10 && recentGrowth < avgGrowth) {
            insight.priority = 8;
            insight.icon = '📉';
            insight.title = 'Slowing Growth Trend';
            insight.message = `Recent growth of ${recentGrowth.toFixed(1)}% is below your historical average of ${avgGrowth.toFixed(1)}%.`;
            insight.recommendation = 'Analyze recent changes and implement strategies to restore growth momentum.';
            insight.color = '#ef4444';
        } else if (volatility > 30) {
            insight.priority = 5;
            insight.icon = '🎢';
            insight.title = 'High Volume Volatility';
            insight.message = `Your business shows ${volatility.toFixed(1)}% volatility in monthly volumes, indicating unpredictable patterns.`;
            insight.recommendation = 'Focus on stabilizing operations and improving demand forecasting.';
            insight.color = '#fbbf24';
        } else {
            return null; // No significant trend insight
        }
        
        return insight;
    }
    
    calculateVolatility(sortedPeriods, docInsights) {
        // Simple volatility calculation based on standard deviation of growth rates
        if (!docInsights.growth_rates || docInsights.growth_rates.length < 3) {
            return 20; // Default moderate volatility
        }
        
        const rates = docInsights.growth_rates;
        const mean = rates.reduce((a, b) => a + b, 0) / rates.length;
        const squaredDiffs = rates.map(rate => Math.pow(rate - mean, 2));
        const variance = squaredDiffs.reduce((a, b) => a + b, 0) / rates.length;
        const stdDev = Math.sqrt(variance);
        
        return stdDev;
    }
    
    analyzeTPData(tpData) {
        const analysis = {
            tp_totals: {},
            top_partner_percentage: 0
        };
        
        // Aggregate TP data
        Object.entries(tpData).forEach(([period, tps]) => {
            Object.entries(tps).forEach(([tpId, metrics]) => {
                if (!analysis.tp_totals[tpId]) {
                    analysis.tp_totals[tpId] = {
                        total_docs: 0,
                        total_kcs: 0
                    };
                }
                
                // Sum up documents and KCs
                Object.entries(metrics).forEach(([key, value]) => {
                    if (key.includes('DOC') && !key.includes('KCS')) {
                        analysis.tp_totals[tpId].total_docs += value || 0;
                    } else if (key.includes('KCS')) {
                        analysis.tp_totals[tpId].total_kcs += value || 0;
                    }
                });
            });
        });
        
        // Calculate top partner percentage
        const sortedTPs = Object.entries(analysis.tp_totals)
            .sort((a, b) => b[1].total_docs - a[1].total_docs);
        
        if (sortedTPs.length > 0) {
            const totalDocs = sortedTPs.reduce((sum, [, tp]) => sum + tp.total_docs, 0);
            if (totalDocs > 0) {
                analysis.top_partner_percentage = (sortedTPs[0][1].total_docs / totalDocs) * 100;
            }
        }
        
        return analysis;
    }
    
    generateVolumeTrendCharts(data, sortedPeriods) {
        // Create chart configurations
        const chartConfigs = [];
        
        // Prepare data for charts
        const docData = this.prepareChartData(data, sortedPeriods, 'TOTAL-DOC');
        const kcData = this.prepareChartData(data, sortedPeriods, 'TOTAL-KCS');
        
        // Stringify and escape the data
        const docDataStr = JSON.stringify(docData).replace(/</g, '\\u003c');
        const kcDataStr = JSON.stringify(kcData).replace(/</g, '\\u003c');
        
        // Add chart configurations to global scope
        const chartScript = `
        <scr` + `ipt>
            window.chartConfigs = [
                {
                    id: 'docVolumeChart',
                    config: {
                        type: 'line',
                        data: ${docDataStr},
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    position: 'bottom'
                                },
                                title: {
                                    display: true,
                                    text: 'Document Volume Trend'
                                }
                            },
                            scales: {
                                y: {
                                    beginAtZero: true
                                }
                            }
                        }
                    }
                },
                {
                    id: 'kcVolumeChart',
                    config: {
                        type: 'line',
                        data: ${kcDataStr},
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    position: 'bottom'
                                },
                                title: {
                                    display: true,
                                    text: 'KC Volume Trend'
                                }
                            },
                            scales: {
                                y: {
                                    beginAtZero: true
                                }
                            }
                        }
                    }
                }
            ];
        <\/script>`;
        
        return `
        <div style="margin-top: 30px;">
            <h4>📈 Volume Trends
                <span class="info-icon">i
                    <div class="tooltip">
                        Volume Trends display historical document and KC volumes over time.
                        The charts show monthly data points with trend lines.
                        Use these charts to identify seasonal patterns, growth trends, and anomalies.
                        Data is sourced from your Date_Summary sheets across all periods.
                    </div>
                </span>
            </h4>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 20px;">
                <div style="background: white; padding: 20px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.05);">
                    <div style="position: relative; height: 300px;">
                        <canvas id="docVolumeChart"></canvas>
                    </div>
                </div>
                <div style="background: white; padding: 20px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.05);">
                    <div style="position: relative; height: 300px;">
                        <canvas id="kcVolumeChart"></canvas>
                    </div>
                </div>
            </div>
        </div>
        ${chartScript}`;
    }
    
    prepareChartData(data, sortedPeriods, metric) {
        const datasets = [];
        const colors = ['#3b82f6', '#10b981', '#f59e0b', '#ef4444', '#8b5cf6'];
        
        // Only get data for Date_Summary sheet
        if (data.trends && data.trends['Date_Summary']) {
            const trends = data.trends['Date_Summary'];
            if (trends.metric_trends && trends.metric_trends[metric]) {
                const values = [];
                for (const period of sortedPeriods) {
                    const idx = trends.periods.indexOf(period);
                    values.push(idx >= 0 ? trends.metric_trends[metric][idx] : 0);
                }
                
                // Rename label based on metric type
                const label = metric === 'TOTAL-DOC' ? 'Documents' : 
                             metric === 'TOTAL-KCS' ? 'Kilocharacters' : 'Date_Summary';
                
                datasets.push({
                    label: label,
                    data: values,
                    borderColor: colors[0],
                    backgroundColor: colors[0] + '33',
                    tension: 0.1
                });
            }
        }
        
        return {
            labels: sortedPeriods.map(p => this.formatPeriodDisplay(p)),
            datasets: datasets
        };
    }
    
    generateOverviewSeasonalityPattern(data, sortedPeriods) {
        // Calculate seasonality based on document volumes
        const monthlyVolumes = {};
        const monthCounts = {};
        const yearlyData = {};
        const availableYears = new Set();
        
        // Aggregate volumes by month and year
        if (data.trends && data.trends['Date_Summary']) {
            const trends = data.trends['Date_Summary'];
            if (trends.periods && trends.metric_trends && trends.metric_trends['TOTAL-DOC']) {
                const docTrend = trends.metric_trends['TOTAL-DOC'];
                trends.periods.forEach((period, idx) => {
                    const [year, month] = period.split('-');
                    availableYears.add(year);
                    
                    // Overall aggregation
                    if (!monthlyVolumes[month]) {
                        monthlyVolumes[month] = 0;
                        monthCounts[month] = 0;
                    }
                    monthlyVolumes[month] += docTrend[idx] || 0;
                    monthCounts[month]++;
                    
                    // Year-specific aggregation
                    if (!yearlyData[year]) {
                        yearlyData[year] = {
                            monthlyVolumes: {},
                            monthCounts: {}
                        };
                    }
                    if (!yearlyData[year].monthlyVolumes[month]) {
                        yearlyData[year].monthlyVolumes[month] = 0;
                        yearlyData[year].monthCounts[month] = 0;
                    }
                    yearlyData[year].monthlyVolumes[month] += docTrend[idx] || 0;
                    yearlyData[year].monthCounts[month]++;
                });
            }
        }
        
        // Calculate averages for all years combined
        const monthlyAverages = {};
        Object.keys(monthlyVolumes).forEach(month => {
            if (monthCounts[month] > 0) {
                monthlyAverages[month] = monthlyVolumes[month] / monthCounts[month];
            }
        });
        
        const values = Object.values(monthlyAverages);
        const overallAverage = values.length > 0 ? values.reduce((a, b) => a + b, 0) / values.length : 0;
        
        // Calculate seasonality factors for all years
        const seasonalityFactors = {};
        Object.keys(monthlyAverages).forEach(month => {
            seasonalityFactors[month] = ((monthlyAverages[month] - overallAverage) / overallAverage * 100).toFixed(1);
        });
        
        // Calculate year-specific seasonality factors
        const yearlySeasonalityFactors = {};
        Object.keys(yearlyData).forEach(year => {
            const yearMonthlyAverages = {};
            Object.keys(yearlyData[year].monthlyVolumes).forEach(month => {
                if (yearlyData[year].monthCounts[month] > 0) {
                    yearMonthlyAverages[month] = yearlyData[year].monthlyVolumes[month] / yearlyData[year].monthCounts[month];
                }
            });
            
            const yearValues = Object.values(yearMonthlyAverages);
            const yearOverallAverage = yearValues.length > 0 ? yearValues.reduce((a, b) => a + b, 0) / yearValues.length : 0;
            
            yearlySeasonalityFactors[year] = {
                factors: {},
                average: yearOverallAverage
            };
            
            Object.keys(yearMonthlyAverages).forEach(month => {
                yearlySeasonalityFactors[year].factors[month] = ((yearMonthlyAverages[month] - yearOverallAverage) / yearOverallAverage * 100).toFixed(1);
            });
        });
        
        const yearArray = Array.from(availableYears).sort();
        const showYearFilter = yearArray.length > 1;
        
        let html = `
        <div style="margin-top: 30px;">
            <h4>🌊 Seasonality Pattern
                <span class="info-icon">i
                    <div class="tooltip">
                        The Seasonality Pattern shows how document volumes vary by month throughout the year.
                        Each month is displayed in a circular pattern with color-coded indicators showing whether it's above or below average.
                        ${showYearFilter ? 'When multiple years are present, you can filter by specific years or view all years combined.' : ''}
                        Use this to identify seasonal trends and plan for peak or low-activity periods.
                    </div>
                </span>
            </h4>
            <div style="background: white; padding: 20px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.05); margin-top: 20px;">
                ${showYearFilter ? `
                <div style="margin-bottom: 20px;">
                    <label style="font-weight: 500; color: #374151; margin-right: 10px;">Year Filter:</label>
                    <select id="seasonalityYearFilter" onchange="updateSeasonalityDisplay()" style="
                        padding: 8px 12px;
                        border: 1px solid #d1d5db;
                        border-radius: 6px;
                        background: white;
                        color: #374151;
                        font-size: 0.9em;
                        cursor: pointer;">
                        <option value="all">All Years Combined</option>
                        ${yearArray.map(year => '<option value="' + year + '">' + year + '</option>').join('')}
                    </select>
                </div>
                ` : ''}
                <div id="overviewSeasonalityAnalysis" style="min-height: 400px;">
                    <!-- Will be populated by script -->
                </div>
            </div>
        </div>`;
        
        // Add the script to populate the seasonality display
        html += '<scr' + 'ipt>' + `
        // Store data globally for filter updates
        try {
            window.seasonalityData = {
                all: {
                    factors: ${JSON.stringify(seasonalityFactors).replace(/</g, '\\u003c')},
                    average: ${isNaN(overallAverage) ? 0 : overallAverage}
                },
                yearly: ${JSON.stringify(yearlySeasonalityFactors).replace(/</g, '\\u003c')}
            };
        } catch (e) {
            console.error('Error setting seasonality data:', e);
        }
        
        function updateSeasonalityDisplay() {
            const seasonalityDiv = document.getElementById('overviewSeasonalityAnalysis');
            const yearFilter = document.getElementById('seasonalityYearFilter');
            const selectedYear = yearFilter ? yearFilter.value : 'all';
            
            if (seasonalityDiv && window.seasonalityData) {
                const months = ['01', '02', '03', '04', '05', '06', '07', '08', '09', '10', '11', '12'];
                const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                
                // Get data for selected year
                let currentFactors, currentAverage;
                if (selectedYear === 'all') {
                    currentFactors = window.seasonalityData.all.factors;
                    currentAverage = window.seasonalityData.all.average;
                } else {
                    currentFactors = window.seasonalityData.yearly[selectedYear].factors;
                    currentAverage = window.seasonalityData.yearly[selectedYear].average;
                }
                
                // Create a more visual heatmap-style display
                let seasonalHTML = '<div style="padding: 10px;">';
                
                // Title and legend
                seasonalHTML += '<div style="margin-bottom: 10px;">';
                seasonalHTML += '<div style="display: flex; flex-direction: column; gap: 8px;">';
                seasonalHTML += '<span style="font-weight: 600; color: #374151; font-size: 0.95em;">Monthly Variation from Average' + 
                    (selectedYear !== 'all' ? ' (' + selectedYear + ')' : '') + '</span>';
                seasonalHTML += '<div style="display: flex; flex-wrap: wrap; align-items: center; gap: 12px; font-size: 0.75em;">';
                seasonalHTML += '<span style="display: flex; align-items: center; gap: 4px;"><span style="width: 16px; height: 10px; background: #10b981; border-radius: 2px;"></span>Above Avg</span>';
                seasonalHTML += '<span style="display: flex; align-items: center; gap: 4px;"><span style="width: 16px; height: 10px; background: #6b7280; border-radius: 2px;"></span>Average</span>';
                seasonalHTML += '<span style="display: flex; align-items: center; gap: 4px;"><span style="width: 16px; height: 10px; background: #ef4444; border-radius: 2px;"></span>Below Avg</span>';
                seasonalHTML += '</div></div></div>';
                
                // Create circular month display with responsive sizing
                seasonalHTML += '<div style="position: relative; width: 240px; height: 240px; margin: 0 auto;">';
                
                // Draw center circle with average
                seasonalHTML += '<div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; background: #f9fafb; border-radius: 50%; width: 80px; height: 80px; display: flex; flex-direction: column; justify-content: center; align-items: center; box-shadow: 0 0 0 2px #e5e7eb;">';
                seasonalHTML += '<div style="font-size: 0.7em; color: #6b7280;">Average</div>';
                seasonalHTML += '<div style="font-size: 1em; font-weight: bold; color: #374151;">' + Math.round(currentAverage) + '</div>';
                seasonalHTML += '<div style="font-size: 0.65em; color: #6b7280;">docs/mo</div>';
                seasonalHTML += '</div>';
                
                // Draw months in a circle
                months.forEach((month, index) => {
                    const factor = parseFloat(currentFactors[month] || 0);
                    const angle = (index * 30 - 90) * Math.PI / 180; // Start from top
                    const radius = 95; // Reduced from 120
                    const x = 120 + radius * Math.cos(angle); // Center at 120 (half of 240)
                    const y = 120 + radius * Math.sin(angle); // Center at 120 (half of 240)
                    
                    // Determine color and intensity
                    let bgColor, textColor;
                    const absFactor = Math.abs(factor);
                    if (factor > 0) {
                        if (absFactor > 20) {
                            bgColor = '#065f46';
                            textColor = '#ffffff';
                        } else if (absFactor > 10) {
                            bgColor = '#10b981';
                            textColor = '#ffffff';
                        } else {
                            bgColor = '#86efac';
                            textColor = '#065f46';
                        }
                    } else if (factor < 0) {
                        if (absFactor > 20) {
                            bgColor = '#991b1b';
                            textColor = '#ffffff';
                        } else if (absFactor > 10) {
                            bgColor = '#ef4444';
                            textColor = '#ffffff';
                        } else {
                            bgColor = '#fca5a5';
                            textColor = '#991b1b';
                        }
                    } else {
                        bgColor = '#e5e7eb';
                        textColor = '#374151';
                    }
                    
                    seasonalHTML += '<div style="position: absolute; left: ' + x + 'px; top: ' + y + 'px; transform: translate(-50%, -50%);">' +
                        '<div style="width: 42px; height: 42px; border-radius: 50%; background: ' + bgColor + '; ' +
                        'display: flex; flex-direction: column; justify-content: center; align-items: center;' +
                        'box-shadow: 0 2px 4px rgba(0,0,0,0.1); cursor: pointer; transition: all 0.2s;"' +
                        ' onmouseover="this.style.transform=&apos;scale(1.15)&apos;; this.style.zIndex=&apos;10&apos;;"' +
                        ' onmouseout="this.style.transform=&apos;scale(1)&apos;; this.style.zIndex=&apos;1&apos;;">' +
                        '<div style="font-size: 0.7em; font-weight: 600; color: ' + textColor + ';">' + monthNames[index] + '</div>' +
                        '<div style="font-size: 0.6em; color: ' + textColor + ';">' + (factor > 0 ? '+' : '') + factor + '%</div>' +
                        '</div>' +
                        '</div>';
                });
                
                seasonalHTML += '</div>';
                
                // Analysis summary
                seasonalHTML += '<div style="margin-top: 15px; padding: 12px; background: #f9fafb; border-radius: 8px;">';
                seasonalHTML += '<h6 style="margin: 0 0 8px 0; color: #374151; font-size: 0.85em;">Seasonality Analysis</h6>';
                
                const seasonalityData = Object.entries(currentFactors)
                    .map(([m, f]) => ({ month: monthNames[parseInt(m) - 1], factor: parseFloat(f) }))
                    .sort((a, b) => b.factor - a.factor);
                
                const strongPatterns = seasonalityData.filter(d => Math.abs(d.factor) > 15);
                const moderatePatterns = seasonalityData.filter(d => Math.abs(d.factor) > 5 && Math.abs(d.factor) <= 15);
                
                if (strongPatterns.length > 0) {
                    seasonalHTML += '<div style="margin-bottom: 6px; font-size: 0.8em;">';
                    seasonalHTML += '<span style="color: #374151; font-weight: 600;">Strong Patterns:</span> ';
                    strongPatterns.forEach((p, i) => {
                        const isHigh = p.factor > 0;
                        seasonalHTML += '<span style="color: ' + (isHigh ? '#065f46' : '#991b1b') + '; font-weight: 500;">' + p.month + ' (' + (isHigh ? '+' : '') + p.factor.toFixed(1) + '%)</span>';
                        if (i < strongPatterns.length - 1) seasonalHTML += ', ';
                    });
                    seasonalHTML += '</div>';
                }
                
                if (moderatePatterns.length > 0) {
                    seasonalHTML += '<div style="margin-bottom: 6px; font-size: 0.8em;">';
                    seasonalHTML += '<span style="color: #374151; font-weight: 600;">Moderate Patterns:</span> ';
                    moderatePatterns.forEach((p, i) => {
                        const isHigh = p.factor > 0;
                        seasonalHTML += '<span style="color: ' + (isHigh ? '#10b981' : '#ef4444') + ';">' + p.month + ' (' + (isHigh ? '+' : '') + p.factor.toFixed(1) + '%)</span>';
                        if (i < moderatePatterns.length - 1) seasonalHTML += ', ';
                    });
                    seasonalHTML += '</div>';
                }
                
                // Overall seasonality score
                const seasonalityScore = Math.sqrt(seasonalityData.reduce((sum, d) => sum + d.factor * d.factor, 0) / seasonalityData.length);
                seasonalHTML += '<div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #e5e7eb; font-size: 0.8em;">';
                seasonalHTML += '<span style="color: #6b7280;">Seasonality Strength: </span>' +
                                 '<span style="font-weight: 600; color: ' + (seasonalityScore < 10 ? '#10b981' : seasonalityScore < 20 ? '#f59e0b' : '#ef4444') + ';">' +
                                    (seasonalityScore < 10 ? 'Low' : seasonalityScore < 20 ? 'Moderate' : 'High') + 
                                    ' (' + seasonalityScore.toFixed(1) + '% variation)' +
                                 '</span>';
                seasonalHTML += '</div>';
                
                seasonalHTML += '</div></div>';
                seasonalityDiv.innerHTML = seasonalHTML;
            }
        }
        
        // Initialize the display
        setTimeout(() => {
            updateSeasonalityDisplay();
        }, 100);` +
        '</scr' + 'ipt>';
        
        return html;
    }
    
    generateComparativeAnalysis(data, sortedPeriods) {
        if (sortedPeriods.length < 2) {
            return "";
        }
        
        // Get last 3 months, 3 months ago, and 12 months ago
        const current3mo = sortedPeriods.slice(-3);
        const prev3mo = sortedPeriods.length >= 6 ? sortedPeriods.slice(-6, -3) : [];
        const yearAgo3mo = sortedPeriods.length >= 15 ? sortedPeriods.slice(-15, -12) : [];
        
        // Format period displays for clarity
        const formatRange = (periods) => {
            if (!periods || periods.length === 0) return "N/A";
            const displays = periods.map(p => this.formatPeriodDisplay(p));
            return `${displays[0]} - ${displays[displays.length - 1]}`;
        };
        
        const currentRange = formatRange(current3mo);
        const prevRange = formatRange(prev3mo);
        const yearAgoRange = formatRange(yearAgo3mo);
        
        let html = `
        <div style="margin-bottom: 30px;">
            <h4 style="color: #2d3748;">📊 Comparative Analysis
                <span class="info-icon">i
                    <div class="tooltip">
                        Comparative Analysis shows side-by-side metrics for documents and kilocharacters.
                        It compares current period performance against historical averages.
                        Percentage differences help identify significant changes in processing patterns.
                        Use this to spot trends and make data-driven decisions.
                    </div>
                </span>
            </h4>
            <p style="color: #64748b; margin: 10px 0 15px 0; font-size: 0.9em;">
                This analysis compares 3-month totals across different time periods to show quarterly trends. 
                QoQ (Quarter-over-Quarter) compares the most recent 3 months to the previous 3 months, 
                while YoY (Year-over-Year) compares to the same 3-month period from last year.
            </p>
            <table class="monthly-table">
                <thead>
                    <tr>
                        <th>Metric</th>
                        <th>Last 3 Months<br><span style="font-size: 0.85em; color: #64748b;">${currentRange}</span></th>
                        <th>Previous 3 Months<br><span style="font-size: 0.85em; color: #64748b;">${prevRange}</span></th>
                        <th>Year Ago (3mo)<br><span style="font-size: 0.85em; color: #64748b;">${yearAgoRange}</span></th>
                        <th>QoQ Change</th>
                        <th>YoY Change</th>
                    </tr>
                </thead>
                <tbody>`;
        
        // Calculate totals for each period
        const metrics = ['TOTAL-DOC', 'TOTAL-KCS'];
        for (const metric of metrics) {
            const currentTotal = this.calculatePeriodTotal(data, current3mo, metric);
            const prevTotal = this.calculatePeriodTotal(data, prev3mo, metric);
            const yoyTotal = this.calculatePeriodTotal(data, yearAgo3mo, metric);
            
            const qoqChange = prevTotal > 0 ? ((currentTotal - prevTotal) / prevTotal * 100) : 0;
            const yoyChange = yoyTotal > 0 ? ((currentTotal - yoyTotal) / yoyTotal * 100) : 0;
            
            const metricLabel = metric === 'TOTAL-DOC' ? 'Documents' : 'KCs';
            
            html += `
                <tr>
                    <td><strong>${metricLabel}</strong></td>
                    <td>${currentTotal.toLocaleString()}</td>
                    <td>${prevTotal.toLocaleString()}</td>
                    <td>${yoyTotal.toLocaleString()}</td>
                    <td class="${qoqChange > 0 ? 'change-positive' : qoqChange < 0 ? 'change-negative' : ''}">${qoqChange >= 0 ? '+' : ''}${qoqChange.toFixed(1)}%</td>
                    <td class="${yoyChange > 0 ? 'change-positive' : yoyChange < 0 ? 'change-negative' : ''}">${yoyChange >= 0 ? '+' : ''}${yoyChange.toFixed(1)}%</td>
                </tr>`;
        }
        
        html += `
                </tbody>
            </table>
        </div>`;
        return html;
    }
    
    generateTrendInsights(data, sortedPeriods) {
        const insights = [];
        
        // Analyze document volume trends
        if (data.trends && data.trends.Date_Summary && data.trends.Date_Summary.metric_trends) {
            const docTrend = data.trends.Date_Summary.metric_trends['TOTAL-DOC'] || [];
            const kcTrend = data.trends.Date_Summary.metric_trends['TOTAL-KCS'] || [];
            
            if (docTrend.length >= 3) {
                // Check for consistent growth or decline
                let consecutiveGrowth = 0;
                let consecutiveDecline = 0;
                
                for (let i = 1; i < docTrend.length; i++) {
                    if (docTrend[i] > docTrend[i-1]) {
                        consecutiveGrowth++;
                        consecutiveDecline = 0;
                    } else if (docTrend[i] < docTrend[i-1]) {
                        consecutiveDecline++;
                        consecutiveGrowth = 0;
                    } else {
                        consecutiveGrowth = 0;
                        consecutiveDecline = 0;
                    }
                    
                    if (consecutiveGrowth >= 3) {
                        insights.push({
                            type: 'growth',
                            message: `Document volume has shown consistent growth for ${consecutiveGrowth + 1} consecutive months`,
                            importance: 'high'
                        });
                    } else if (consecutiveDecline >= 3) {
                        insights.push({
                            type: 'decline',
                            message: `Document volume has declined for ${consecutiveDecline + 1} consecutive months`,
                            importance: 'high'
                        });
                    }
                }
                
                // Check for volatility
                const changes = [];
                for (let i = 1; i < docTrend.length; i++) {
                    if (docTrend[i-1] > 0) {
                        changes.push(Math.abs((docTrend[i] - docTrend[i-1]) / docTrend[i-1] * 100));
                    }
                }
                
                const avgChange = changes.length > 0 ? changes.reduce((a, b) => a + b, 0) / changes.length : 0;
                if (avgChange > 15) {
                    insights.push({
                        type: 'volatility',
                        message: `Document volume shows high volatility with average monthly change of ${avgChange.toFixed(1)}%`,
                        importance: 'medium'
                    });
                }
                
                // Check seasonality
                if (docTrend.length >= 12) {
                    const monthlyAverages = [];
                    for (let month = 0; month < 12; month++) {
                        const values = [];
                        for (let i = month; i < docTrend.length; i += 12) {
                            values.push(docTrend[i]);
                        }
                        if (values.length > 0) {
                            monthlyAverages.push(values.reduce((a, b) => a + b, 0) / values.length);
                        }
                    }
                    
                    const maxMonth = Math.max(...monthlyAverages);
                    const minMonth = Math.min(...monthlyAverages);
                    if ((maxMonth - minMonth) / minMonth > 0.3) {
                        insights.push({
                            type: 'seasonality',
                            message: 'Data shows potential seasonal patterns with significant variation between months',
                            importance: 'medium'
                        });
                    }
                }
            }
        }
        
        if (insights.length === 0) {
            insights.push({
                type: 'stable',
                message: 'Document processing volumes have remained relatively stable',
                importance: 'low'
            });
        }
        
        let html = `
        <div style="margin-bottom: 30px;">
            <h4 style="color: #2d3748;">💡 Trend Insights
                <span class="info-icon">i
                    <div class="tooltip">
                        Trend Insights provide AI-generated analysis of your data patterns.
                        The insights identify key trends, anomalies, and recommendations.
                        Analysis considers volume changes, efficiency metrics, and growth patterns.
                        Use these insights to understand business performance and plan improvements.
                    </div>
                </span>
            </h4>
            <div style="display: grid; gap: 15px;">`;
        
        for (const insight of insights.slice(0, 5)) {
            const bgColor = insight.type === 'growth' ? '#d1fae5' : 
                           insight.type === 'decline' ? '#fee2e2' : 
                           insight.type === 'volatility' ? '#fef3c7' : '#e0e7ff';
            const iconColor = insight.type === 'growth' ? '#059669' : 
                             insight.type === 'decline' ? '#dc2626' : 
                             insight.type === 'volatility' ? '#d97706' : '#4f46e5';
            const icon = insight.type === 'growth' ? '📈' : 
                        insight.type === 'decline' ? '📉' : 
                        insight.type === 'volatility' ? '⚡' : '📊';
            
            html += `
                <div style="background: ${bgColor}; padding: 15px 20px; border-radius: 8px; border-left: 4px solid ${iconColor};">
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <span style="font-size: 1.5em;">${icon}</span>
                        <p style="margin: 0; color: #1f2937; font-weight: 500;">${insight.message}</p>
                    </div>
                </div>`;
        }
        
        html += `
            </div>
        </div>`;
        return html;
    }
    
    generateMoMDashboard(data, sortedPeriods) {
        if (sortedPeriods.length < 2) {
            return '';
        }
        
        const currentPeriod = sortedPeriods[sortedPeriods.length - 1];
        const prevPeriod = sortedPeriods[sortedPeriods.length - 2];
        
        // Get metrics for current and previous periods
        let currentDocs = 0, prevDocs = 0, currentKCs = 0, prevKCs = 0;
        let currentTPs = 0, prevTPs = 0;
        let avgDocs = 0, avgKCs = 0;
        
        // Extract data from trends and calculate averages
        if (data.trends && data.trends.Date_Summary) {
            const trends = data.trends.Date_Summary;
            if (trends.metric_trends && trends.periods) {
                const currentIdx = trends.periods.indexOf(currentPeriod);
                const prevIdx = trends.periods.indexOf(prevPeriod);
                
                if (currentIdx >= 0) {
                    currentDocs = (trends.metric_trends['TOTAL-DOC'] || [])[currentIdx] || 0;
                    currentKCs = (trends.metric_trends['TOTAL-KCS'] || [])[currentIdx] || 0;
                }
                if (prevIdx >= 0) {
                    prevDocs = (trends.metric_trends['TOTAL-DOC'] || [])[prevIdx] || 0;
                    prevKCs = (trends.metric_trends['TOTAL-KCS'] || [])[prevIdx] || 0;
                }
                
                // Calculate averages across all periods
                const allDocs = trends.metric_trends['TOTAL-DOC'] || [];
                const allKCs = trends.metric_trends['TOTAL-KCS'] || [];
                
                if (allDocs.length > 0) {
                    avgDocs = allDocs.reduce((sum, val) => sum + val, 0) / allDocs.length;
                }
                if (allKCs.length > 0) {
                    avgKCs = allKCs.reduce((sum, val) => sum + val, 0) / allKCs.length;
                }
            }
        }
        
        // Count active TPs
        if (data.tp_data) {
            if (data.tp_data[currentPeriod] && data.tp_data[currentPeriod]['TP_Summary']) {
                currentTPs = data.tp_data[currentPeriod]['TP_Summary'].length || 0;
            }
            if (data.tp_data[prevPeriod] && data.tp_data[prevPeriod]['TP_Summary']) {
                prevTPs = data.tp_data[prevPeriod]['TP_Summary'].length || 0;
            }
        }
        
        // Calculate changes - current period vs average
        const docChange = avgDocs > 0 ? ((currentDocs - avgDocs) / avgDocs * 100) : 0;
        const kcChange = avgKCs > 0 ? ((currentKCs - avgKCs) / avgKCs * 100) : 0;
        const tpChange = prevTPs > 0 ? ((currentTPs - prevTPs) / prevTPs * 100) : 0;
        const currentEfficiency = currentKCs > 0 ? currentDocs / currentKCs : 0;
        const avgEfficiency = avgKCs > 0 ? avgDocs / avgKCs : 0;
        const efficiencyChange = avgEfficiency > 0 ? ((currentEfficiency - avgEfficiency) / avgEfficiency * 100) : 0;
        
        // Get sparkline data for last 6 periods
        const sparklinePeriods = sortedPeriods.slice(-6);
        const docSparkline = [];
        const kcSparkline = [];
        
        if (data.trends && data.trends.Date_Summary) {
            const trends = data.trends.Date_Summary;
            sparklinePeriods.forEach(period => {
                const idx = trends.periods ? trends.periods.indexOf(period) : -1;
                if (idx >= 0) {
                    docSparkline.push((trends.metric_trends['TOTAL-DOC'] || [])[idx] || 0);
                    kcSparkline.push((trends.metric_trends['TOTAL-KCS'] || [])[idx] || 0);
                }
            });
        }
        
        let html = `
        <div style="margin-bottom: 40px;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                <h4 style="color: #2d3748; margin: 0;">📊 Performance Dashboard - ${currentPeriod} vs All-Time Average</h4>
            </div>
            
            <!-- Metric Cards -->
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; margin-bottom: 30px;">
                <!-- Documents Card -->
                <div style="background: linear-gradient(135deg, rgba(147, 197, 253, 0.3) 0%, rgba(96, 165, 250, 0.3) 100%); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); border: 1px solid rgba(147, 197, 253, 0.4); color: #1e40af; padding: 20px; border-radius: 12px; box-shadow: 0 8px 32px rgba(59, 130, 246, 0.1);">
                    <div style="display: flex; justify-content: space-between; align-items: start;">
                        <div>
                            <div style="font-size: 0.9em; opacity: 0.8; margin-bottom: 5px; color: #3730a3;">Average Documents</div>
                            <div style="font-size: 2em; font-weight: bold; margin-bottom: 5px; color: #1e3a8a;">${Math.round(avgDocs).toLocaleString()}</div>
                            <div style="display: flex; align-items: center; gap: 8px;">
                                ${this.getChangeIndicator(docChange)}
                                <span style="font-size: 0.9em; color: #3730a3;">${Math.abs(docChange).toFixed(1)}% vs avg</span>
                            </div>
                            <div style="font-size: 0.75em; opacity: 0.7; margin-top: 4px; color: #3730a3;">Current: ${currentDocs.toLocaleString()}</div>
                        </div>
                        <div style="opacity: 0.8;">
                            ${this.generateSparklineSVG(docSparkline, '#3b82f6')}
                        </div>
                    </div>
                </div>
                
                <!-- KCs Card -->
                <div style="background: linear-gradient(135deg, rgba(167, 243, 208, 0.3) 0%, rgba(110, 231, 183, 0.3) 100%); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); border: 1px solid rgba(167, 243, 208, 0.4); color: #047857; padding: 20px; border-radius: 12px; box-shadow: 0 8px 32px rgba(16, 185, 129, 0.1);">
                    <div style="display: flex; justify-content: space-between; align-items: start;">
                        <div>
                            <div style="font-size: 0.9em; opacity: 0.8; margin-bottom: 5px; color: #065f46;">Average KCs</div>
                            <div style="font-size: 2em; font-weight: bold; margin-bottom: 5px; color: #064e3b;">${Math.round(avgKCs).toLocaleString()}</div>
                            <div style="display: flex; align-items: center; gap: 8px;">
                                ${this.getChangeIndicator(kcChange)}
                                <span style="font-size: 0.9em; color: #065f46;">${Math.abs(kcChange).toFixed(1)}% vs avg</span>
                            </div>
                            <div style="font-size: 0.75em; opacity: 0.7; margin-top: 4px; color: #065f46;">Current: ${currentKCs.toLocaleString()}</div>
                        </div>
                        <div style="opacity: 0.8;">
                            ${this.generateSparklineSVG(kcSparkline, '#10b981')}
                        </div>
                    </div>
                </div>
                
                <!-- Trading Partners Card -->
                <div style="background: linear-gradient(135deg, rgba(221, 214, 254, 0.3) 0%, rgba(196, 181, 253, 0.3) 100%); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); border: 1px solid rgba(221, 214, 254, 0.4); color: #6b21a8; padding: 20px; border-radius: 12px; box-shadow: 0 8px 32px rgba(139, 92, 246, 0.1);">
                    <div style="display: flex; justify-content: space-between; align-items: start;">
                        <div>
                            <div style="font-size: 0.9em; opacity: 0.8; margin-bottom: 5px; color: #581c87;">Active Partners</div>
                            <div style="font-size: 2em; font-weight: bold; margin-bottom: 5px; color: #4c1d95;">${currentTPs}</div>
                            <div style="display: flex; align-items: center; gap: 8px;">
                                ${this.getChangeIndicator(tpChange)}
                                <span style="font-size: 0.9em; color: #581c87;">${Math.abs(tpChange).toFixed(1)}%</span>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Efficiency Card -->
                <div style="background: linear-gradient(135deg, rgba(254, 243, 199, 0.3) 0%, rgba(253, 230, 138, 0.3) 100%); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); border: 1px solid rgba(254, 243, 199, 0.4); color: #b45309; padding: 20px; border-radius: 12px; box-shadow: 0 8px 32px rgba(245, 158, 11, 0.1);">
                    <div style="display: flex; justify-content: space-between; align-items: start;">
                        <div>
                            <div style="font-size: 0.9em; opacity: 0.8; margin-bottom: 5px; color: #92400e;">Average Efficiency</div>
                            <div style="font-size: 2em; font-weight: bold; margin-bottom: 5px; color: #78350f;">${avgEfficiency.toFixed(2)}</div>
                            <div style="display: flex; align-items: center; gap: 8px;">
                                ${this.getChangeIndicator(efficiencyChange)}
                                <span style="font-size: 0.9em; color: #92400e;">${Math.abs(efficiencyChange).toFixed(1)}% vs avg</span>
                            </div>
                            <div style="font-size: 0.75em; opacity: 0.7; margin-top: 4px; color: #92400e;">Current: ${currentEfficiency.toFixed(2)}</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>`;
        
        return html;
    }
    
    getChangeIndicator(change) {
        if (change > 0) {
            return '<span style="color: #059669; font-size: 1.2em; font-weight: 600;">↑</span>';
        } else if (change < 0) {
            return '<span style="color: #dc2626; font-size: 1.2em; font-weight: 600;">↓</span>';
        } else {
            return '<span style="color: #6b7280; font-size: 1.2em; font-weight: 600;">→</span>';
        }
    }
    
    generateInlineSparkline(values) {
        if (!values || values.length < 2) return '';
        
        // Calculate trend
        const lastValue = values[values.length - 1];
        const prevValue = values[values.length - 2];
        const trend = lastValue > prevValue ? '↑' : lastValue < prevValue ? '↓' : '→';
        const trendColor = lastValue > prevValue ? '#10b981' : lastValue < prevValue ? '#ef4444' : '#6b7280';
        
        // Create sparkline characters
        const min = Math.min(...values);
        const max = Math.max(...values);
        const range = max - min || 1;
        
        const sparkline = values.map(value => {
            const normalized = (value - min) / range;
            if (normalized >= 0.75) return '▆';
            if (normalized >= 0.5) return '▅';
            if (normalized >= 0.25) return '▃';
            return '▂';
        }).join('');
        
        return `<span style="font-family: monospace; letter-spacing: -2px;">${sparkline}</span> <span style="color: ${trendColor}; font-weight: bold;">${trend}</span>`;
    }
    
    generateSparklineSVG(data, color) {
        if (!data || data.length < 2) return '';
        
        const width = 80;
        const height = 30;
        const padding = 2;
        
        // Normalize data
        const min = Math.min(...data);
        const max = Math.max(...data);
        const range = max - min || 1;
        
        // Generate path
        const points = data.map((value, index) => {
            const x = padding + (index / (data.length - 1)) * (width - 2 * padding);
            const y = height - padding - ((value - min) / range) * (height - 2 * padding);
            return `${x},${y}`;
        });
        
        const path = `M ${points.join(' L ')}`;
        
        return `<svg width="${width}" height="${height}" viewBox="0 0 ${width} ${height}"><path d="${path}" fill="none" stroke="${color}" stroke-width="2" opacity="0.8"/><circle cx="${padding + (data.length - 1) / (data.length - 1) * (width - 2 * padding)}" cy="${height - padding - ((data[data.length - 1] - min) / range) * (height - 2 * padding)}" r="3" fill="${color}"/></svg>`;
    }
    
    generateBestWorstPerformers(data, currentPeriod, prevPeriod) {
        // Calculate TP performance changes
        const tpChanges = [];
        
        if (data.tp_data && data.tp_data[currentPeriod] && data.tp_data[prevPeriod]) {
            const currentTPData = {};
            const prevTPData = {};
            
            // Collect current period data
            if (data.tp_data[currentPeriod]['TP_Summary']) {
                data.tp_data[currentPeriod]['TP_Summary'].forEach(row => {
                    const tpId = row['TP ID'] || row['TP-ID'] || row['Trading Partner'] || '';
                    if (tpId) {
                        currentTPData[tpId] = parseFloat(row['TOTAL-DOC'] || 0);
                    }
                });
            }
            
            // Collect previous period data
            if (data.tp_data[prevPeriod]['TP_Summary']) {
                data.tp_data[prevPeriod]['TP_Summary'].forEach(row => {
                    const tpId = row['TP ID'] || row['TP-ID'] || row['Trading Partner'] || '';
                    if (tpId) {
                        prevTPData[tpId] = parseFloat(row['TOTAL-DOC'] || 0);
                    }
                });
            }
            
            // Calculate changes
            Object.keys(currentTPData).forEach(tpId => {
                if (prevTPData[tpId] && prevTPData[tpId] > 0) {
                    const change = ((currentTPData[tpId] - prevTPData[tpId]) / prevTPData[tpId] * 100);
                    tpChanges.push({ tpId, change, current: currentTPData[tpId], prev: prevTPData[tpId] });
                }
            });
        }
        
        // Sort and get top/bottom performers
        tpChanges.sort((a, b) => b.change - a.change);
        const topPerformers = tpChanges.slice(0, 3);
        const bottomPerformers = tpChanges.slice(-3).reverse();
        
        return `
        <!-- Best Performers -->
        <div style="background: #f0fdf4; border: 1px solid #86efac; padding: 20px; border-radius: 10px;">
            <h5 style="color: #065f46; margin: 0 0 15px 0;">🌟 Top Performers</h5>
            ${topPerformers.length > 0 ? topPerformers.map(tp => `
                <div style="display: flex; justify-content: space-between; align-items: center; padding: 8px 0; border-bottom: 1px solid #d1fae5;">
                    <span style="font-weight: 500; color: #065f46;">${tp.tpId}</span>
                    <span style="color: #059669; font-weight: 600;">+${tp.change.toFixed(1)}%</span>
                </div>
            `).join('') : '<p style="color: #6b7280; font-size: 0.9em;">No significant gainers</p>'}
        </div>
        
        <!-- Worst Performers -->
        <div style="background: #fef2f2; border: 1px solid #fca5a5; padding: 20px; border-radius: 10px;">
            <h5 style="color: #991b1b; margin: 0 0 15px 0;">📉 Bottom Performers</h5>
            ${bottomPerformers.length > 0 && bottomPerformers[0].change < 0 ? bottomPerformers.map(tp => `
                <div style="display: flex; justify-content: space-between; align-items: center; padding: 8px 0; border-bottom: 1px solid #fee2e2;">
                    <span style="font-weight: 500; color: #991b1b;">${tp.tpId}</span>
                    <span style="color: #dc2626; font-weight: 600;">${tp.change.toFixed(1)}%</span>
                </div>
            `).join('') : '<p style="color: #6b7280; font-size: 0.9em;">No significant decliners</p>'}
        </div>`;
    }
    
    generateConsolidatedTPPerformance(data, periods) {
        // Extract TP monthly data for both docs and KCs
        const tpMonthlyData = {};
        
        if (data.tp_data) {
            for (const period of periods) {
                if (data.tp_data[period] && data.tp_data[period]['TP_Summary']) {
                    for (const row of data.tp_data[period]['TP_Summary']) {
                        let tpId = null;
                        let totalDocs = 0;
                        let totalKcs = 0;
                        
                        for (const [key, value] of Object.entries(row)) {
                            const keyStripped = key.trim();
                            if (['TP ID', 'TP-ID', 'Trading Partner', 'TP_ID', 'TP'].includes(keyStripped)) {
                                tpId = String(value || '').trim();
                            } else if (keyStripped === 'TOTAL-DOC') {
                                totalDocs = parseFloat(value) || 0;
                            } else if (keyStripped === 'TOTAL-KCS') {
                                totalKcs = parseFloat(value) || 0;
                            }
                        }
                        
                        if (tpId) {
                            if (!tpMonthlyData[tpId]) {
                                tpMonthlyData[tpId] = {};
                            }
                            tpMonthlyData[tpId][period] = { docs: totalDocs, kcs: totalKcs };
                        }
                    }
                }
            }
        }
        
        // Calculate totals and sort TPs
        const tpTotals = {};
        for (const [tpId, periods] of Object.entries(tpMonthlyData)) {
            tpTotals[tpId] = {
                totalDocs: Object.values(periods).reduce((sum, p) => sum + p.docs, 0),
                totalKcs: Object.values(periods).reduce((sum, p) => sum + p.kcs, 0)
            };
        }
        
        const sortedTPs = Object.keys(tpTotals).sort((a, b) => tpTotals[b].totalDocs - tpTotals[a].totalDocs);
        
        if (sortedTPs.length === 0) {
            return "";
        }
        
        let html = `
        <div style="margin-bottom: 40px;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                <h4 style="color: #2d3748; margin: 0;">🤝 Trading Partner Monthly Performance
                    <span class="info-icon">i
                        <div class="tooltip">
                            This consolidated table shows both document counts and kilocharacter volumes for each trading partner.
                            Use the toggle buttons to switch between viewing Documents only, KCs only, or Both metrics.
                            Data comes from TP_Summary sheets for each period.
                            Green cells indicate growth, red indicates decline compared to previous month.
                        </div>
                    </span>
                </h4>
                <div style="display: flex; gap: 10px; align-items: center;">
                    <!-- Toggle Buttons -->
                    <div style="background: #f3f4f6; padding: 4px; border-radius: 8px; display: flex; gap: 4px;">
                        <button id="tp-view-docs" onclick="setTPView('docs')" style="
                            padding: 6px 12px;
                            border: none;
                            background: #3b82f6;
                            color: white;
                            border-radius: 6px;
                            cursor: pointer;
                            font-size: 0.85em;
                            transition: all 0.2s;
                        ">Documents</button>
                        <button id="tp-view-kcs" onclick="setTPView('kcs')" style="
                            padding: 6px 12px;
                            border: none;
                            background: transparent;
                            color: #6b7280;
                            border-radius: 6px;
                            cursor: pointer;
                            font-size: 0.85em;
                            transition: all 0.2s;
                        ">KCs</button>
                        <button id="tp-view-both" onclick="setTPView('both')" style="
                            padding: 6px 12px;
                            border: none;
                            background: transparent;
                            color: #6b7280;
                            border-radius: 6px;
                            cursor: pointer;
                            font-size: 0.85em;
                            transition: all 0.2s;
                        ">Both</button>
                    </div>
                    <button onclick="exportTPPerformanceData('json')" style="
                        background: #3182ce;
                        color: white;
                        border: none;
                        padding: 8px 16px;
                        border-radius: 5px;
                        cursor: pointer;
                        font-size: 14px;
                        margin-right: 8px;
                    ">📥 Export JSON</button>
                    <button onclick="exportTPPerformanceData('csv')" style="
                        background: #16a34a;
                        color: white;
                        border: none;
                        padding: 8px 16px;
                        border-radius: 5px;
                        cursor: pointer;
                        font-size: 14px;
                    ">📥 Export CSV</button>
                    
                    <!-- ID Display Filter -->
                    ${window.parent && window.parent.idCrossReference ? `
                    <div style="background: #f3f4f6; padding: 4px; border-radius: 8px; display: flex; gap: 4px; margin-left: auto;">
                        <span style="padding: 6px 8px; color: #4b5563; font-size: 0.85em;">Display:</span>
                        <button onclick="setTPDisplayMode('id', 'tp-performance-table')" 
                            class="display-mode-btn display-mode-id" 
                            data-mode="id"
                            style="
                                padding: 6px 12px;
                                border: none;
                                background: #3b82f6;
                                color: white;
                                border-radius: 6px;
                                cursor: pointer;
                                font-size: 0.85em;
                                transition: all 0.2s;
                            ">ID</button>
                        <button onclick="setTPDisplayMode('name', 'tp-performance-table')" 
                            class="display-mode-btn display-mode-name" 
                            data-mode="name"
                            style="
                                padding: 6px 12px;
                                border: none;
                                background: transparent;
                                color: #6b7280;
                                border-radius: 6px;
                                cursor: pointer;
                                font-size: 0.85em;
                                transition: all 0.2s;
                            ">Name</button>
                        <button onclick="setTPDisplayMode('region', 'tp-performance-table')" 
                            class="display-mode-btn display-mode-region" 
                            data-mode="region"
                            style="
                                padding: 6px 12px;
                                border: none;
                                background: transparent;
                                color: #6b7280;
                                border-radius: 6px;
                                cursor: pointer;
                                font-size: 0.85em;
                                transition: all 0.2s;
                            ">Region</button>
                    </div>
                    ` : ''}
                </div>
            </div>
            
            <!-- Table Container -->
            <div style="overflow-x: auto; max-height: 600px; overflow-y: auto; border: 1px solid #e5e7eb; border-radius: 8px;">
                <table id="tp-performance-table" class="monthly-table" style="font-size: 0.85em;">
                    <thead style="position: sticky; top: 0; z-index: 10; background: white;">
                        <tr>
                            <th style="position: sticky; left: 0; z-index: 11; background: #f7fafc;">Trading Partner</th>
                            ${periods.map(period => `
                                <th class="tp-col-docs" style="text-align: center; background: #f7fafc;">
                                    <div>${this.formatPeriodDisplay(period)}</div>
                                    <div style="font-size: 0.8em; color: #6b7280;">Docs</div>
                                </th>
                                <th class="tp-col-kcs" style="text-align: center; background: #f7fafc; display: none;">
                                    <div>${this.formatPeriodDisplay(period)}</div>
                                    <div style="font-size: 0.8em; color: #6b7280;">KCs</div>
                                </th>
                            `).join('')}
                            <th class="tp-col-docs" style="background: #f7fafc;">Total Docs</th>
                            <th class="tp-col-kcs" style="background: #f7fafc; display: none;">Total KCs</th>
                            <th style="background: #f7fafc;">Trend</th>
                        </tr>
                    </thead>
                    <tbody>`;
        
        // Generate rows for each TP
        sortedTPs.forEach((tpId, index) => {
            const tpData = tpMonthlyData[tpId];
            const docValues = [];
            const kcValues = [];
            let prevDocs = null;
            let prevKcs = null;
            
            html += `<tr style="${index % 2 === 0 ? 'background: #f9fafb;' : ''}">
                <td class="tp-id-cell" data-id="${tpId}" style="font-weight: 600; position: sticky; left: 0; background: ${index % 2 === 0 ? '#f9fafb' : '#ffffff'}; z-index: 5;">${tpId}</td>`;
            
            periods.forEach(period => {
                const value = tpData[period] || { docs: 0, kcs: 0 };
                docValues.push(value.docs);
                kcValues.push(value.kcs);
                
                // Calculate change for color coding
                const docChange = prevDocs !== null && prevDocs > 0 ? ((value.docs - prevDocs) / prevDocs * 100) : 0;
                const kcChange = prevKcs !== null && prevKcs > 0 ? ((value.kcs - prevKcs) / prevKcs * 100) : 0;
                
                const docColor = docChange > 5 ? '#d1fae5' : docChange < -5 ? '#fee2e2' : '';
                const kcColor = kcChange > 5 ? '#d1fae5' : kcChange < -5 ? '#fee2e2' : '';
                
                html += `
                    <td class="tp-col-docs" style="text-align: right; background: ${docColor};">
                        ${value.docs.toLocaleString()}
                    </td>
                    <td class="tp-col-kcs" style="text-align: right; background: ${kcColor}; display: none;">
                        ${value.kcs.toLocaleString()}
                    </td>`;
                
                prevDocs = value.docs;
                prevKcs = value.kcs;
            });
            
            // Add totals
            html += `
                <td class="tp-col-docs" style="font-weight: 600; text-align: right;">${tpTotals[tpId].totalDocs.toLocaleString()}</td>
                <td class="tp-col-kcs" style="font-weight: 600; text-align: right; display: none;">${tpTotals[tpId].totalKcs.toLocaleString()}</td>
                <td style="font-family: monospace; font-size: 0.8em;">${this.generateInlineSparkline(docValues)}</td>
            </tr>`;
        });
        
        html += `</tbody></table></div></div>`;
        
        // Add JavaScript for toggle functionality
        html += `
        <script>
        function setTPView(view) {
            const docsBtn = document.getElementById('tp-view-docs');
            const kcsBtn = document.getElementById('tp-view-kcs');
            const bothBtn = document.getElementById('tp-view-both');
            const docsCols = document.querySelectorAll('.tp-col-docs');
            const kcsCols = document.querySelectorAll('.tp-col-kcs');
            
            // Reset all buttons
            [docsBtn, kcsBtn, bothBtn].forEach(btn => {
                btn.style.background = 'transparent';
                btn.style.color = '#6b7280';
            });
            
            // Show/hide columns based on view
            if (view === 'docs') {
                docsBtn.style.background = '#3b82f6';
                docsBtn.style.color = 'white';
                docsCols.forEach(col => col.style.display = '');
                kcsCols.forEach(col => col.style.display = 'none');
            } else if (view === 'kcs') {
                kcsBtn.style.background = '#10b981';
                kcsBtn.style.color = 'white';
                docsCols.forEach(col => col.style.display = 'none');
                kcsCols.forEach(col => col.style.display = '');
            } else if (view === 'both') {
                bothBtn.style.background = '#8b5cf6';
                bothBtn.style.color = 'white';
                docsCols.forEach(col => col.style.display = '');
                kcsCols.forEach(col => col.style.display = '');
            }
        }
        
        // Export function for TP Performance data
        window.exportTPPerformanceData = function(format) {
            const table = document.getElementById('tp-performance-table');
            if (!table) {
                alert('Table not found');
                return;
            }
            
            // Get current view (docs, kcs, or both)
            const docsBtn = document.getElementById('tp-view-docs');
            const kcsBtn = document.getElementById('tp-view-kcs');
            const bothBtn = document.getElementById('tp-view-both');
            
            let currentView = 'docs';
            if (kcsBtn && kcsBtn.style.background !== 'transparent') {
                currentView = 'kcs';
            } else if (bothBtn && bothBtn.style.background !== 'transparent') {
                currentView = 'both';
            }
            
            // Extract data from table
            const headers = [];
            const rows = [];
            
            // Get headers based on current view
            const headerCells = table.querySelectorAll('thead th');
            headerCells.forEach((cell, index) => {
                const isDocsCol = cell.classList.contains('tp-col-docs');
                const isKcsCol = cell.classList.contains('tp-col-kcs');
                
                if (index === 0) {
                    // Trading Partner column
                    headers.push('Trading Partner');
                } else if (index === headerCells.length - 1) {
                    // Trend column
                    headers.push('Trend');
                } else if (currentView === 'docs' && isDocsCol) {
                    // Check if it's a total column or date column
                    if (cell.textContent.trim() === 'Total Docs') {
                        headers.push('Total Docs');
                    } else {
                        // For date columns, extract just the date part
                        const dateDiv = cell.querySelector('div');
                        const dateText = dateDiv ? dateDiv.textContent.trim() : cell.textContent.trim();
                        headers.push(dateText + ' Docs');
                    }
                } else if (currentView === 'kcs' && isKcsCol) {
                    // Check if it's a total column or date column
                    if (cell.textContent.trim() === 'Total KCs') {
                        headers.push('Total KCs');
                    } else {
                        // For date columns, extract just the date part
                        const dateDiv = cell.querySelector('div');
                        const dateText = dateDiv ? dateDiv.textContent.trim() : cell.textContent.trim();
                        headers.push(dateText + ' KCs');
                    }
                } else if (currentView === 'both' && (isDocsCol || isKcsCol)) {
                    // Check if it's a total column
                    const cellText = cell.textContent.trim();
                    if (cellText === 'Total Docs' || cellText === 'Total KCs') {
                        headers.push(cellText);
                    } else {
                        // For date columns, extract just the date part
                        const dateDiv = cell.querySelector('div');
                        const dateText = dateDiv ? dateDiv.textContent.trim() : cell.textContent.trim();
                        const metric = isDocsCol ? ' Docs' : ' KCs';
                        headers.push(dateText + metric);
                    }
                }
            });
            
            // Get data rows
            const dataRows = table.querySelectorAll('tbody tr');
            dataRows.forEach(row => {
                const rowData = [];
                const cells = row.querySelectorAll('td');
                
                cells.forEach((cell, index) => {
                    const isDocsCol = cell.classList.contains('tp-col-docs');
                    const isKcsCol = cell.classList.contains('tp-col-kcs');
                    
                    if (index === 0 || index === cells.length - 1) {
                        // Always include Trading Partner and Trend columns
                        rowData.push(cell.textContent.trim());
                    } else if (currentView === 'docs' && isDocsCol) {
                        rowData.push(cell.textContent.trim());
                    } else if (currentView === 'kcs' && isKcsCol) {
                        rowData.push(cell.textContent.trim());
                    } else if (currentView === 'both' && (isDocsCol || isKcsCol)) {
                        rowData.push(cell.textContent.trim());
                    }
                });
                
                if (rowData.length > 0) {
                    rows.push(rowData);
                }
            });
            
            let content, filename;
            const timestamp = new Date().toISOString().split('T')[0];
            
            if (format === 'json') {
                // Convert to JSON format
                const jsonData = rows.map(row => {
                    const obj = {};
                    headers.forEach((header, index) => {
                        obj[header] = row[index];
                    });
                    return obj;
                });
                
                content = JSON.stringify(jsonData, null, 2);
                filename = 'tp-performance-' + currentView + '-' + timestamp + '.json';
            } else if (format === 'csv') {
                // Convert to CSV format
                const csvRows = [headers.join(',')];
                rows.forEach(row => {
                    csvRows.push(row.map(cell => {
                        // Escape quotes and wrap in quotes if contains comma
                        const value = cell.replace(/"/g, '""');
                        return value.includes(',') ? '"' + value + '"' : value;
                    }).join(','));
                });
                
                content = csvRows.join('\\n');
                filename = 'tp-performance-' + currentView + '-' + timestamp + '.csv';
            }
            
            // Download file
            const blob = new Blob([content], { type: format === 'json' ? 'application/json' : 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
        };
        
        // ID Display Mode Functions
        window.setTPDisplayMode = function(mode, tableId) {
            const table = document.getElementById(tableId);
            if (!table) return;
            
            // Update button states
            const container = table.closest('div');
            let buttons = container ? container.querySelectorAll('.display-mode-btn') : [];
            
            // If no buttons found in immediate container, search more broadly
            if (buttons.length === 0) {
                const allContainers = document.querySelectorAll('div');
                for (let div of allContainers) {
                    if (div.contains(table)) {
                        const testButtons = div.querySelectorAll('.display-mode-btn');
                        if (testButtons.length > 0) {
                            buttons = testButtons;
                            break;
                        }
                    }
                }
            }
            
            buttons.forEach(btn => {
                if (btn.getAttribute('data-mode') === mode) {
                    btn.style.background = '#3b82f6';
                    btn.style.color = 'white';
                } else {
                    btn.style.background = 'transparent';
                    btn.style.color = '#6b7280';
                }
            });
            
            // Get cross-reference data from parent window if in iframe, otherwise use local
            const crossRef = window.parent && window.parent.idCrossReference ? 
                            window.parent.idCrossReference : 
                            window.idCrossReference;
            
            // Update cell displays
            const cells = table.querySelectorAll('.tp-id-cell');
            cells.forEach(cell => {
                const id = cell.getAttribute('data-id');
                if (!id) return;
                
                // Store original HTML if not already stored
                if (!cell.hasAttribute('data-original-html')) {
                    cell.setAttribute('data-original-html', cell.innerHTML);
                }
                
                let displayValue = id;
                if (crossRef && crossRef[id]) {
                    const xref = crossRef[id];
                    if (mode === 'name' && xref.name) {
                        displayValue = xref.name;
                    } else if (mode === 'region' && xref.region) {
                        displayValue = xref.region;
                    }
                }
                
                // Preserve HTML formatting (like <strong> tags) from original
                const originalHTML = cell.getAttribute('data-original-html');
                if (originalHTML && originalHTML.includes('<strong>')) {
                    cell.innerHTML = '<strong>' + displayValue + '</strong>';
                } else {
                    cell.textContent = displayValue;
                }
            });
        };
        
        window.updateAllTablesWithCrossRef = function() {
            // This function will be called when cross-ref is loaded/removed
            // to update all tables in the current report
            
            // Re-run the analysis if report has been generated
            const reportFrame = document.getElementById('reportFrame');
            if (reportFrame && reportFrame.srcdoc && window.analyzer) {
                // Get current files and re-analyze
                const currentFiles = window.analyzer.uploadedFiles;
                if (currentFiles && currentFiles.length > 0) {
                    // Show loading indicator
                    reportFrame.srcdoc = '<div style="text-align: center; padding: 50px;"><h3>Updating report with cross-reference data...</h3></div>';
                    
                    // Re-analyze files with cross-reference data
                    setTimeout(() => {
                        window.analyzeFiles();
                    }, 100);
                }
            }
        };
        </scr` + `ipt>`;
        
        return html;
    }

    generateSmartInsights(data, sortedPeriods) {
        if (sortedPeriods.length < 2) {
            return "";
        }
        
        // Get last 3 months and previous 3 months for comparison
        const last3Months = sortedPeriods.slice(-3);
        const prev3Months = sortedPeriods.length >= 6 ? sortedPeriods.slice(-6, -3) : [];
        const currentPeriod = sortedPeriods[sortedPeriods.length - 1];
        const prevPeriod = sortedPeriods[sortedPeriods.length - 2];
        
        // Collect all insights
        const insights = [];
        
        // 1. Volume Changes Analysis (3-month comparison)
        if (data.trends && data.trends.Date_Summary && data.trends.Date_Summary.metric_trends) {
            const docTrend = data.trends.Date_Summary.metric_trends['TOTAL-DOC'] || [];
            const kcTrend = data.trends.Date_Summary.metric_trends['TOTAL-KCS'] || [];
            const periods = data.trends.Date_Summary.periods || [];
            
            // Calculate 3-month totals
            let last3Total = { docs: 0, kcs: 0 };
            let prev3Total = { docs: 0, kcs: 0 };
            
            last3Months.forEach(period => {
                const idx = periods.indexOf(period);
                if (idx >= 0) {
                    last3Total.docs += docTrend[idx] || 0;
                    last3Total.kcs += kcTrend[idx] || 0;
                }
            });
            
            prev3Months.forEach(period => {
                const idx = periods.indexOf(period);
                if (idx >= 0) {
                    prev3Total.docs += docTrend[idx] || 0;
                    prev3Total.kcs += kcTrend[idx] || 0;
                }
            });
            
            if (prev3Total.docs > 0) {
                const docChange = ((last3Total.docs - prev3Total.docs) / prev3Total.docs * 100);
                const kcChange = prev3Total.kcs > 0 ? ((last3Total.kcs - prev3Total.kcs) / prev3Total.kcs * 100) : 0;
                
                // Major volume changes over 3 months
                if (Math.abs(docChange) > 15) {
                    insights.push({
                        type: docChange > 0 ? 'positive' : 'negative',
                        category: 'volume',
                        priority: 'high',
                        icon: docChange > 0 ? '📈' : '📉',
                        title: `Quarterly Document Volume ${docChange > 0 ? 'Growth' : 'Decline'}`,
                        text: `Document volume ${docChange > 0 ? 'increased' : 'decreased'} by ${Math.abs(docChange).toFixed(1)}% over last 3 months`,
                        details: `Last 3 months: ${last3Total.docs.toLocaleString()} docs | Previous 3 months: ${prev3Total.docs.toLocaleString()} docs | Change: ${docChange > 0 ? '+' : ''}${(last3Total.docs - prev3Total.docs).toLocaleString()} docs`
                    });
                }
                
                // Efficiency changes (3-month comparison)
                const last3Efficiency = last3Total.kcs > 0 ? last3Total.docs / last3Total.kcs : 0;
                const prev3Efficiency = prev3Total.kcs > 0 ? prev3Total.docs / prev3Total.kcs : 0;
                const efficiencyChange = prev3Efficiency > 0 ? ((last3Efficiency - prev3Efficiency) / prev3Efficiency * 100) : 0;
                
                if (Math.abs(efficiencyChange) > 10) {
                    insights.push({
                        type: efficiencyChange > 0 ? 'positive' : 'negative',
                        category: 'efficiency',
                        priority: 'medium',
                        icon: efficiencyChange > 0 ? '⚡' : '⚠️',
                        title: `Quarterly Efficiency ${efficiencyChange > 0 ? 'Improvement' : 'Decline'}`,
                        text: `Processing efficiency ${efficiencyChange > 0 ? 'improved' : 'declined'} by ${Math.abs(efficiencyChange).toFixed(1)}% over last 3 months`,
                        details: `Last 3 months avg: ${last3Efficiency.toFixed(2)} docs/KC | Previous 3 months avg: ${prev3Efficiency.toFixed(2)} docs/KC | ${efficiencyChange > 0 ? 'More' : 'Less'} documents processed per kilocharacter`
                    });
                }
            }
        }
        
        // 2. Trading Partner Insights (3-month analysis)
        if (data.tp_data) {
            const last3TPs = new Set();
            const prev3TPs = new Set();
            
            // Collect trading partners from last 3 months
            last3Months.forEach(period => {
                if (data.tp_data[period] && data.tp_data[period]['TP_Summary']) {
                    data.tp_data[period]['TP_Summary'].forEach(row => {
                        const tpId = row['TP ID'] || row['TP-ID'] || row['Trading Partner'];
                        if (tpId) last3TPs.add(tpId);
                    });
                }
            });
            
            // Collect trading partners from previous 3 months
            prev3Months.forEach(period => {
                if (data.tp_data[period] && data.tp_data[period]['TP_Summary']) {
                    data.tp_data[period]['TP_Summary'].forEach(row => {
                        const tpId = row['TP ID'] || row['TP-ID'] || row['Trading Partner'];
                        if (tpId) prev3TPs.add(tpId);
                    });
                }
            });
            
            // New partners in last 3 months
            const newPartners = Array.from(last3TPs).filter(tp => !prev3TPs.has(tp));
            if (newPartners.length > 0) {
                insights.push({
                    type: 'info',
                    category: 'partners',
                    priority: 'medium',
                    icon: '🤝',
                    title: 'New Trading Partners (3-Month)',
                    text: `${newPartners.length} new partner${newPartners.length > 1 ? 's' : ''} started trading in the last 3 months`,
                    details: `New partners: ${newPartners.slice(0, 5).join(', ')}${newPartners.length > 5 ? ` and ${newPartners.length - 5} more` : ''} | Total active partners (3mo): ${last3TPs.size}`
                });
            }
            
            // Lost partners from previous 3 months
            const lostPartners = Array.from(prev3TPs).filter(tp => !last3TPs.has(tp));
            if (lostPartners.length > 0) {
                insights.push({
                    type: 'warning',
                    category: 'partners',
                    priority: 'high',
                    icon: '⚠️',
                    title: 'Inactive Trading Partners (3-Month)',
                    text: `${lostPartners.length} partner${lostPartners.length > 1 ? 's' : ''} had no activity in the last 3 months`,
                    details: `Previously active partners: ${lostPartners.slice(0, 5).join(', ')}${lostPartners.length > 5 ? ` and ${lostPartners.length - 5} more` : ''} | Consider re-engagement strategies`
                });
            }
        }
        
        // 3. Anomaly Detection
        if (data.trends && data.trends.Date_Summary) {
            const docTrend = data.trends.Date_Summary.metric_trends['TOTAL-DOC'] || [];
            if (docTrend.length >= 3) {
                // Calculate standard deviation for last 6 months
                const recentData = docTrend.slice(-6);
                const mean = recentData.reduce((a, b) => a + b, 0) / recentData.length;
                const variance = recentData.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / recentData.length;
                const stdDev = Math.sqrt(variance);
                
                const currentValue = docTrend[docTrend.length - 1];
                const zScore = stdDev > 0 ? Math.abs((currentValue - mean) / stdDev) : 0;
                
                if (zScore > 2) {
                    insights.push({
                        type: 'warning',
                        category: 'anomaly',
                        priority: 'high',
                        icon: '🔍',
                        title: 'Unusual Activity Detected',
                        text: `Current document volume is ${zScore.toFixed(1)} standard deviations from the 6-month average`
                    });
                }
            }
        }
        
        // 4. Seasonality Insights
        const currentMonth = currentPeriod.split('-')[1];
        const monthName = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'][parseInt(currentMonth) - 1];
        
        // Check if this month historically shows patterns
        if (data.trends && data.trends.Date_Summary) {
            const periods = data.trends.Date_Summary.periods || [];
            const docTrend = data.trends.Date_Summary.metric_trends['TOTAL-DOC'] || [];
            
            // Get all values for this month across years
            const sameMonthValues = [];
            periods.forEach((period, idx) => {
                if (period.split('-')[1] === currentMonth && period !== currentPeriod) {
                    sameMonthValues.push(docTrend[idx]);
                }
            });
            
            if (sameMonthValues.length >= 2) {
                const avgSameMonth = sameMonthValues.reduce((a, b) => a + b, 0) / sameMonthValues.length;
                const currentValue = docTrend[periods.indexOf(currentPeriod)];
                const monthVariation = ((currentValue - avgSameMonth) / avgSameMonth * 100);
                
                if (Math.abs(monthVariation) > 15) {
                    insights.push({
                        type: 'info',
                        category: 'seasonality',
                        priority: 'low',
                        icon: '🗓️',
                        title: 'Seasonal Pattern',
                        text: `${monthName} volume is ${Math.abs(monthVariation).toFixed(0)}% ${monthVariation > 0 ? 'above' : 'below'} historical ${monthName} average`
                    });
                }
            }
        }
        
        // Sort insights by priority
        const priorityOrder = { high: 0, medium: 1, low: 2 };
        insights.sort((a, b) => priorityOrder[a.priority] - priorityOrder[b.priority]);
        
        if (insights.length === 0) {
            return "";
        }
        
        // Generate HTML
        let html = `
        <div style="margin-bottom: 40px;">
            <h4 style="color: #2d3748; margin: 0 0 20px 0;">💡 Smart Insights & Key Findings (3-Month Analysis)
                <span class="info-icon">i
                    <div class="tooltip">
                        AI-powered insights analyze the last 3 months of data to identify important trends, anomalies, and patterns.
                        Comparisons are made between the most recent 3 months and the previous 3-month period.
                        These insights are automatically generated based on statistical analysis and business rules.
                        High priority items require immediate attention.
                    </div>
                </span>
            </h4>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(450px, 1fr)); gap: 15px;">`;
        
        insights.forEach(insight => {
            const bgColor = insight.type === 'positive' ? '#f0fdf4' : 
                           insight.type === 'negative' ? '#fef2f2' : 
                           insight.type === 'warning' ? '#fffbeb' : '#f0f9ff';
            const borderColor = insight.type === 'positive' ? '#86efac' : 
                               insight.type === 'negative' ? '#fca5a5' : 
                               insight.type === 'warning' ? '#fde047' : '#93c5fd';
            const iconBg = insight.type === 'positive' ? '#d1fae5' : 
                          insight.type === 'negative' ? '#fee2e2' : 
                          insight.type === 'warning' ? '#fef3c7' : '#dbeafe';
            
            html += `
            <div style="
                background: ${bgColor};
                border: 1px solid ${borderColor};
                border-radius: 10px;
                padding: 20px;
                display: flex;
                align-items: start;
                gap: 16px;
                min-height: 120px;
                transition: all 0.2s ease;
                cursor: pointer;
            " onmouseover="this.style.boxShadow='0 4px 12px rgba(0,0,0,0.1)'" onmouseout="this.style.boxShadow=''">
                <div style="
                    background: ${iconBg};
                    width: 48px;
                    height: 48px;
                    border-radius: 10px;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    font-size: 1.5em;
                    flex-shrink: 0;
                ">${insight.icon}</div>
                <div style="flex: 1; min-width: 0;">
                    <div style="display: flex; align-items: center; flex-wrap: wrap; gap: 8px; margin-bottom: 8px;">
                        <div style="font-weight: 600; color: #1f2937; font-size: 1.05em;">${insight.title}</div>
                        ${insight.priority === 'high' ? 
                            '<span style="background: #dc2626; color: white; font-size: 0.7em; padding: 3px 10px; border-radius: 12px; font-weight: 600;">HIGH PRIORITY</span>' : 
                            insight.priority === 'medium' ? 
                            '<span style="background: #f59e0b; color: white; font-size: 0.7em; padding: 3px 10px; border-radius: 12px;">MEDIUM</span>' : 
                            ''
                        }
                    </div>
                    <div style="color: #4b5563; font-size: 0.95em; line-height: 1.5;">
                        ${insight.text}
                    </div>
                    ${insight.details ? `
                        <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid ${borderColor};">
                            <div style="color: #6b7280; font-size: 0.85em;">
                                ${insight.details}
                            </div>
                        </div>
                    ` : ''}
                </div>
            </div>`;
        });
        
        html += `
            </div>
        </div>`;
        
        return html;
    }

    generateMomAnalysis(data) {
        if (!data.trends) {
            return "<p>No data available for month-over-month analysis.</p>";
        }
        
        // Get all periods sorted
        const allPeriods = new Set();
        for (const [sheetName, trends] of Object.entries(data.trends)) {
            if (trends.periods) {
                trends.periods.forEach(p => allPeriods.add(p));
            }
        }
        const sortedPeriods = Array.from(allPeriods).sort();
        
        if (sortedPeriods.length < 2) {
            return "<p>Insufficient data for month-over-month analysis. At least 2 months of data required.</p>";
        }
        
        let html = `<div style="background: white; padding: 30px; border-radius: 15px; box-shadow: 0 4px 20px rgba(0,0,0,0.08);">
            <h3 style="margin-top: 0; color: #1a365d; margin-bottom: 30px;">📈 Month over Month Analysis
                <span class="info-icon">i
                    <div class="tooltip">
                        Month over Month Analysis tracks changes in key metrics across time periods.
                        It includes summary comparisons and detailed trading partner performance tables.
                        Growth percentages help identify trends and seasonal patterns.
                        Use this tab to understand how your business is evolving over time.
                    </div>
                </span>
            </h3>`;
        
        // Visual Dashboard Summary
        html += this.generateMoMDashboard(data, sortedPeriods);
        
        // Smart Insights (formerly Monthly Highlights)
        html += this.generateSmartInsights(data, sortedPeriods);
        
        // Summary Metrics Comparison
        html += this.generateMonthlyComparison(data, sortedPeriods);
        
        // Consolidated TP Monthly Performance
        html += this.generateConsolidatedTPPerformance(data, sortedPeriods);
        
        // Document Type Behavior
        html += this.generateDocTypeBehavior(data, sortedPeriods);
        
        // Document Type Behavior KCs
        html += this.generateDocTypeBehaviorKCs(data, sortedPeriods);
        
        html += "</div>";
        return html;
    }
    
    generateTpAnalysis(data) {
        if (!data.tp_data || Object.keys(data.tp_data).length === 0) {
            return `<div style="background: white; padding: 30px; border-radius: 15px;">
                <h3>Trading Partner Analysis</h3>
                <p>No trading partner data available.</p>
            </div>`;
        }
        
        // Extract TP data and analyze
        const tpData = this.extractTPData(data);
        const tpAnalysis = this.analyzeTPData(tpData);
        
        let html = `<div style="background: white; padding: 30px; border-radius: 15px; box-shadow: 0 4px 20px rgba(0,0,0,0.08);">
            <h3 style="margin-top: 0; color: #1a365d; margin-bottom: 30px;">Trading Partner Analysis
                <span class="info-icon">i
                    <div class="tooltip">
                        Trading Partner Analysis provides detailed insights into your business relationships.
                        It includes volume rankings, growth trends, and document type breakdowns by partner.
                        Charts and tables help visualize partner performance and identify opportunities.
                        Use this tab to manage and optimize your trading partner relationships.
                    </div>
                </span>
            </h3>`;
        
        // Visual Summary Dashboard
        html += this.generateTPSummaryDashboard(tpAnalysis, tpData);
        
        // Partner Performance Section
        html += `<div style="margin-top: 40px; padding-top: 40px; border-top: 2px solid #e5e7eb;">
            <h3 style="color: #374151; margin-bottom: 25px; font-size: 1.3em;">
                Partner Performance Analysis
            </h3>`;
        
        // Top TPs by document volume
        html += this.generateTopTPsTable(tpAnalysis);
        
        // Top TPs by KC volume
        html += this.generateTPKCAnalysis(tpData, tpAnalysis);
        
        html += `</div>`; // End Partner Performance Section
        
        // Growth & Trends Section
        html += `<div style="margin-top: 40px; padding-top: 40px; border-top: 2px solid #e5e7eb;">
            <h3 style="color: #374151; margin-bottom: 25px; font-size: 1.3em;">
                Growth & Trend Analysis
            </h3>`;
        
        // Growth Analysis
        html += this.generateTPGrowthAnalysis(tpAnalysis);
        
        // Volume Trends Chart
        html += this.generateTPTrendsChart(tpAnalysis);
        
        // Seasonality Analysis for Partners
        html += this.generateTPSeasonalityAnalysis(tpAnalysis);
        
        html += `</div>`; // End Growth & Trends Section
        
        // Document Analysis Section
        html += `<div style="margin-top: 40px; padding-top: 40px; border-top: 2px solid #e5e7eb;">
            <h3 style="color: #374151; margin-bottom: 25px; font-size: 1.3em;">
                Document Type Analysis
            </h3>`;
        
        // Document Types by TP
        html += this.generateDocTypesAnalysis(tpAnalysis.doc_types_by_tp);
        
        html += `</div>`; // End Document Analysis Section
        
        html += "</div>";
        return html;
    }
    
    generateDocumentAnalysis(data) {
        // Extract document data
        const docData = this.extractDocumentData(data);
        
        // Store docData for export functions
        this.docData = docData;
        
        if (!docData) {
            return `<div class="doc-analysis-container">
                <h3 style="margin-top: 0; color: #1a365d;">📄 Document Analysis</h3>
                <p style="text-align: center; color: #718096; padding: 20px;">
                    No document data available. Please ensure your data includes TP_Doc_Summary sheets.
                </p>
            </div>`;
        }
        
        // Analyze document trends
        const docAnalysis = this.analyzeDocumentTrends(docData);
        
        let html = `<div class="doc-analysis-container">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 30px;">
                <h3 style="margin: 0; color: #1a365d;">📄 Document Analysis
                    <span class="info-icon">i
                        <div class="tooltip">
                            Document Analysis examines the types and volumes of documents processed.
                            It includes count analysis, KC volume analysis, and behavior trends by document type.
                            The TP-Document Type Matrix shows relationships between partners and document types.
                            Use this tab to optimize document processing and identify efficiency opportunities.
                        </div>
                    </span>
                </h3>
            </div>`;
        
        // Summary statistics
        const totalDocs = docAnalysis.total_documents;
        const uniqueTypes = docAnalysis.document_types.size;
        const activeTPs = Object.keys(docAnalysis.tp_document_counts).length;
        
        html += `<div class="info-box" style="margin-bottom: 30px;">
            <strong>Document Summary:</strong> ${totalDocs.toLocaleString()} Total Documents | 
            ${uniqueTypes} Document Types | ${activeTPs} Trading Partners | 
            ${docAnalysis.periods.length} Periods Analyzed
        </div>`;
        
        
        // Add Efficiency Metrics Dashboard
        html += this.generateEfficiencyMetrics(docAnalysis);
        
        // Document Count and KC Count line graph - moved to top
        html += this.generateDocKCTrendsChart(docAnalysis, data);
        
        // Predictive Analytics - moved after Doc/KC trends
        html += this.generatePredictiveAnalytics(docAnalysis);
        
        // Document volume summary
        html += this.generateMonthlyDocAnalysis(docAnalysis);
        
        // Performance Indicators
        html += this.generatePerformanceIndicators(docAnalysis);
        
        // Top TPs by document volume
        html += this.generateTPDocVolumeAnalysis(docAnalysis);
        
        // Document type distribution chart - moved just above TP-Document Type Matrix
        html += this.generateDocTypeDistribution(docAnalysis);
        
        // TP-Document Type Matrix Tables
        html += this.generateTPDocMatrixTables(docData, docAnalysis);
        
        html += "</div>";
        return html;
    }
    
    generateHubAnalysis(data) {
        // Hub Analysis - analyze hub patterns and relationships
        let html = `<div style="background: white; padding: 30px; border-radius: 15px; box-shadow: 0 4px 20px rgba(0,0,0,0.08);">
            <h3 style="margin-top: 0; color: #1a365d; margin-bottom: 30px;">🌐 Hub Analysis
                <span class="info-icon">i
                    <div class="tooltip">
                        Hub Analysis identifies central trading partners that act as distribution hubs.
                        It analyzes connection patterns, volume flows, and network centrality.
                        Hubs are partners that connect with many other partners or handle high volumes.
                        Use this to optimize routing and identify critical network nodes.
                    </div>
                </span>
            </h3>`;
        
        // Extract hub data
        const hubData = this.extractHubData(data);
        
        if (!hubData || hubData.hubCount === 0) {
            html += `
            <div style="background: #fef3c7; border: 1px solid #fbbf24; padding: 20px; border-radius: 8px; margin: 20px 0;">
                <p style="color: #92400e; margin: 0 0 10px 0; font-weight: 600;">⚠️ No Hub Data Found</p>
                <p style="color: #78350f; margin: 0;">
                    Please ensure your Excel files include a 'Hub_Summary' sheet with the following columns:
                </p>
                <ul style="color: #78350f; margin: 10px 0 0 20px;">
                    <li><strong>HUB ID</strong>: The unique hub identifier</li>
                    <li><strong>TOTAL-DOC</strong>: Total document count</li>
                    <li><strong>TOTAL-KCS</strong>: Total kilocharacter count</li>
                </ul>
                ${hubData && hubData.debugInfo && hubData.debugInfo.length > 0 ? `
                <p style="color: #78350f; margin: 10px 0 5px 0; font-size: 0.9em;"><strong>Debug Info:</strong></p>
                <ul style="color: #78350f; margin: 0 0 0 20px; font-size: 0.85em;">
                    ${hubData.debugInfo.map(info => `<li>${info}</li>`).join('')}
                </ul>
                ` : ''}
            </div></div>`;
            return html;
        }
        
        // Hub Metrics Dashboard
        html += `
        <div style="margin-bottom: 30px;">
            <h4 style="color: #2d3748; margin-bottom: 20px; font-size: 1.1em;">📊 Hub Metrics Overview</h4>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px;">`;
        
        // Total Hubs Card
        html += `
                <div style="background: linear-gradient(135deg, rgba(139, 92, 246, 0.3) 0%, rgba(124, 58, 237, 0.3) 100%); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); border: 1px solid rgba(139, 92, 246, 0.4); padding: 20px; border-radius: 12px; box-shadow: 0 8px 32px rgba(139, 92, 246, 0.1); min-height: 120px; display: flex; flex-direction: column; justify-content: space-between; overflow: hidden;">
                    <div style="font-size: 0.85em; opacity: 0.8; margin-bottom: 5px; color: #4c1d95; font-weight: 500;">Identified Hubs</div>
                    <div style="font-size: clamp(1.5em, 4vw, 2.2em); font-weight: bold; color: #4c1d95; line-height: 1; word-break: break-word;">${hubData.hubCount}</div>
                    <div style="font-size: 0.75em; opacity: 0.7; color: #5b21b6; margin-top: 5px;">
                        Unique HUB IDs
                    </div>
                </div>`;
        
        // Document Volume Card
        html += `
                <div style="background: linear-gradient(135deg, rgba(16, 185, 129, 0.3) 0%, rgba(5, 150, 105, 0.3) 100%); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); border: 1px solid rgba(16, 185, 129, 0.4); padding: 20px; border-radius: 12px; box-shadow: 0 8px 32px rgba(16, 185, 129, 0.1); min-height: 120px; display: flex; flex-direction: column; justify-content: space-between; overflow: hidden;">
                    <div style="font-size: 0.85em; opacity: 0.8; margin-bottom: 5px; color: #065f46; font-weight: 500;">Document Volume</div>
                    <div style="font-size: clamp(1.5em, 4vw, 2.2em); font-weight: bold; color: #064e3b; line-height: 1; word-break: break-word;">${hubData.totalDocs.toLocaleString()}</div>
                    <div style="font-size: 0.75em; opacity: 0.7; color: #065f46; margin-top: 5px;">
                        Total hub documents
                    </div>
                </div>`;
        
        // Total KCs Card
        html += `
                <div style="background: linear-gradient(135deg, rgba(245, 158, 11, 0.3) 0%, rgba(217, 119, 6, 0.3) 100%); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); border: 1px solid rgba(245, 158, 11, 0.4); padding: 20px; border-radius: 12px; box-shadow: 0 8px 32px rgba(245, 158, 11, 0.1); min-height: 120px; display: flex; flex-direction: column; justify-content: space-between; overflow: hidden;">
                    <div style="font-size: 0.85em; opacity: 0.8; margin-bottom: 5px; color: #92400e; font-weight: 500;">Kilocharacters</div>
                    <div style="font-size: clamp(1.5em, 4vw, 2.2em); font-weight: bold; color: #78350f; line-height: 1; word-break: break-word;">${hubData.totalKCs.toLocaleString()}</div>
                    <div style="font-size: 0.75em; opacity: 0.7; color: #92400e; margin-top: 5px;">
                        Total hub KCs
                    </div>
                </div>`;
        
        // Active Periods Card
        html += `
                <div style="background: linear-gradient(135deg, rgba(59, 130, 246, 0.3) 0%, rgba(29, 78, 216, 0.3) 100%); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); border: 1px solid rgba(59, 130, 246, 0.4); padding: 20px; border-radius: 12px; box-shadow: 0 8px 32px rgba(59, 130, 246, 0.1); min-height: 120px; display: flex; flex-direction: column; justify-content: space-between; overflow: hidden;">
                    <div style="font-size: 0.85em; opacity: 0.8; margin-bottom: 5px; color: #1e3a8a; font-weight: 500;">Active Periods</div>
                    <div style="font-size: clamp(1.5em, 4vw, 2.2em); font-weight: bold; color: #1e3a8a; line-height: 1; word-break: break-word;">${hubData.periods.length}</div>
                    <div style="font-size: 0.75em; opacity: 0.7; color: #1e40af; margin-top: 5px;">
                        Months with hub data
                    </div>
                </div>`;
        
        html += `
            </div>
        </div>`;
        
        // Add pie charts section
        html += `
        <div style="margin-top: 30px;">
            <h4 style="color: #2d3748; margin-bottom: 20px; font-size: 1.1em;">📊 Hub Distribution Analysis</h4>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(400px, 1fr)); gap: 20px;">
                <!-- Document Distribution Chart -->
                <div style="background: linear-gradient(135deg, rgba(255, 255, 255, 0.5) 0%, rgba(249, 250, 251, 0.5) 100%); backdrop-filter: blur(10px); border: 1px solid rgba(229, 231, 235, 0.4); padding: 20px; border-radius: 12px; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.08);">
                    <h5 style="margin: 0 0 15px 0; color: #374151; font-size: 1em;">Document Distribution by Hub</h5>
                    <div style="position: relative; height: 300px;">
                        <canvas id="hubDocDistributionChart"></canvas>
                    </div>
                </div>
                
                <!-- KC Distribution Chart -->
                <div style="background: linear-gradient(135deg, rgba(255, 255, 255, 0.5) 0%, rgba(249, 250, 251, 0.5) 100%); backdrop-filter: blur(10px); border: 1px solid rgba(229, 231, 235, 0.4); padding: 20px; border-radius: 12px; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.08);">
                    <h5 style="margin: 0 0 15px 0; color: #374151; font-size: 1em;">Kilocharacter Distribution by Hub</h5>
                    <div style="position: relative; height: 300px;">
                        <canvas id="hubKcDistributionChart"></canvas>
                    </div>
                </div>
            </div>
        </div>`;
        
        // Add trend analysis section
        html += `
        <div style="margin-top: 30px;">
            <h4 style="color: #2d3748; margin-bottom: 20px; font-size: 1.1em;">📈 Hub Trend Analysis</h4>
            
            <!-- Filter Controls -->
            <div style="background: linear-gradient(135deg, rgba(255, 255, 255, 0.5) 0%, rgba(249, 250, 251, 0.5) 100%); backdrop-filter: blur(10px); border: 1px solid rgba(229, 231, 235, 0.4); padding: 15px; border-radius: 12px; margin-bottom: 20px;">
                <div style="display: flex; gap: 20px; align-items: center; flex-wrap: wrap;">
                    <div>
                        <label style="font-size: 0.9em; color: #4b5563; margin-right: 10px;">Select Hubs:</label>
                        <select id="hubTrendFilter" multiple style="padding: 8px; border-radius: 6px; border: 1px solid #d1d5db; min-width: 200px; height: 100px;">
                            ${Object.keys(hubData.hubDetails).map(hubId => 
                                `<option value="${hubId}" selected>${hubId}</option>`
                            ).join('')}
                        </select>
                    </div>
                    <div>
                        <button onclick="updateHubTrendCharts()" style="background: #3b82f6; color: white; padding: 8px 16px; border-radius: 6px; border: none; cursor: pointer; font-size: 0.9em;">Update Charts</button>
                    </div>
                    <div style="font-size: 0.85em; color: #6b7280;">
                        Hold Ctrl/Cmd to select multiple hubs
                    </div>
                </div>
            </div>
            
            <!-- Trend Charts -->
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(500px, 1fr)); gap: 20px; margin-bottom: 20px;">
                <!-- Document Trend Chart -->
                <div style="background: linear-gradient(135deg, rgba(255, 255, 255, 0.5) 0%, rgba(249, 250, 251, 0.5) 100%); backdrop-filter: blur(10px); border: 1px solid rgba(229, 231, 235, 0.4); padding: 20px; border-radius: 12px; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.08);">
                    <h5 style="margin: 0 0 15px 0; color: #374151; font-size: 1em;">Document Volume Trends</h5>
                    <div style="position: relative; height: 300px;">
                        <canvas id="hubDocTrendChart"></canvas>
                    </div>
                </div>
                
                <!-- KC Trend Chart -->
                <div style="background: linear-gradient(135deg, rgba(255, 255, 255, 0.5) 0%, rgba(249, 250, 251, 0.5) 100%); backdrop-filter: blur(10px); border: 1px solid rgba(229, 231, 235, 0.4); padding: 20px; border-radius: 12px; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.08);">
                    <h5 style="margin: 0 0 15px 0; color: #374151; font-size: 1em;">Kilocharacter Volume Trends</h5>
                    <div style="position: relative; height: 300px;">
                        <canvas id="hubKcTrendChart"></canvas>
                    </div>
                </div>
            </div>
            
            <!-- Performance Analysis -->
            <h4 style="color: #2d3748; margin-bottom: 20px; margin-top: 30px; font-size: 1.1em;">🎯 Performance Analysis</h4>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px;">
                <!-- Doc/KC Ratio Card -->
                <div style="background: linear-gradient(135deg, rgba(239, 246, 255, 0.5) 0%, rgba(219, 234, 254, 0.5) 100%); backdrop-filter: blur(10px); border: 1px solid rgba(147, 197, 253, 0.4); padding: 20px; border-radius: 12px; box-shadow: 0 8px 32px rgba(59, 130, 246, 0.1);">
                    <h5 style="margin: 0 0 15px 0; color: #1e40af; font-size: 1em;">📄 Average Document Size (Doc/KC)</h5>
                    <div style="font-size: clamp(1.8em, 3vw, 2.5em); font-weight: bold; color: #1e3a8a; margin-bottom: 10px;">
                        ${hubData.totalKCs > 0 ? (hubData.totalDocs / hubData.totalKCs).toFixed(3) : '0.000'}
                    </div>
                    <div style="font-size: 0.85em; color: #3730a3;">
                        Documents per Kilocharacter
                    </div>
                    <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid rgba(147, 197, 253, 0.3);">
                        <div style="font-size: 0.8em; color: #4b5563; margin-bottom: 8px;">Interpretation:</div>
                        <div style="font-size: 0.75em; color: #6b7280; line-height: 1.4;">
                            ${hubData.totalKCs > 0 && (hubData.totalDocs / hubData.totalKCs) > 1 ? 
                                '⚡ High ratio indicates many small documents' : 
                                '📚 Low ratio indicates fewer, larger documents'}
                        </div>
                    </div>
                </div>
                
                <!-- KC/Doc Ratio Card -->
                <div style="background: linear-gradient(135deg, rgba(243, 244, 246, 0.5) 0%, rgba(229, 231, 235, 0.5) 100%); backdrop-filter: blur(10px); border: 1px solid rgba(156, 163, 175, 0.4); padding: 20px; border-radius: 12px; box-shadow: 0 8px 32px rgba(107, 114, 128, 0.1);">
                    <h5 style="margin: 0 0 15px 0; color: #374151; font-size: 1em;">📊 Average Document Content (KC/Doc)</h5>
                    <div style="font-size: clamp(1.8em, 3vw, 2.5em); font-weight: bold; color: #1f2937; margin-bottom: 10px;">
                        ${hubData.totalDocs > 0 ? (hubData.totalKCs / hubData.totalDocs).toFixed(3) : '0.000'}
                    </div>
                    <div style="font-size: 0.85em; color: #4b5563;">
                        Kilocharacters per Document
                    </div>
                    <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid rgba(156, 163, 175, 0.3);">
                        <div style="font-size: 0.8em; color: #4b5563; margin-bottom: 8px;">Interpretation:</div>
                        <div style="font-size: 0.75em; color: #6b7280; line-height: 1.4;">
                            ${hubData.totalDocs > 0 && (hubData.totalKCs / hubData.totalDocs) > 5 ? 
                                '📈 High content density per document' : 
                                hubData.totalDocs > 0 && (hubData.totalKCs / hubData.totalDocs) > 1 ?
                                '📄 Moderate content per document' :
                                '📝 Low content per document'}
                        </div>
                    </div>
                </div>
                
                <!-- Efficiency Score Card -->
                <div style="background: linear-gradient(135deg, rgba(236, 253, 245, 0.5) 0%, rgba(209, 250, 229, 0.5) 100%); backdrop-filter: blur(10px); border: 1px solid rgba(110, 231, 183, 0.4); padding: 20px; border-radius: 12px; box-shadow: 0 8px 32px rgba(16, 185, 129, 0.1);">
                    <h5 style="margin: 0 0 15px 0; color: #047857; font-size: 1em;">⚡ Processing Efficiency</h5>
                    <div style="font-size: clamp(1.8em, 3vw, 2.5em); font-weight: bold; color: #065f46; margin-bottom: 10px;">
                        ${hubData.uniqueHubs.size > 0 ? Math.round(hubData.totalDocs / hubData.uniqueHubs.size).toLocaleString() : '0'}
                    </div>
                    <div style="font-size: 0.85em; color: #059669;">
                        Avg Documents per Hub
                    </div>
                    <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid rgba(110, 231, 183, 0.3);">
                        <div style="font-size: 0.8em; color: #4b5563; margin-bottom: 8px;">Hub Load Distribution:</div>
                        <div style="font-size: 0.75em; color: #6b7280; line-height: 1.4;">
                            Total: ${hubData.uniqueHubs.size} hubs processing ${hubData.totalDocs.toLocaleString()} documents
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Hub Performance Details Table -->
            <div style="margin-top: 20px;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                    <h5 style="color: #2d3748; margin: 0; font-size: 1em;">📊 Hub Performance Details</h5>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <button onclick="parent.window.analyzer.exportTableToJSON('hubPerformanceTable', 'hub_performance.json')" 
                                style="padding: 8px 16px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px;">
                            Export to JSON
                        </button>
                        <button onclick="parent.window.analyzer.exportTableToCSV('hubPerformanceTable', 'hub_performance.csv')" 
                                style="padding: 8px 16px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px;">
                            Export to CSV
                        </button>
                        ${window.parent && window.parent.idCrossReference ? `
                        <div style="background: #f3f4f6; padding: 4px; border-radius: 8px; display: flex; gap: 4px; margin-left: 20px;">
                            <span style="padding: 6px 8px; color: #4b5563; font-size: 0.85em;">Display:</span>
                            <button onclick="setTPDisplayMode('id', 'hubPerformanceTable')" 
                                class="display-mode-btn display-mode-id" 
                                data-mode="id"
                                style="
                                    padding: 6px 12px;
                                    border: none;
                                    background: #3b82f6;
                                    color: white;
                                    border-radius: 6px;
                                    cursor: pointer;
                                    font-size: 0.85em;
                                    transition: all 0.2s;
                                ">ID</button>
                            <button onclick="setTPDisplayMode('name', 'hubPerformanceTable')" 
                                class="display-mode-btn display-mode-name" 
                                data-mode="name"
                                style="
                                    padding: 6px 12px;
                                    border: none;
                                    background: transparent;
                                    color: #6b7280;
                                    border-radius: 6px;
                                    cursor: pointer;
                                    font-size: 0.85em;
                                    transition: all 0.2s;
                                ">Name</button>
                            <button onclick="setTPDisplayMode('region', 'hubPerformanceTable')" 
                                class="display-mode-btn display-mode-region" 
                                data-mode="region"
                                style="
                                    padding: 6px 12px;
                                    border: none;
                                    background: transparent;
                                    color: #6b7280;
                                    border-radius: 6px;
                                    cursor: pointer;
                                    font-size: 0.85em;
                                    transition: all 0.2s;
                                ">Region</button>
                        </div>
                        ` : ''}
                    </div>
                </div>
                <div style="background: linear-gradient(135deg, rgba(255, 255, 255, 0.5) 0%, rgba(249, 250, 251, 0.5) 100%); backdrop-filter: blur(10px); border: 1px solid rgba(229, 231, 235, 0.4); padding: 15px; border-radius: 12px; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.08);">
                    <div style="overflow-x: auto;">
                        <table id="hubPerformanceTable" style="width: 100%; border-collapse: collapse; background: white; border-radius: 8px; font-size: 0.9em;">
                            <thead>
                                <tr style="background: #f8fafc;">
                                    <th style="padding: 10px; text-align: left; font-weight: 600; color: #2d3748; border-bottom: 2px solid #e5e7eb;">Hub ID</th>
                                    <th style="padding: 10px; text-align: right; font-weight: 600; color: #2d3748; border-bottom: 2px solid #e5e7eb;">Total Docs</th>
                                    <th style="padding: 10px; text-align: right; font-weight: 600; color: #2d3748; border-bottom: 2px solid #e5e7eb;">Total KCs</th>
                                    <th style="padding: 10px; text-align: right; font-weight: 600; color: #2d3748; border-bottom: 2px solid #e5e7eb;">Doc/KC</th>
                                    <th style="padding: 10px; text-align: right; font-weight: 600; color: #2d3748; border-bottom: 2px solid #e5e7eb;">KC/Doc</th>
                                    <th style="padding: 10px; text-align: right; font-weight: 600; color: #2d3748; border-bottom: 2px solid #e5e7eb;">Avg Docs/Period</th>
                                    <th style="padding: 10px; text-align: right; font-weight: 600; color: #2d3748; border-bottom: 2px solid #e5e7eb;">Active Periods</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${Object.values(hubData.hubDetails)
                                    .sort((a, b) => b.docs - a.docs)
                                    .map((hub, index) => {
                                        // Calculate metrics
                                        const docPerKc = hub.kcs > 0 ? (hub.docs / hub.kcs).toFixed(3) : '0.000';
                                        const kcPerDoc = hub.docs > 0 ? (hub.kcs / hub.docs).toFixed(3) : '0.000';
                                        
                                        // Count active periods for this hub
                                        let activePeriods = 0;
                                        if (hubData.periodData[hub.id]) {
                                            activePeriods = Object.keys(hubData.periodData[hub.id]).length;
                                        }
                                        
                                        const avgDocsPerPeriod = activePeriods > 0 ? Math.round(hub.docs / activePeriods) : 0;
                                        
                                        const rowBg = index % 2 === 0 ? '#ffffff' : '#f9fafb';
                                        
                                        // Color coding for ratios
                                        // Doc/KC: Higher is better (green)
                                        const docPerKcColor = docPerKc > 1 ? '#059669' : docPerKc > 0.5 ? '#f59e0b' : '#dc2626';
                                        // KC/Doc: Lower is better (green)
                                        const kcPerDocColor = kcPerDoc < 1 ? '#059669' : kcPerDoc < 5 ? '#f59e0b' : '#dc2626';
                                        
                                        return `
                                        <tr style="background: ${rowBg}; border-bottom: 1px solid #e5e7eb;">
                                            <td class="tp-id-cell" data-id="${hub.id}" style="padding: 10px; font-weight: 500;">${hub.id}</td>
                                            <td style="padding: 10px; text-align: right;">${hub.docs.toLocaleString()}</td>
                                            <td style="padding: 10px; text-align: right;">${hub.kcs.toLocaleString()}</td>
                                            <td style="padding: 10px; text-align: right; color: ${docPerKcColor}; font-weight: 600;">${docPerKc}</td>
                                            <td style="padding: 10px; text-align: right; color: ${kcPerDocColor}; font-weight: 600;">${kcPerDoc}</td>
                                            <td style="padding: 10px; text-align: right;">${avgDocsPerPeriod.toLocaleString()}</td>
                                            <td style="padding: 10px; text-align: right;">${activePeriods}</td>
                                        </tr>`;
                                    }).join('')}
                            </tbody>
                            <tfoot>
                                <tr style="background: #f1f5f9; font-weight: 600;">
                                    <td style="padding: 10px; border-top: 2px solid #e5e7eb;">Total/Average</td>
                                    <td style="padding: 10px; text-align: right; border-top: 2px solid #e5e7eb;">${hubData.totalDocs.toLocaleString()}</td>
                                    <td style="padding: 10px; text-align: right; border-top: 2px solid #e5e7eb;">${hubData.totalKCs.toLocaleString()}</td>
                                    <td style="padding: 10px; text-align: right; border-top: 2px solid #e5e7eb;">${hubData.totalKCs > 0 ? (hubData.totalDocs / hubData.totalKCs).toFixed(3) : '0.000'}</td>
                                    <td style="padding: 10px; text-align: right; border-top: 2px solid #e5e7eb;">${hubData.totalDocs > 0 ? (hubData.totalKCs / hubData.totalDocs).toFixed(3) : '0.000'}</td>
                                    <td style="padding: 10px; text-align: right; border-top: 2px solid #e5e7eb;">${hubData.uniqueHubs.size > 0 ? Math.round(hubData.totalDocs / hubData.uniqueHubs.size).toLocaleString() : '0'}</td>
                                    <td style="padding: 10px; text-align: right; border-top: 2px solid #e5e7eb;">-</td>
                                </tr>
                            </tfoot>
                        </table>
                    </div>
                    <div style="margin-top: 15px; padding: 10px; background: #f0f9ff; border-radius: 8px; border-left: 3px solid #3b82f6;">
                        <p style="margin: 0; font-size: 0.85em; color: #1e40af;">
                            <strong>Ratio Interpretation Guide:</strong>
                        </p>
                        <ul style="margin: 5px 0 0 20px; font-size: 0.8em; color: #3730a3;">
                            <li><strong style="color: #059669;">Doc/KC > 1 (Green):</strong> Efficient processing - many documents per kilocharacter</li>
                            <li><strong style="color: #dc2626;">Doc/KC < 0.5 (Red):</strong> Less efficient - fewer documents per kilocharacter</li>
                            <li><strong style="color: #059669;">KC/Doc < 1 (Green):</strong> Efficient small documents or status messages</li>
                            <li><strong style="color: #dc2626;">KC/Doc > 5 (Red):</strong> Large documents with high content density</li>
                        </ul>
                    </div>
                </div>
            </div>
            
            <!-- Monthly Distribution Tables -->
            <h4 style="color: #2d3748; margin-bottom: 20px; margin-top: 40px; font-size: 1.1em;">📅 Monthly Hub Distribution</h4>
            
            <!-- Documents per Month Table -->
            <div style="margin-bottom: 30px;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                    <h5 style="color: #2d3748; margin: 0; font-size: 1em;">📄 Documents per Hub by Month</h5>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <button onclick="parent.window.analyzer.exportTableToJSON('hubDocsMonthlyTable', 'hub_docs_monthly.json')" 
                                style="padding: 8px 16px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px;">
                            Export to JSON
                        </button>
                        <button onclick="parent.window.analyzer.exportTableToCSV('hubDocsMonthlyTable', 'hub_docs_monthly.csv')" 
                                style="padding: 8px 16px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px;">
                            Export to CSV
                        </button>
                        ${window.parent && window.parent.idCrossReference ? `
                        <div style="background: #f3f4f6; padding: 4px; border-radius: 8px; display: flex; gap: 4px; margin-left: 20px;">
                            <span style="padding: 6px 8px; color: #4b5563; font-size: 0.85em;">Display:</span>
                            <button onclick="setTPDisplayMode('id', 'hubDocsMonthlyTable')" 
                                class="display-mode-btn display-mode-id" 
                                data-mode="id"
                                style="
                                    padding: 6px 12px;
                                    border: none;
                                    background: #3b82f6;
                                    color: white;
                                    border-radius: 6px;
                                    cursor: pointer;
                                    font-size: 0.85em;
                                    transition: all 0.2s;
                                ">ID</button>
                            <button onclick="setTPDisplayMode('name', 'hubDocsMonthlyTable')" 
                                class="display-mode-btn display-mode-name" 
                                data-mode="name"
                                style="
                                    padding: 6px 12px;
                                    border: none;
                                    background: transparent;
                                    color: #6b7280;
                                    border-radius: 6px;
                                    cursor: pointer;
                                    font-size: 0.85em;
                                    transition: all 0.2s;
                                ">Name</button>
                            <button onclick="setTPDisplayMode('region', 'hubDocsMonthlyTable')" 
                                class="display-mode-btn display-mode-region" 
                                data-mode="region"
                                style="
                                    padding: 6px 12px;
                                    border: none;
                                    background: transparent;
                                    color: #6b7280;
                                    border-radius: 6px;
                                    cursor: pointer;
                                    font-size: 0.85em;
                                    transition: all 0.2s;
                                ">Region</button>
                        </div>
                        ` : ''}
                    </div>
                </div>
                <div style="background: linear-gradient(135deg, rgba(255, 255, 255, 0.5) 0%, rgba(249, 250, 251, 0.5) 100%); backdrop-filter: blur(10px); border: 1px solid rgba(229, 231, 235, 0.4); padding: 15px; border-radius: 12px; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.08);">
                    <div style="overflow-x: auto;">
                        <table id="hubDocsMonthlyTable" style="width: 100%; border-collapse: collapse; background: white; border-radius: 8px; font-size: 0.85em;">
                            <thead>
                                <tr style="background: #f8fafc;">
                                    <th style="padding: 10px; text-align: left; font-weight: 600; color: #2d3748; border-bottom: 2px solid #e5e7eb; position: sticky; left: 0; background: #f8fafc; z-index: 10;">Hub ID</th>
                                    ${hubData.periods.sort().map(period => 
                                        `<th style="padding: 10px; text-align: right; font-weight: 600; color: #2d3748; border-bottom: 2px solid #e5e7eb; white-space: nowrap;">${this.formatPeriodDisplay(period)}</th>`
                                    ).join('')}
                                    <th style="padding: 10px; text-align: right; font-weight: 600; color: #2d3748; border-bottom: 2px solid #e5e7eb; background: #e6f7ff;">Total</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${Object.values(hubData.hubDetails)
                                    .sort((a, b) => b.docs - a.docs)
                                    .map((hub, index) => {
                                        const rowBg = index % 2 === 0 ? '#ffffff' : '#f9fafb';
                                            
                                        let rowHtml = `<tr style="background: ${rowBg}; border-bottom: 1px solid #e5e7eb;">`;
                                        rowHtml += `<td class="tp-id-cell" data-id="${hub.id}" style="padding: 10px; font-weight: 500; position: sticky; left: 0; background: ${rowBg}; z-index: 5;">${hub.id}</td>`;
                                        
                                        let rowTotal = 0;
                                        hubData.periods.sort().forEach(period => {
                                            const periodData = hubData.periodData[hub.id] && hubData.periodData[hub.id][period] ? 
                                                              hubData.periodData[hub.id][period].docs : 0;
                                            rowTotal += periodData;
                                            const cellBg = periodData > 0 ? 'background: rgba(59, 130, 246, 0.1);' : '';
                                            rowHtml += `<td style="padding: 10px; text-align: right; ${cellBg}">${periodData > 0 ? periodData.toLocaleString() : '-'}</td>`;
                                        });
                                        
                                        rowHtml += `<td style="padding: 10px; text-align: right; font-weight: 600; background: #e6f7ff;">${rowTotal.toLocaleString()}</td>`;
                                        rowHtml += `</tr>`;
                                        return rowHtml;
                                    }).join('')}
                            </tbody>
                            <tfoot>
                                <tr style="background: #f1f5f9; font-weight: 600;">
                                    <td style="padding: 10px; border-top: 2px solid #e5e7eb; position: sticky; left: 0; background: #f1f5f9; z-index: 5;">Total</td>
                                    ${hubData.periods.sort().map(period => {
                                        let periodTotal = 0;
                                        Object.values(hubData.hubDetails).forEach(hub => {
                                            if (hubData.periodData[hub.id] && hubData.periodData[hub.id][period]) {
                                                periodTotal += hubData.periodData[hub.id][period].docs;
                                            }
                                        });
                                        return `<td style="padding: 10px; text-align: right; border-top: 2px solid #e5e7eb;">${periodTotal.toLocaleString()}</td>`;
                                    }).join('')}
                                    <td style="padding: 10px; text-align: right; border-top: 2px solid #e5e7eb; background: #e6f7ff;">${hubData.totalDocs.toLocaleString()}</td>
                                </tr>
                            </tfoot>
                        </table>
                    </div>
                </div>
            </div>
            
            <!-- Kilocharacters per Month Table -->
            <div style="margin-bottom: 30px;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                    <h5 style="color: #2d3748; margin: 0; font-size: 1em;">📊 Kilocharacters per Hub by Month</h5>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <button onclick="parent.window.analyzer.exportTableToJSON('hubKCsMonthlyTable', 'hub_kcs_monthly.json')" 
                                style="padding: 8px 16px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px;">
                            Export to JSON
                        </button>
                        <button onclick="parent.window.analyzer.exportTableToCSV('hubKCsMonthlyTable', 'hub_kcs_monthly.csv')" 
                                style="padding: 8px 16px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px;">
                            Export to CSV
                        </button>
                        ${window.parent && window.parent.idCrossReference ? `
                        <div style="background: #f3f4f6; padding: 4px; border-radius: 8px; display: flex; gap: 4px; margin-left: 20px;">
                            <span style="padding: 6px 8px; color: #4b5563; font-size: 0.85em;">Display:</span>
                            <button onclick="setTPDisplayMode('id', 'hubKCsMonthlyTable')" 
                                class="display-mode-btn display-mode-id" 
                                data-mode="id"
                                style="
                                    padding: 6px 12px;
                                    border: none;
                                    background: #3b82f6;
                                    color: white;
                                    border-radius: 6px;
                                    cursor: pointer;
                                    font-size: 0.85em;
                                    transition: all 0.2s;
                                ">ID</button>
                            <button onclick="setTPDisplayMode('name', 'hubKCsMonthlyTable')" 
                                class="display-mode-btn display-mode-name" 
                                data-mode="name"
                                style="
                                    padding: 6px 12px;
                                    border: none;
                                    background: transparent;
                                    color: #6b7280;
                                    border-radius: 6px;
                                    cursor: pointer;
                                    font-size: 0.85em;
                                    transition: all 0.2s;
                                ">Name</button>
                            <button onclick="setTPDisplayMode('region', 'hubKCsMonthlyTable')" 
                                class="display-mode-btn display-mode-region" 
                                data-mode="region"
                                style="
                                    padding: 6px 12px;
                                    border: none;
                                    background: transparent;
                                    color: #6b7280;
                                    border-radius: 6px;
                                    cursor: pointer;
                                    font-size: 0.85em;
                                    transition: all 0.2s;
                                ">Region</button>
                        </div>
                        ` : ''}
                    </div>
                </div>
                <div style="background: linear-gradient(135deg, rgba(255, 255, 255, 0.5) 0%, rgba(249, 250, 251, 0.5) 100%); backdrop-filter: blur(10px); border: 1px solid rgba(229, 231, 235, 0.4); padding: 15px; border-radius: 12px; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.08);">
                    <div style="overflow-x: auto;">
                        <table id="hubKCsMonthlyTable" style="width: 100%; border-collapse: collapse; background: white; border-radius: 8px; font-size: 0.85em;">
                            <thead>
                                <tr style="background: #f8fafc;">
                                    <th style="padding: 10px; text-align: left; font-weight: 600; color: #2d3748; border-bottom: 2px solid #e5e7eb; position: sticky; left: 0; background: #f8fafc; z-index: 10;">Hub ID</th>
                                    ${hubData.periods.sort().map(period => 
                                        `<th style="padding: 10px; text-align: right; font-weight: 600; color: #2d3748; border-bottom: 2px solid #e5e7eb; white-space: nowrap;">${this.formatPeriodDisplay(period)}</th>`
                                    ).join('')}
                                    <th style="padding: 10px; text-align: right; font-weight: 600; color: #2d3748; border-bottom: 2px solid #e5e7eb; background: #f0fdf4;">Total</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${Object.values(hubData.hubDetails)
                                    .sort((a, b) => b.kcs - a.kcs)
                                    .map((hub, index) => {
                                        const rowBg = index % 2 === 0 ? '#ffffff' : '#f9fafb';
                                            
                                        let rowHtml = `<tr style="background: ${rowBg}; border-bottom: 1px solid #e5e7eb;">`;
                                        rowHtml += `<td class="tp-id-cell" data-id="${hub.id}" style="padding: 10px; font-weight: 500; position: sticky; left: 0; background: ${rowBg}; z-index: 5;">${hub.id}</td>`;
                                        
                                        let rowTotal = 0;
                                        hubData.periods.sort().forEach(period => {
                                            const periodData = hubData.periodData[hub.id] && hubData.periodData[hub.id][period] ? 
                                                              hubData.periodData[hub.id][period].kcs : 0;
                                            rowTotal += periodData;
                                            const cellBg = periodData > 0 ? 'background: rgba(16, 185, 129, 0.1);' : '';
                                            rowHtml += `<td style="padding: 10px; text-align: right; ${cellBg}">${periodData > 0 ? periodData.toLocaleString() : '-'}</td>`;
                                        });
                                        
                                        rowHtml += `<td style="padding: 10px; text-align: right; font-weight: 600; background: #f0fdf4;">${rowTotal.toLocaleString()}</td>`;
                                        rowHtml += `</tr>`;
                                        return rowHtml;
                                    }).join('')}
                            </tbody>
                            <tfoot>
                                <tr style="background: #f1f5f9; font-weight: 600;">
                                    <td style="padding: 10px; border-top: 2px solid #e5e7eb; position: sticky; left: 0; background: #f1f5f9; z-index: 5;">Total</td>
                                    ${hubData.periods.sort().map(period => {
                                        let periodTotal = 0;
                                        Object.values(hubData.hubDetails).forEach(hub => {
                                            if (hubData.periodData[hub.id] && hubData.periodData[hub.id][period]) {
                                                periodTotal += hubData.periodData[hub.id][period].kcs;
                                            }
                                        });
                                        return `<td style="padding: 10px; text-align: right; border-top: 2px solid #e5e7eb;">${periodTotal.toLocaleString()}</td>`;
                                    }).join('')}
                                    <td style="padding: 10px; text-align: right; border-top: 2px solid #e5e7eb; background: #f0fdf4;">${hubData.totalKCs.toLocaleString()}</td>
                                </tr>
                            </tfoot>
                        </table>
                    </div>
                    <div style="margin-top: 15px; padding: 10px; background: #f0f9ff; border-radius: 8px; border-left: 3px solid #3b82f6;">
                        <p style="margin: 0; font-size: 0.85em; color: #1e40af;">
                            <strong>Reading the Tables:</strong>
                        </p>
                        <ul style="margin: 5px 0 0 20px; font-size: 0.8em; color: #3730a3;">
                            <li>Cells with values have colored backgrounds (blue for documents, green for KCs)</li>
                            <li>Dash (-) indicates no activity for that hub in that period</li>
                            <li>Tables are sorted by total volume (documents or KCs respectively)</li>
                            <li>Sticky columns allow scrolling through months while keeping Hub IDs visible</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>`;
        
        // Add chart initialization script
        html += this.generateHubDistributionCharts(hubData);
        html += this.generateHubTrendCharts(hubData);
        
        html += `</div>`;
        
        return html;
    }
    
    extractHubData(data) {
        const hubData = {
            uniqueHubs: new Set(),
            totalDocs: 0,
            totalKCs: 0,
            periods: [],
            avgConnections: 0,
            debugInfo: [],
            hubDetails: {}, // Store individual hub metrics
            periodData: {} // Store period-wise data for each hub
        };
        
        // Look for Hub_Summary sheet data
        if (data.tp_data) {
            Object.entries(data.tp_data).forEach(([period, periodData]) => {
                if (periodData['Hub_Summary']) {
                    if (!hubData.periods.includes(period)) {
                        hubData.periods.push(period);
                    }
                    const hubSummaryData = periodData['Hub_Summary'];
                    
                    if (Array.isArray(hubSummaryData)) {
                        // Debug: log first row to see column names
                        if (hubSummaryData.length > 0) {
                            hubData.debugInfo.push(`Period ${period}: Found ${hubSummaryData.length} rows`);
                            hubData.debugInfo.push(`Columns: ${Object.keys(hubSummaryData[0]).join(', ')}`);
                        }
                        
                        hubSummaryData.forEach(row => {
                            // Extract hub ID - check all possible column names including with spaces
                            const hubId = row['HUB ID'] || row['Hub ID'] || row['Hub_ID'] || row['HUB'] || row['Hub'] || row['HubID'] || row['hub id'];
                            
                            if (hubId && hubId.toString().trim() !== '') {
                                const hubKey = hubId.toString().trim();
                                
                                // Add to unique hubs set
                                hubData.uniqueHubs.add(hubKey);
                                
                                // Initialize hub details if not exists
                                if (!hubData.hubDetails[hubKey]) {
                                    hubData.hubDetails[hubKey] = {
                                        id: hubKey,
                                        docs: 0,
                                        kcs: 0
                                    };
                                }
                                
                                // Initialize period data for this hub
                                if (!hubData.periodData[hubKey]) {
                                    hubData.periodData[hubKey] = {};
                                }
                                if (!hubData.periodData[hubKey][period]) {
                                    hubData.periodData[hubKey][period] = {
                                        docs: 0,
                                        kcs: 0
                                    };
                                }
                                
                                // Sum up document counts - handle comma-separated numbers
                                const docCountStr = row['TOTAL-DOC'] || row['Total Docs'] || row['Documents'] || row['TOTAL_DOC'] || row['TotalDoc'] || '0';
                                const kcCountStr = row['TOTAL-KCS'] || row['Total KCs'] || row['KCs'] || row['TOTAL_KCS'] || row['TotalKCS'] || '0';
                                
                                // Remove commas and parse
                                const docCount = parseFloat(docCountStr.toString().replace(/,/g, ''));
                                const kcCount = parseFloat(kcCountStr.toString().replace(/,/g, ''));
                                
                                if (!isNaN(docCount)) {
                                    hubData.totalDocs += docCount;
                                    hubData.hubDetails[hubKey].docs += docCount;
                                    hubData.periodData[hubKey][period].docs += docCount;
                                }
                                if (!isNaN(kcCount)) {
                                    hubData.totalKCs += kcCount;
                                    hubData.hubDetails[hubKey].kcs += kcCount;
                                    hubData.periodData[hubKey][period].kcs += kcCount;
                                }
                            }
                        });
                    }
                }
            });
        }
        
        
        // Convert unique hubs to count
        hubData.hubCount = hubData.uniqueHubs.size;
        
        // If no Hub_Summary data found, return empty data
        if (hubData.hubCount === 0) {
            return null;
        }
        
        return hubData;
    }
    
    inferHubData(data) {
        // Original logic for inferring hubs when Hub_Summary is not available
        const partners = {};
        const connections = {};
        
        if (data.tp_data) {
            Object.entries(data.tp_data).forEach(([period, periodData]) => {
                Object.entries(periodData).forEach(([sheetName, sheetData]) => {
                    if (sheetName.includes('TP') && Array.isArray(sheetData)) {
                        sheetData.forEach(row => {
                            const tpId = row['TP ID'] || row['TP-ID'] || row['Trading Partner'] || row['TP_ID'] || row['TP'];
                            if (tpId) {
                                if (!partners[tpId]) {
                                    partners[tpId] = {
                                        id: tpId,
                                        volume: 0,
                                        connections: new Set(),
                                        periods: new Set()
                                    };
                                }
                                
                                const docCount = parseFloat(row['TOTAL-DOC'] || 0);
                                partners[tpId].volume += docCount;
                                partners[tpId].periods.add(period);
                                
                                Object.keys(row).forEach(key => {
                                    if (key.includes('DOC') && row[key] > 0) {
                                        if (!connections[key]) connections[key] = new Set();
                                        connections[key].add(tpId);
                                    }
                                });
                            }
                        });
                    }
                });
            });
        }
        
        Object.values(connections).forEach(connectedPartners => {
            const partnerList = Array.from(connectedPartners);
            partnerList.forEach((p1, i) => {
                partnerList.slice(i + 1).forEach(p2 => {
                    if (partners[p1] && partners[p2]) {
                        partners[p1].connections.add(p2);
                        partners[p2].connections.add(p1);
                    }
                });
            });
        });
        
        const partnerList = Object.values(partners).map(p => ({
            ...p,
            connections: p.connections.size,
            periods: p.periods.size
        }));
        
        const avgConnections = partnerList.length > 0 ? partnerList.reduce((sum, p) => sum + p.connections, 0) / partnerList.length : 0;
        const avgVolume = partnerList.length > 0 ? partnerList.reduce((sum, p) => sum + p.volume, 0) / partnerList.length : 0;
        
        const hubs = partnerList
            .filter(p => p.connections > avgConnections * 1.5 || p.volume > avgVolume * 2)
            .sort((a, b) => (b.connections * b.volume) - (a.connections * a.volume))
            .slice(0, 10);
        
        return {
            partners: partners,
            hubs: hubs,
            avgConnections: avgConnections,
            avgVolume: avgVolume,
            periods: []
        };
    }
    
    // REMOVED: generateTopHubsTable
    generateTopHubsTable(hubData) {
        let html = `
        <div style="margin-bottom: 30px;">
            <h4 style="color: #2d3748; margin-bottom: 20px;">🏆 Top Hub Partners</h4>
            <div style="overflow-x: auto;">
                <table style="width: 100%; border-collapse: collapse; background: white; border-radius: 8px; overflow: hidden;">
                    <thead>
                        <tr style="background: #f8fafc;">
                            <th style="padding: 12px; text-align: left; font-weight: 600; color: #2d3748;">Rank</th>
                            <th style="padding: 12px; text-align: left; font-weight: 600; color: #2d3748;">Hub Partner</th>
                            <th style="padding: 12px; text-align: right; font-weight: 600; color: #2d3748;">Documents</th>
                            <th style="padding: 12px; text-align: right; font-weight: 600; color: #2d3748;">Kilocharacters</th>
                            <th style="padding: 12px; text-align: right; font-weight: 600; color: #2d3748;">Connections</th>
                            <th style="padding: 12px; text-align: right; font-weight: 600; color: #2d3748;">Active Periods</th>
                            <th style="padding: 12px; text-align: center; font-weight: 600; color: #2d3748;">Hub Score</th>
                        </tr>
                    </thead>
                    <tbody>`;
        
        hubData.hubs.forEach((hub, index) => {
            // Calculate hub score based on documents and connections
            const connectionScore = hubData.avgConnections > 0 ? hub.connections / hubData.avgConnections : 1;
            const volumeScore = hubData.avgVolume > 0 ? hub.docCount / hubData.avgVolume : 1;
            const hubScore = (connectionScore * volumeScore).toFixed(2);
            const rowBg = index % 2 === 0 ? '#ffffff' : '#f9fafb';
            
            html += `
                        <tr style="background: ${rowBg}; border-bottom: 1px solid #e5e7eb;">
                            <td style="padding: 12px; font-weight: 600;">
                                <span style="background: #3b82f6; color: white; padding: 4px 8px; border-radius: 12px; font-size: 0.85em;">
                                    #${index + 1}
                                </span>
                            </td>
                            <td style="padding: 12px; font-weight: 500;">${hub.id}</td>
                            <td style="padding: 12px; text-align: right;">${(hub.docCount || 0).toLocaleString()}</td>
                            <td style="padding: 12px; text-align: right;">${(hub.kcCount || 0).toLocaleString()}</td>
                            <td style="padding: 12px; text-align: right;">${hub.connections}</td>
                            <td style="padding: 12px; text-align: right;">${hub.periods}</td>
                            <td style="padding: 12px; text-align: center;">
                                <span style="background: ${hubScore > 4 ? '#d1fae5' : hubScore > 2 ? '#fef3c7' : '#fee2e2'}; 
                                            color: ${hubScore > 4 ? '#065f46' : hubScore > 2 ? '#92400e' : '#991b1b'}; 
                                            padding: 4px 12px; border-radius: 12px; font-weight: 600;">
                                    ${hubScore}
                                </span>
                            </td>
                        </tr>`;
        });
        
        html += `
                    </tbody>
                </table>
            </div>
        </div>`;
        
        return html;
    }
    
    // REMOVED: generateHubPerformanceAnalysis
    generateHubPerformanceAnalysis(hubData, data) {
        // Add detailed metrics section if Hub_Summary data is available
        if (hubData.hubs.length === 0) {
            return '';
        }
        
        let html = `
        <div style="margin-bottom: 30px;">
            <h4 style="color: #2d3748; margin-bottom: 20px;">📈 Hub Performance Trends
                <span class="info-icon">i
                    <div class="tooltip">
                        Performance analysis tracks hub metrics over time.
                        Shows document and KC trends for each hub partner.
                        Based on data from Hub_Summary sheets in your Excel files.
                    </div>
                </span>
            </h4>
            <div style="display: grid; grid-template-columns: 1fr; gap: 20px;">`;
        
        // Hub Volume Trend Chart
        html += `
                <div style="background: linear-gradient(135deg, rgba(255, 255, 255, 0.5) 0%, rgba(249, 250, 251, 0.5) 100%); backdrop-filter: blur(10px); border: 1px solid rgba(229, 231, 235, 0.4); padding: 20px; border-radius: 10px; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.08);">
                    <h5 style="margin: 0 0 15px 0; color: #374151;">Hub Volume Distribution</h5>
                    <canvas id="hubVolumeChart" width="400" height="250"></canvas>
                </div>`;
        
        // Hub Growth Analysis
        const periods = Object.keys(data.summary || {}).sort();
        if (periods.length > 1) {
            html += `
                <div style="background: linear-gradient(135deg, rgba(219, 234, 254, 0.3) 0%, rgba(191, 219, 254, 0.3) 100%); backdrop-filter: blur(10px); border: 1px solid rgba(147, 197, 253, 0.4); padding: 20px; border-radius: 10px;">
                    <h5 style="margin: 0 0 15px 0; color: #1e40af;">Hub Growth Analysis</h5>
                    <p style="margin: 0 0 10px 0; color: #1e3a8a;">
                        Analyzing ${periods.length} periods from ${this.formatPeriodDisplay(periods[0])} to ${this.formatPeriodDisplay(periods[periods.length - 1])}
                    </p>
                    <p style="margin: 0; color: #1e3a8a; font-size: 0.9em;">
                        Total Hubs: ${hubData.hubs.length} | Total Documents: ${hubData.hubs.reduce((sum, h) => sum + h.docCount, 0).toLocaleString()} | Total KCs: ${hubData.hubs.reduce((sum, h) => sum + h.kcCount, 0).toLocaleString()}
                    </p>
                </div>`;
        }
        
        html += `
            </div>
        </div>`;
        
        return html;
    }
    
    // REMOVED: generateHubConnectivityMatrix
    generateHubConnectivityMatrix(hubData) {
        let html = `
        <div style="margin-bottom: 30px;">
            <h4 style="color: #2d3748; margin-bottom: 20px;">🔗 Hub Connectivity Insights</h4>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 15px;">`;
        
        // Connectivity insights
        const maxConnections = Math.max(...hubData.hubs.map(h => h.connections));
        const minConnections = Math.min(...hubData.hubs.map(h => h.connections));
        
        html += `
                <div style="background: linear-gradient(135deg, rgba(236, 72, 153, 0.3) 0%, rgba(219, 39, 119, 0.3) 100%); backdrop-filter: blur(8px); border: 1px solid rgba(236, 72, 153, 0.4); padding: 15px; border-radius: 8px;">
                    <h6 style="margin: 0 0 10px 0; color: #9d174d;">Connection Range</h6>
                    <p style="margin: 0; color: #831843; font-size: 1.2em; font-weight: 600;">
                        ${minConnections} - ${maxConnections} partners
                    </p>
                </div>`;
        
        // Network density
        const totalPossibleConnections = Object.keys(hubData.partners).length * (Object.keys(hubData.partners).length - 1) / 2;
        const actualConnections = Object.values(hubData.partners).reduce((sum, p) => sum + p.connections.size, 0) / 2;
        const density = totalPossibleConnections > 0 ? (actualConnections / totalPossibleConnections * 100).toFixed(1) : 0;
        
        html += `
                <div style="background: linear-gradient(135deg, rgba(251, 146, 60, 0.3) 0%, rgba(234, 88, 12, 0.3) 100%); backdrop-filter: blur(8px); border: 1px solid rgba(251, 146, 60, 0.4); padding: 15px; border-radius: 8px;">
                    <h6 style="margin: 0 0 10px 0; color: #9a3412;">Network Density</h6>
                    <p style="margin: 0; color: #7c2d12; font-size: 1.2em; font-weight: 600;">
                        ${density}%
                    </p>
                </div>`;
        
        html += `
            </div>
        </div>`;
        
        return html;
    }
    
    generateHubDistributionCharts(hubData) {
        // Prepare data for charts
        const hubLabels = [];
        const docData = [];
        const kcData = [];
        
        // Sort hubs by document count and take top 10 for better visibility
        const sortedHubs = Object.values(hubData.hubDetails)
            .sort((a, b) => b.docs - a.docs)
            .slice(0, 10);
        
        sortedHubs.forEach(hub => {
            hubLabels.push(hub.id);
            docData.push(hub.docs);
            kcData.push(hub.kcs);
        });
        
        // Add "Others" category if there are more than 10 hubs
        if (Object.keys(hubData.hubDetails).length > 10) {
            const othersDoc = hubData.totalDocs - docData.reduce((sum, val) => sum + val, 0);
            const othersKc = hubData.totalKCs - kcData.reduce((sum, val) => sum + val, 0);
            
            if (othersDoc > 0) {
                hubLabels.push('Others');
                docData.push(othersDoc);
                kcData.push(othersKc);
            }
        }
        
        // Generate colors for the pie charts
        const colors = [
            'rgba(59, 130, 246, 0.8)',   // Blue
            'rgba(16, 185, 129, 0.8)',   // Green
            'rgba(245, 158, 11, 0.8)',   // Amber
            'rgba(239, 68, 68, 0.8)',    // Red
            'rgba(139, 92, 246, 0.8)',   // Purple
            'rgba(236, 72, 153, 0.8)',   // Pink
            'rgba(34, 197, 94, 0.8)',    // Emerald
            'rgba(251, 146, 60, 0.8)',   // Orange
            'rgba(14, 165, 233, 0.8)',   // Sky
            'rgba(168, 85, 247, 0.8)',   // Violet
            'rgba(156, 163, 175, 0.8)'   // Gray for Others
        ];
        
        return `
        <script>
        setTimeout(() => {
            // Document Distribution Pie Chart
            const docCtx = document.getElementById('hubDocDistributionChart');
            if (docCtx) {
                new Chart(docCtx.getContext('2d'), {
                    type: 'pie',
                    data: {
                        labels: ${JSON.stringify(hubLabels)},
                        datasets: [{
                            data: ${JSON.stringify(docData)},
                            backgroundColor: ${JSON.stringify(colors.slice(0, hubLabels.length))},
                            borderColor: 'rgba(255, 255, 255, 0.8)',
                            borderWidth: 2
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                position: 'right',
                                labels: {
                                    padding: 10,
                                    font: {
                                        size: 11
                                    },
                                    generateLabels: function(chart) {
                                        const data = chart.data;
                                        if (data.labels.length && data.datasets.length) {
                                            const dataset = data.datasets[0];
                                            const total = dataset.data.reduce((sum, val) => sum + val, 0);
                                            return data.labels.map((label, i) => {
                                                const value = dataset.data[i];
                                                const percentage = ((value / total) * 100).toFixed(1);
                                                return {
                                                    text: label + ': ' + percentage + '%',
                                                    fillStyle: dataset.backgroundColor[i],
                                                    hidden: false,
                                                    index: i
                                                };
                                            });
                                        }
                                        return [];
                                    }
                                }
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        const label = context.label || '';
                                        const value = context.parsed;
                                        const total = context.dataset.data.reduce((sum, val) => sum + val, 0);
                                        const percentage = ((value / total) * 100).toFixed(1);
                                        return label + ': ' + value.toLocaleString() + ' docs (' + percentage + '%)';
                                    }
                                }
                            }
                        }
                    }
                });
            }
            
            // KC Distribution Pie Chart
            const kcCtx = document.getElementById('hubKcDistributionChart');
            if (kcCtx) {
                new Chart(kcCtx.getContext('2d'), {
                    type: 'pie',
                    data: {
                        labels: ${JSON.stringify(hubLabels)},
                        datasets: [{
                            data: ${JSON.stringify(kcData)},
                            backgroundColor: ${JSON.stringify(colors.slice(0, hubLabels.length))},
                            borderColor: 'rgba(255, 255, 255, 0.8)',
                            borderWidth: 2
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                position: 'right',
                                labels: {
                                    padding: 10,
                                    font: {
                                        size: 11
                                    },
                                    generateLabels: function(chart) {
                                        const data = chart.data;
                                        if (data.labels.length && data.datasets.length) {
                                            const dataset = data.datasets[0];
                                            const total = dataset.data.reduce((sum, val) => sum + val, 0);
                                            return data.labels.map((label, i) => {
                                                const value = dataset.data[i];
                                                const percentage = ((value / total) * 100).toFixed(1);
                                                return {
                                                    text: label + ': ' + percentage + '%',
                                                    fillStyle: dataset.backgroundColor[i],
                                                    hidden: false,
                                                    index: i
                                                };
                                            });
                                        }
                                        return [];
                                    }
                                }
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        const label = context.label || '';
                                        const value = context.parsed;
                                        const total = context.dataset.data.reduce((sum, val) => sum + val, 0);
                                        const percentage = ((value / total) * 100).toFixed(1);
                                        return label + ': ' + value.toLocaleString() + ' KCs (' + percentage + '%)';
                                    }
                                }
                            }
                        }
                    }
                });
            }
        }, 100);
        </scr` + `ipt>`;
    }
    
    generateHubTrendCharts(hubData) {
        // Prepare data for trend charts
        const periods = hubData.periods.sort();
        const hubColors = [
            'rgba(59, 130, 246, 0.8)',   // Blue
            'rgba(16, 185, 129, 0.8)',   // Green
            'rgba(245, 158, 11, 0.8)',   // Amber
            'rgba(239, 68, 68, 0.8)',    // Red
            'rgba(139, 92, 246, 0.8)',   // Purple
            'rgba(236, 72, 153, 0.8)',   // Pink
            'rgba(34, 197, 94, 0.8)',    // Emerald
            'rgba(251, 146, 60, 0.8)',   // Orange
            'rgba(14, 165, 233, 0.8)',   // Sky
            'rgba(168, 85, 247, 0.8)'    // Violet
        ];
        
        // Format periods for display
        const formattedPeriods = periods.map(p => this.formatPeriodDisplay(p));
        
        // Store hub data globally for filter updates
        const globalHubData = {
            periods: periods,
            formattedPeriods: formattedPeriods,
            periodData: hubData.periodData,
            hubDetails: hubData.hubDetails,
            colors: hubColors
        };
        
        return `
        <script>
        // Store hub data for filter updates
        window.hubTrendData = ${JSON.stringify(globalHubData)};
        
        function updateHubTrendCharts() {
            const selectedHubs = Array.from(document.getElementById('hubTrendFilter').selectedOptions).map(opt => opt.value);
            
            if (selectedHubs.length === 0) {
                alert('Please select at least one hub');
                return;
            }
            
            // Update Document Trend Chart
            const docChart = Chart.getChart('hubDocTrendChart');
            if (docChart) {
                const datasets = selectedHubs.map((hubId, index) => {
                    const data = window.hubTrendData.periods.map(period => 
                        window.hubTrendData.periodData[hubId] && window.hubTrendData.periodData[hubId][period] ?
                        window.hubTrendData.periodData[hubId][period].docs : 0
                    );
                    
                    return {
                        label: hubId,
                        data: data,
                        borderColor: window.hubTrendData.colors[index % window.hubTrendData.colors.length],
                        backgroundColor: window.hubTrendData.colors[index % window.hubTrendData.colors.length].replace('0.8', '0.2'),
                        borderWidth: 2,
                        tension: 0.1
                    };
                });
                
                docChart.data.datasets = datasets;
                docChart.update();
            }
            
            // Update KC Trend Chart
            const kcChart = Chart.getChart('hubKcTrendChart');
            if (kcChart) {
                const datasets = selectedHubs.map((hubId, index) => {
                    const data = window.hubTrendData.periods.map(period => 
                        window.hubTrendData.periodData[hubId] && window.hubTrendData.periodData[hubId][period] ?
                        window.hubTrendData.periodData[hubId][period].kcs : 0
                    );
                    
                    return {
                        label: hubId,
                        data: data,
                        borderColor: window.hubTrendData.colors[index % window.hubTrendData.colors.length],
                        backgroundColor: window.hubTrendData.colors[index % window.hubTrendData.colors.length].replace('0.8', '0.2'),
                        borderWidth: 2,
                        tension: 0.1
                    };
                });
                
                kcChart.data.datasets = datasets;
                kcChart.update();
            }
        }
        
        setTimeout(() => {
            // Initialize Document Trend Chart
            const docCtx = document.getElementById('hubDocTrendChart');
            if (docCtx) {
                const initialHubs = Object.keys(window.hubTrendData.hubDetails).slice(0, 5); // Show top 5 by default
                
                new Chart(docCtx.getContext('2d'), {
                    type: 'line',
                    data: {
                        labels: ${JSON.stringify(formattedPeriods)},
                        datasets: initialHubs.map((hubId, index) => {
                            const data = window.hubTrendData.periods.map(period => 
                                window.hubTrendData.periodData[hubId] && window.hubTrendData.periodData[hubId][period] ?
                                window.hubTrendData.periodData[hubId][period].docs : 0
                            );
                            
                            return {
                                label: hubId,
                                data: data,
                                borderColor: window.hubTrendData.colors[index % window.hubTrendData.colors.length],
                                backgroundColor: window.hubTrendData.colors[index % window.hubTrendData.colors.length].replace('0.8', '0.2'),
                                borderWidth: 2,
                                tension: 0.1
                            };
                        })
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            mode: 'index',
                            intersect: false
                        },
                        plugins: {
                            legend: {
                                position: 'top',
                                labels: {
                                    font: {
                                        size: 11
                                    }
                                }
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        return context.dataset.label + ': ' + context.parsed.y.toLocaleString() + ' documents';
                                    }
                                }
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: 'Documents'
                                },
                                ticks: {
                                    callback: function(value) {
                                        return value.toLocaleString();
                                    }
                                }
                            },
                            x: {
                                title: {
                                    display: true,
                                    text: 'Period'
                                }
                            }
                        }
                    }
                });
            }
            
            // Initialize KC Trend Chart
            const kcCtx = document.getElementById('hubKcTrendChart');
            if (kcCtx) {
                const initialHubs = Object.keys(window.hubTrendData.hubDetails).slice(0, 5); // Show top 5 by default
                
                new Chart(kcCtx.getContext('2d'), {
                    type: 'line',
                    data: {
                        labels: ${JSON.stringify(formattedPeriods)},
                        datasets: initialHubs.map((hubId, index) => {
                            const data = window.hubTrendData.periods.map(period => 
                                window.hubTrendData.periodData[hubId] && window.hubTrendData.periodData[hubId][period] ?
                                window.hubTrendData.periodData[hubId][period].kcs : 0
                            );
                            
                            return {
                                label: hubId,
                                data: data,
                                borderColor: window.hubTrendData.colors[index % window.hubTrendData.colors.length],
                                backgroundColor: window.hubTrendData.colors[index % window.hubTrendData.colors.length].replace('0.8', '0.2'),
                                borderWidth: 2,
                                tension: 0.1
                            };
                        })
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            mode: 'index',
                            intersect: false
                        },
                        plugins: {
                            legend: {
                                position: 'top',
                                labels: {
                                    font: {
                                        size: 11
                                    }
                                }
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        return context.dataset.label + ': ' + context.parsed.y.toLocaleString() + ' KCs';
                                    }
                                }
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: 'Kilocharacters'
                                },
                                ticks: {
                                    callback: function(value) {
                                        return value.toLocaleString();
                                    }
                                }
                            },
                            x: {
                                title: {
                                    display: true,
                                    text: 'Period'
                                }
                            }
                        }
                    }
                });
            }
            
            // Auto-select top 5 hubs in the filter
            const filter = document.getElementById('hubTrendFilter');
            if (filter) {
                const options = filter.options;
                for (let i = 0; i < options.length; i++) {
                    options[i].selected = i < 5;
                }
            }
        }, 100);
        </scr` + `ipt>`;
    }
    
    // REMOVED: generateHubNetworkScript
    generateHubNetworkScript(hubData) {
        return `
        <script>
        setTimeout(() => {
            // Hub Volume Chart
            const volumeCtx = document.getElementById('hubVolumeChart');
            if (volumeCtx) {
                new Chart(volumeCtx.getContext('2d'), {
                    type: 'bar',
                    data: {
                        labels: ${JSON.stringify(hubData.hubs.slice(0, 10).map(h => h.id))},
                        datasets: [{
                            label: 'Documents',
                            data: ${JSON.stringify(hubData.hubs.slice(0, 10).map(h => h.docCount))},
                            backgroundColor: 'rgba(59, 130, 246, 0.6)',
                            borderColor: 'rgba(59, 130, 246, 1)',
                            borderWidth: 1
                        },
                        {
                            label: 'Kilocharacters',
                            data: ${JSON.stringify(hubData.hubs.slice(0, 10).map(h => h.kcCount))},
                            backgroundColor: 'rgba(16, 185, 129, 0.6)',
                            borderColor: 'rgba(16, 185, 129, 1)',
                            borderWidth: 1,
                            yAxisID: 'y1'
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                type: 'linear',
                                display: true,
                                position: 'left',
                                title: {
                                    display: true,
                                    text: 'Documents'
                                },
                                beginAtZero: true,
                                ticks: {
                                    callback: function(value) {
                                        return value.toLocaleString();
                                    }
                                }
                            },
                            y1: {
                                type: 'linear',
                                display: true,
                                position: 'right',
                                title: {
                                    display: true,
                                    text: 'Kilocharacters'
                                },
                                beginAtZero: true,
                                grid: {
                                    drawOnChartArea: false
                                },
                                ticks: {
                                    callback: function(value) {
                                        return value.toLocaleString();
                                    }
                                }
                            }
                        }
                    }
                });
            }
            
            // Network Visualization
            const networkCtx = document.getElementById('hubNetworkChart');
            if (networkCtx) {
                const ctx = networkCtx.getContext('2d');
                
                // Simple network visualization
                const width = networkCtx.width;
                const height = networkCtx.height;
                const centerX = width / 2;
                const centerY = height / 2;
                const radius = Math.min(width, height) / 3;
                
                // Draw hub nodes
                const hubCount = ${hubData.hubs.length};
                const angleStep = (2 * Math.PI) / hubCount;
                
                ctx.clearRect(0, 0, width, height);
                
                // Draw connections
                ctx.strokeStyle = 'rgba(156, 163, 175, 0.3)';
                ctx.lineWidth = 1;
                
                ${JSON.stringify(hubData.hubs)}.forEach((hub, i) => {
                    const x1 = centerX + radius * Math.cos(i * angleStep);
                    const y1 = centerY + radius * Math.sin(i * angleStep);
                    
                    // Draw connections to center
                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(centerX, centerY);
                    ctx.stroke();
                });
                
                // Draw hub nodes
                ${JSON.stringify(hubData.hubs)}.forEach((hub, i) => {
                    const x = centerX + radius * Math.cos(i * angleStep);
                    const y = centerY + radius * Math.sin(i * angleStep);
                    const nodeSize = 10 + (hub.connections / 2);
                    
                    // Node
                    ctx.fillStyle = 'rgba(59, 130, 246, 0.8)';
                    ctx.beginPath();
                    ctx.arc(x, y, nodeSize, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    // Label
                    ctx.fillStyle = '#1e293b';
                    ctx.font = '12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(hub.id, x, y - nodeSize - 5);
                });
                
                // Center node
                ctx.fillStyle = 'rgba(239, 68, 68, 0.8)';
                ctx.beginPath();
                ctx.arc(centerX, centerY, 15, 0, 2 * Math.PI);
                ctx.fill();
                
                ctx.fillStyle = 'white';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('HUB', centerX, centerY);
            }
        }, 100);
        </scr` + `ipt>`;
    }
    
    formatCurrency(value, short = false) {
        if (short && value >= 1000000) {
            return `$${(value / 1000000).toFixed(1)}M`;
        } else if (short && value >= 1000) {
            return `$${(value / 1000).toFixed(1)}K`;
        }
        return `$${value.toLocaleString()}`;
    }
    
    getChartColor(index, alpha = 1) {
        const colors = [
            `rgba(59, 130, 246, ${alpha})`,  // Blue
            `rgba(16, 185, 129, ${alpha})`,  // Green
            `rgba(245, 158, 11, ${alpha})`,  // Amber
            `rgba(239, 68, 68, ${alpha})`,   // Red
            `rgba(139, 92, 246, ${alpha})`,  // Purple
            `rgba(236, 72, 153, ${alpha})`,  // Pink
            `rgba(14, 165, 233, ${alpha})`,  // Sky
            `rgba(168, 85, 247, ${alpha})`   // Violet
        ];
        return colors[index % colors.length];
    }
    
    formatAIInsights(insights) {
        // Convert markdown-style formatting to HTML
        let formatted = insights
            .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
            .replace(/\*(.+?)\*/g, '<em>$1</em>')
            .replace(/^##\s+(.+)$/gm, '<h2>$1</h2>')
            .replace(/^###\s+(.+)$/gm, '<h3>$1</h3>')
            .replace(/^-\s+(.+)$/gm, '<li>$1</li>')
            .replace(/^(\d+)\.\s+(.+)$/gm, '<li>$2</li>')
            .replace(/(<li>.*<\/li>\n?)+/g, '<ul>$&</ul>')
            .replace(/\n\n/g, '</p><p>')
            .replace(/^/, '<p>')
            .replace(/$/, '</p>');
        
        return formatted;
    }
    
    formatMonthlyChanges(periods, volumes) {
        if (volumes.length < 2) {
            return "Insufficient data";
        }
        
        const changes = [];
        for (let i = 1; i < volumes.length; i++) {
            if (i < periods.length) {
                const period = this.formatPeriodDisplay(periods[i]);
                if (volumes[i-1] > 0) {
                    const change = ((volumes[i] - volumes[i-1]) / volumes[i-1]) * 100;
                    changes.push(`\u2022 ${period}: ${change >= 0 ? '+' : ''}${change.toFixed(1)}%`);
                } else {
                    changes.push(`\u2022 ${period}: N/A`);
                }
            }
        }
        
        return changes.join('<br>') || "No changes to display";
    }
    
    calculatePeriodTotal(data, periods, metric) {
        let total = 0;
        
        if (data.trends && data.trends.Date_Summary) {
            const trends = data.trends.Date_Summary;
            if (trends.metric_trends && trends.metric_trends[metric]) {
                const values = trends.metric_trends[metric];
                const trendPeriods = trends.periods;
                
                for (const period of periods) {
                    const idx = trendPeriods.indexOf(period);
                    if (idx >= 0 && idx < values.length) {
                        total += values[idx] || 0;
                    }
                }
            }
        }
        
        return total;
    }
    
    generateMonthlyComparison(data, periods) {
        if (periods.length < 2) {
            return "";
        }
        
        let html = `
        <div style="margin-bottom: 40px;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                <h4 style="color: #2d3748; margin: 0;">\ud83d\udcca Summary Metrics Comparison
                    <span class="info-icon">i
                        <div class="tooltip">
                            This table shows monthly document and kilocharacter (KC) totals from Date_Summary sheets.
                            Documents are counted by summing all columns containing 'DOC' in their name.
                            Month-over-month percentage changes and efficiency ratios (Docs/KC) are calculated automatically.
                            Data comes from the TOTAL-DOC and TOTAL-KCS columns in your Date_Summary sheets.
                        </div>
                    </span>
                </h4>
                <div style="display: flex; gap: 10px;">
                    <button onclick="exportTableData('summary-metrics', 'json')" style="
                        background: #3182ce;
                        color: white;
                        border: none;
                        padding: 8px 16px;
                        border-radius: 5px;
                        cursor: pointer;
                        font-size: 14px;
                        transition: background 0.2s;
                    " onmouseover="this.style.background='#2563eb'" onmouseout="this.style.background='#3182ce'">
                        📥 Export JSON
                    </button>
                    <button onclick="exportTableData('summary-metrics', 'csv')" style="
                        background: #16a34a;
                        color: white;
                        border: none;
                        padding: 8px 16px;
                        border-radius: 5px;
                        cursor: pointer;
                        font-size: 14px;
                        transition: background 0.2s;
                    " onmouseover="this.style.background='#15803d'" onmouseout="this.style.background='#16a34a'">
                        📥 Export CSV
                    </button>
                </div>
            </div>
            <div style="overflow-x: auto; border: 1px solid #e5e7eb; border-radius: 8px;">
                <table class="monthly-table" style="width: 100%; border-collapse: collapse;">
                    <thead>
                        <tr style="background: #f8fafc;">
                            <th style="padding: 12px; text-align: left; font-weight: 600; color: #2d3748; border-bottom: 2px solid #e2e8f0;">Period</th>
                            <th style="padding: 12px; text-align: right; font-weight: 600; color: #2d3748; border-bottom: 2px solid #e2e8f0;">Total Documents</th>
                            <th style="padding: 12px; text-align: right; font-weight: 600; color: #2d3748; border-bottom: 2px solid #e2e8f0;">Total KCs</th>
                            <th style="padding: 12px; text-align: center; font-weight: 600; color: #2d3748; border-bottom: 2px solid #e2e8f0;">Docs Change</th>
                            <th style="padding: 12px; text-align: center; font-weight: 600; color: #2d3748; border-bottom: 2px solid #e2e8f0;">KCs Change</th>
                            <th style="padding: 12px; text-align: right; font-weight: 600; color: #2d3748; border-bottom: 2px solid #e2e8f0;">Efficiency (Docs/KC)</th>
                        </tr>
                    </thead>
                    <tbody>`;
        
        // Get data for each period
        const periodData = [];
        
        for (const period of periods) {
            let docs = 0;
            let kcs = 0;
            
            // First try Date_Summary trends
            if (data.trends && data.trends.Date_Summary) {
                const trends = data.trends.Date_Summary;
                if (trends.metric_trends && trends.periods) {
                    const idx = trends.periods.indexOf(period);
                    if (idx >= 0) {
                        docs = (trends.metric_trends['TOTAL-DOC'] || [])[idx] || 0;
                        kcs = (trends.metric_trends['TOTAL-KCS'] || [])[idx] || 0;
                    }
                }
            }
            
            // If no data found, try raw Date_Summary data
            if (docs === 0 && data.tp_data && data.tp_data[period] && data.tp_data[period]['Date_Summary']) {
                const dateSummaryData = data.tp_data[period]['Date_Summary'];
                if (Array.isArray(dateSummaryData) && dateSummaryData.length > 0) {
                    const row = dateSummaryData[0];
                    docs = parseFloat(row['TOTAL-DOC'] || 0);
                    kcs = parseFloat(row['TOTAL-KCS'] || 0);
                }
            }
            
            // If still no data, try TP_Summary trends
            if (docs === 0 && data.trends && data.trends.TP_Summary) {
                const trends = data.trends.TP_Summary;
                if (trends.metric_trends && trends.periods) {
                    const idx = trends.periods.indexOf(period);
                    if (idx >= 0) {
                        docs = (trends.metric_trends['TOTAL-DOC'] || [])[idx] || 0;
                        kcs = (trends.metric_trends['TOTAL-KCS'] || [])[idx] || 0;
                    }
                }
            }
            
            // If still no data, try Doc_Summary totals
            if (docs === 0 && data.trends && data.trends.Doc_Summary) {
                const trends = data.trends.Doc_Summary;
                if (trends.metric_trends && trends.periods) {
                    const idx = trends.periods.indexOf(period);
                    if (idx >= 0) {
                        docs = (trends.metric_trends['TOTAL-DOC'] || [])[idx] || 0;
                        kcs = (trends.metric_trends['TOTAL-KCS'] || [])[idx] || 0;
                    }
                }
            }
            
            // If still no data, try to get from docData (document extraction)
            if (docs === 0 && data.docData && data.docData[period]) {
                const periodDocData = data.docData[period];
                if (periodDocData && periodDocData.documents_by_tp) {
                    docs = Object.values(periodDocData.documents_by_tp).reduce((sum, tp) => sum + tp.total_docs, 0);
                    kcs = Object.values(periodDocData.documents_by_tp).reduce((sum, tp) => sum + tp.total_kcs, 0);
                }
            }
            
            
            periodData.push({ period, docs, kcs });
        }
        
        // Generate rows
        for (let i = 0; i < periodData.length; i++) {
            const current = periodData[i];
            const prev = i > 0 ? periodData[i-1] : null;
            
            const docChange = prev && prev.docs > 0 ? 
                ((current.docs - prev.docs) / prev.docs * 100) : 0;
            const kcChange = prev && prev.kcs > 0 ? 
                ((current.kcs - prev.kcs) / prev.kcs * 100) : 0;
            const efficiency = current.kcs > 0 ? current.docs / current.kcs : 0;
            
            const isCurrentMonth = i === periodData.length - 1;
            
            const rowBg = isCurrentMonth ? '#eff6ff' : (i % 2 === 0 ? '#ffffff' : '#f9fafb');
            const docChangeColor = docChange > 5 ? '#059669' : docChange < -5 ? '#dc2626' : '#6b7280';
            const kcChangeColor = kcChange > 5 ? '#059669' : kcChange < -5 ? '#dc2626' : '#6b7280';
            const docChangeBg = docChange > 10 ? '#d1fae5' : docChange > 5 ? '#ecfdf5' : 
                               docChange < -10 ? '#fee2e2' : docChange < -5 ? '#fef2f2' : '';
            const kcChangeBg = kcChange > 10 ? '#d1fae5' : kcChange > 5 ? '#ecfdf5' : 
                              kcChange < -10 ? '#fee2e2' : kcChange < -5 ? '#fef2f2' : '';
            
            html += `
                <tr style="background: ${rowBg}; border-bottom: 1px solid #e5e7eb;">
                    <td style="padding: 12px; font-weight: ${isCurrentMonth ? '600' : '400'};">
                        ${isCurrentMonth ? 
                            `<span style="background: #3b82f6; color: white; padding: 4px 12px; border-radius: 16px; font-size: 0.85em;">
                                ${this.formatPeriodDisplay(current.period)}
                            </span>` : 
                            this.formatPeriodDisplay(current.period)
                        }
                    </td>
                    <td style="padding: 12px; text-align: right; font-weight: ${isCurrentMonth ? '600' : '400'};">
                        ${current.docs.toLocaleString()}
                    </td>
                    <td style="padding: 12px; text-align: right; font-weight: ${isCurrentMonth ? '600' : '400'};">
                        ${current.kcs.toLocaleString()}
                    </td>
                    <td style="padding: 12px; text-align: center; background: ${docChangeBg};">
                        ${i > 0 ? 
                            `<span style="color: ${docChangeColor}; font-weight: 600;">
                                ${docChange >= 0 ? '↑' : '↓'} ${Math.abs(docChange).toFixed(1)}%
                            </span>` : 
                            '<span style="color: #9ca3af;">-</span>'
                        }
                    </td>
                    <td style="padding: 12px; text-align: center; background: ${kcChangeBg};">
                        ${i > 0 ? 
                            `<span style="color: ${kcChangeColor}; font-weight: 600;">
                                ${kcChange >= 0 ? '↑' : '↓'} ${Math.abs(kcChange).toFixed(1)}%
                            </span>` : 
                            '<span style="color: #9ca3af;">-</span>'
                        }
                    </td>
                    <td style="padding: 12px; text-align: right;">
                        ${efficiency.toFixed(2)}
                    </td>
                </tr>`;
        }
        
        html += `
                    </tbody>
                </table>
            </div>
        </div>`;
        return html;
    }
    
    generateTPMonthlyPerformance(data, periods) {
        // Extract TP monthly data
        const tpMonthlyData = {};
        
        if (data.tp_data) {
            for (const period of periods) {
                if (data.tp_data[period]) {
                    for (const [sheetName, sheetRows] of Object.entries(data.tp_data[period])) {
                        // Only use TP_Summary to avoid double counting
                        if (sheetName === 'TP_Summary') {
                            for (const row of sheetRows) {
                                // Extract TP ID
                                let tpId = null;
                                let totalDocs = 0;
                                let totalKcs = 0;
                                
                                for (const [key, value] of Object.entries(row)) {
                                    const keyStripped = key.trim();
                                    if (['TP ID', 'TP-ID', 'Trading Partner', 'TP_ID', 'TP'].includes(keyStripped)) {
                                        tpId = String(value || '').trim();
                                    } else if (keyStripped === 'TOTAL-DOC') {
                                        totalDocs = parseFloat(value) || 0;
                                    } else if (keyStripped === 'TOTAL-KCS') {
                                        totalKcs = parseFloat(value) || 0;
                                    }
                                }
                                
                                if (tpId) {
                                    if (!tpMonthlyData[tpId]) {
                                        tpMonthlyData[tpId] = {};
                                    }
                                    if (!tpMonthlyData[tpId][period]) {
                                        tpMonthlyData[tpId][period] = {docs: 0, kcs: 0};
                                    }
                                    
                                    tpMonthlyData[tpId][period].docs += totalDocs;
                                    tpMonthlyData[tpId][period].kcs += totalKcs;
                                }
                            }
                        }
                    }
                }
            }
        }
        
        // Calculate total volume per TP
        const tpTotals = {};
        for (const [tpId, monthlyData] of Object.entries(tpMonthlyData)) {
            const total = Object.values(monthlyData).reduce((sum, data) => sum + (data.docs || 0), 0);
            tpTotals[tpId] = total;
        }
        
        // Get all TPs sorted by volume
        const allTps = Object.entries(tpTotals).sort((a, b) => b[1] - a[1]);
        
        let html = `
        <div style="margin-bottom: 40px;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                <h4 style="color: #2d3748; margin: 0;">\ud83e\udd1d All Trading Partners - Monthly Performance
                    <span class="info-icon">i
                        <div class="tooltip">
                            This table shows document volumes for each trading partner across all available periods.
                            Growth percentages are calculated as average month-over-month changes.
                            Trading partners are sorted by total document volume in descending order.
                            Use this to identify your most active partners and track their trends.
                        </div>
                    </span>
                </h4>
                <div style="display: flex; gap: 10px;">
                    <button onclick="exportTableData('tp-monthly-docs', 'json')" style="
                        background: #3182ce;
                        color: white;
                        border: none;
                        padding: 8px 16px;
                        border-radius: 5px;
                        cursor: pointer;
                        font-size: 14px;
                        transition: background 0.2s;
                    " onmouseover="this.style.background='#2563eb'" onmouseout="this.style.background='#3182ce'">
                        📥 Export JSON
                    </button>
                    <button onclick="exportTableData('tp-monthly-docs', 'csv')" style="
                        background: #16a34a;
                        color: white;
                        border: none;
                        padding: 8px 16px;
                        border-radius: 5px;
                        cursor: pointer;
                        font-size: 14px;
                        transition: background 0.2s;
                    " onmouseover="this.style.background='#15803d'" onmouseout="this.style.background='#16a34a'">
                        📥 Export CSV
                    </button>
                </div>
            </div>
            <div style="overflow-x: auto; max-height: 600px;">
            <table class="monthly-table">
                <thead style="position: sticky; top: 0; z-index: 20;">
                    <tr>
                        <th style="position: sticky; left: 0; background: #f7fafc; z-index: 21;">Trading Partner</th>`;
        
        // Add period headers
        for (const period of periods) {
            html += `<th style="text-align: center; background: #f7fafc;">${this.formatPeriodDisplay(period)}</th>`;
        }
        
        html += `<th style="background: #e6f7ff;">Total</th>
                    </tr>
                </thead>
                <tbody>`;
        
        // Add TP rows - show all trading partners
        for (let i = 0; i < allTps.length; i++) {
            const [tpId, totalVolume] = allTps[i];
            html += `
                <tr>
                    <td style="position: sticky; left: 0; background: white; z-index: 5;">
                        <strong>${tpId}</strong>
                    </td>`;
            
            // Add monthly data
            for (const period of periods) {
                if (tpMonthlyData[tpId] && tpMonthlyData[tpId][period]) {
                    const value = tpMonthlyData[tpId][period].docs;
                    
                    // Add visual indicator for high/low values
                    if (value > 0) {
                        const monthlyValues = Object.values(tpMonthlyData[tpId])
                            .map(d => d.docs)
                            .filter(v => v > 0);
                        const maxVal = Math.max(...monthlyValues);
                        const minVal = Math.min(...monthlyValues);
                        
                        if (value === maxVal) {
                            html += `<td style="background: #d4f8d4;">${value.toLocaleString()}</td>`;
                        } else if (value === minVal) {
                            html += `<td style="background: #ffe6e6;">${value.toLocaleString()}</td>`;
                        } else {
                            html += `<td>${value.toLocaleString()}</td>`;
                        }
                    } else {
                        html += '<td>-</td>';
                    }
                } else {
                    html += '<td>-</td>';
                }
            }
            
            // Add total
            html += `<td style="background: #e6f7ff; font-weight: 600;">${totalVolume.toLocaleString()}</td>
            </tr>`;
        }
        
        
        html += `
                </tbody>
            </table>
            </div>
        </div>`;
        return html;
    }
    
    generateTPMonthlyPerformanceKCs(data, periods) {
        // Similar to generateTPMonthlyPerformance but for KCs
        // Extract TP monthly data
        const tpMonthlyData = {};
        
        if (data.tp_data) {
            for (const period of periods) {
                if (data.tp_data[period]) {
                    for (const [sheetName, sheetRows] of Object.entries(data.tp_data[period])) {
                        // Only use TP_Summary to avoid double counting
                        if (sheetName === 'TP_Summary') {
                            for (const row of sheetRows) {
                                // Extract TP ID
                                let tpId = null;
                                let totalDocs = 0;
                                let totalKcs = 0;
                                
                                for (const [key, value] of Object.entries(row)) {
                                    const keyStripped = key.trim();
                                    if (['TP ID', 'TP-ID', 'Trading Partner', 'TP_ID', 'TP'].includes(keyStripped)) {
                                        tpId = String(value || '').trim();
                                    } else if (keyStripped === 'TOTAL-DOC') {
                                        totalDocs = parseFloat(value) || 0;
                                    } else if (keyStripped === 'TOTAL-KCS') {
                                        totalKcs = parseFloat(value) || 0;
                                    }
                                }
                                
                                if (tpId) {
                                    if (!tpMonthlyData[tpId]) {
                                        tpMonthlyData[tpId] = {};
                                    }
                                    if (!tpMonthlyData[tpId][period]) {
                                        tpMonthlyData[tpId][period] = {docs: 0, kcs: 0};
                                    }
                                    
                                    tpMonthlyData[tpId][period].docs += totalDocs;
                                    tpMonthlyData[tpId][period].kcs += totalKcs;
                                }
                            }
                        }
                    }
                }
            }
        }
        
        // Calculate total KC volume per TP
        const tpTotals = {};
        for (const [tpId, monthlyData] of Object.entries(tpMonthlyData)) {
            const total = Object.values(monthlyData).reduce((sum, data) => sum + (data.kcs || 0), 0);
            tpTotals[tpId] = total;
        }
        
        // Get all TPs sorted by KC volume
        const allTps = Object.entries(tpTotals).sort((a, b) => b[1] - a[1]);
        
        let html = `
        <div style="margin-bottom: 40px;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                <h4 style="color: #2d3748; margin: 0;">\ud83e\udd1d All Trading Partners - Monthly Performance (Kilocharacters)
                    <span class="info-icon">i
                        <div class="tooltip">
                            This table shows kilocharacter volumes for each trading partner across all periods.
                            KC growth percentages are calculated as average month-over-month changes.
                            Trading partners are sorted by total KC volume in descending order.
                            This helps understand data complexity and processing requirements by partner.
                        </div>
                    </span>
                </h4>
                <div style="display: flex; gap: 10px;">
                    <button onclick="exportTableData('tp-monthly-kcs', 'json')" style="
                        background: #3182ce;
                        color: white;
                        border: none;
                        padding: 8px 16px;
                        border-radius: 5px;
                        cursor: pointer;
                        font-size: 14px;
                        transition: background 0.2s;
                    " onmouseover="this.style.background='#2563eb'" onmouseout="this.style.background='#3182ce'">
                        📥 Export JSON
                    </button>
                    <button onclick="exportTableData('tp-monthly-kcs', 'csv')" style="
                        background: #16a34a;
                        color: white;
                        border: none;
                        padding: 8px 16px;
                        border-radius: 5px;
                        cursor: pointer;
                        font-size: 14px;
                        transition: background 0.2s;
                    " onmouseover="this.style.background='#15803d'" onmouseout="this.style.background='#16a34a'">
                        📥 Export CSV
                    </button>
                </div>
            </div>
            <div style="overflow-x: auto; max-height: 600px;">
            <table class="monthly-table">
                <thead style="position: sticky; top: 0; z-index: 20;">
                    <tr>
                        <th style="position: sticky; left: 0; background: #f7fafc; z-index: 21;">Trading Partner</th>`;
        
        // Add period headers
        for (const period of periods) {
            html += `<th style="text-align: center; background: #f7fafc;">${this.formatPeriodDisplay(period)}</th>`;
        }
        
        html += `<th style="background: #e6f7ff;">Total KCs</th>
                    </tr>
                </thead>
                <tbody>`;
        
        // Add TP rows - show all trading partners
        for (let i = 0; i < allTps.length; i++) {
            const [tpId, totalVolume] = allTps[i];
            html += `
                <tr>
                    <td style="position: sticky; left: 0; background: white; z-index: 5;">
                        <strong>${tpId}</strong>
                    </td>`;
            
            // Add monthly KC data
            for (const period of periods) {
                if (tpMonthlyData[tpId] && tpMonthlyData[tpId][period]) {
                    const value = tpMonthlyData[tpId][period].kcs;
                    
                    // Add visual indicator for high/low values
                    if (value > 0) {
                        const monthlyValues = Object.values(tpMonthlyData[tpId])
                            .map(d => d.kcs)
                            .filter(v => v > 0);
                        const maxVal = Math.max(...monthlyValues);
                        const minVal = Math.min(...monthlyValues);
                        
                        if (value === maxVal) {
                            html += `<td style="background: #d4f8d4;">${value.toLocaleString()}</td>`;
                        } else if (value === minVal) {
                            html += `<td style="background: #ffe6e6;">${value.toLocaleString()}</td>`;
                        } else {
                            html += `<td>${value.toLocaleString()}</td>`;
                        }
                    } else {
                        html += '<td>-</td>';
                    }
                } else {
                    html += '<td>-</td>';
                }
            }
            
            // Add total
            html += `<td style="background: #e6f7ff; font-weight: 600;">${totalVolume.toLocaleString()}</td>
            </tr>`;
        }
        
        
        html += `
                </tbody>
            </table>
            </div>
        </div>`;
        return html;
    }
    
    generateDocTypeBehavior(data, sortedPeriods) {
        
        if (!data.tp_data || sortedPeriods.length < 2) {
            return "";
        }
        
        // First, add the Document Count Analysis section wrapper
        let html = `<div style="border: 2px solid #e2e8f0; border-radius: 10px; padding: 20px; margin-bottom: 30px;">
            <h4 style="color: #1a365d; margin-top: 0; margin-bottom: 20px;">📄 Document Count Analysis
                <span class="info-icon">i
                    <div class="tooltip">
                        Document Count Analysis shows the volume of each document type across all periods.
                        It helps identify which document types are most frequently processed.
                        The table includes total counts and average monthly volumes.
                        Use this to understand your document processing patterns and trends.
                    </div>
                </span>
            </h4>`;
        
        // Analyze document type behavior across months
        const docTypeTrends = {};
        const docTypeCategories = new Set();
        
        
        // Collect all document types and their trends from Doc_Summary or TP_Doc_Summary
        for (const period of sortedPeriods) {
            const periodData = data.tp_data[period];
            if (!periodData) {
                continue;
            }
            
            // Check for Doc_Summary first, then fall back to TP_Doc_Summary
            const docData = periodData['Doc_Summary'] || periodData['TP_Doc_Summary'];
            if (docData) {
                if (docData.length > 0) {
                    
                    // Debug: Look for the actual column names
                    const allColumns = new Set();
                    docData.forEach(row => {
                        Object.keys(row).forEach(col => allColumns.add(col));
                    });
                }
                
                let rowCount = 0;
                const isDocSummary = periodData['Doc_Summary'] ? true : false;
                
                docData.forEach(row => {
                    rowCount++;
                    // For TP_Doc_Summary, document types might be in column headers
                    if (!isDocSummary) {
                        // Look for document type columns (those that are not metadata columns)
                        Object.keys(row).forEach(colName => {
                            const colUpper = colName.toUpperCase();
                            // Skip metadata columns and look for document type columns
                            if (!colUpper.includes('TRADE') && !colUpper.includes('TP') && 
                                !colUpper.includes('CUSTOMER') && !colUpper.includes('TOTAL') &&
                                !colUpper.includes('TTL') && colName !== 'DOCS' && 
                                colName !== 'DOC' && !colUpper.includes('INB') && 
                                !colUpper.includes('OUT') && !colUpper.includes('OUB')) {
                                
                                const value = parseFloat(row[colName]) || 0;
                                if (value > 0) {
                                    // This column represents a document type
                                    const docType = colName.trim();
                                    docTypeCategories.add(docType);
                                    
                                    if (!docTypeTrends[docType]) {
                                        docTypeTrends[docType] = {};
                                    }
                                    if (!docTypeTrends[docType][period]) {
                                        docTypeTrends[docType][period] = 0;
                                    }
                                    docTypeTrends[docType][period] += value;
                                }
                            }
                        });
                        
                        // Also check if there's a DOCS column with document type
                        const docType = row['DOCS'] || row['Doc Type'] || row['Document Type'];
                        if (docType && !String(docType).toUpperCase().includes('TOTAL')) {
                            // Look for total columns for this doc type
                            let docCount = 0;
                            Object.keys(row).forEach(key => {
                                if ((key.toUpperCase().includes('TOTAL') || key.toUpperCase().includes('TTL')) && 
                                    key.toUpperCase().includes('DOC')) {
                                    docCount += parseFloat(row[key]) || 0;
                                }
                            });
                            
                            if (docCount > 0) {
                                docTypeCategories.add(docType);
                                if (!docTypeTrends[docType]) {
                                    docTypeTrends[docType] = {};
                                }
                                if (!docTypeTrends[docType][period]) {
                                    docTypeTrends[docType][period] = 0;
                                }
                                docTypeTrends[docType][period] += docCount;
                            }
                        }
                    } else {
                        // For Doc_Summary sheets, use the original logic
                        const docType = (row['DOC'] || row['DOCS'] || row['Doc Type'] || row['Document Type'] || '').trim();
                        
                        // Debug: Log what we're finding
                        if (docData.indexOf(row) < 3) {
                        }
                        
                        if (docType && !String(docType).toUpperCase().includes('TOTAL')) {
                            docTypeCategories.add(docType);
                            
                            if (!docTypeTrends[docType]) {
                                docTypeTrends[docType] = {};
                            }
                            
                            // Get total document count from TOTAL-DOC column
                            let docCount = parseFloat(row['TOTAL-DOC']) || 0;
                            
                            // If TOTAL-DOC doesn't exist, try other variations
                            if (docCount === 0) {
                                Object.keys(row).forEach(key => {
                                    const keyUpper = key.toUpperCase();
                                    if ((keyUpper.includes('TOTAL') || keyUpper.includes('TTL')) && 
                                        (keyUpper.includes('DOC') && !keyUpper.includes('KCS'))) {
                                        const val = parseFloat(row[key]) || 0;
                                        if (val > 0) {
                                            docCount = val;
                                        }
                                    }
                                });
                            }
                            
                            
                            if (docCount > 0) {
                                if (!docTypeTrends[docType][period]) {
                                    docTypeTrends[docType][period] = 0;
                                }
                                docTypeTrends[docType][period] += docCount;
                            }
                        }
                    }
                });
            }
        }
        
        
        // Calculate metrics for each document type
        const docTypeMetrics = {};
        for (const [docType, periods] of Object.entries(docTypeTrends)) {
            const values = sortedPeriods.map(p => periods[p] || 0);
            const nonZeroValues = values.filter(v => v > 0);
            
            if (nonZeroValues.length > 0) {
                // Calculate average monthly volume
                const avgVolume = nonZeroValues.reduce((a, b) => a + b, 0) / nonZeroValues.length;
                
                // Calculate month-over-month growth rate
                let avgGrowth = 0;
                let growthCount = 0;
                for (let i = 1; i < values.length; i++) {
                    if (values[i-1] > 0 && values[i] > 0) {
                        const growth = ((values[i] - values[i-1]) / values[i-1]) * 100;
                        avgGrowth += growth;
                        growthCount++;
                    }
                }
                avgGrowth = growthCount > 0 ? avgGrowth / growthCount : 0;
                
                // Get first and last non-zero values
                const firstValue = values.find(v => v > 0) || 0;
                const lastValue = [...values].reverse().find(v => v > 0) || 0;
                
                docTypeMetrics[docType] = {
                    avgVolume,
                    avgGrowth,
                    firstValue,
                    lastValue,
                    values,
                    total: nonZeroValues.reduce((a, b) => a + b, 0)
                };
            }
        }
        
        // Sort by average volume
        const sortedDocTypes = Object.entries(docTypeMetrics)
            .sort((a, b) => b[1].avgVolume - a[1].avgVolume);
        
        
        if (sortedDocTypes.length === 0) {
            html += `<p>No document type data available.</p></div>`;
            return html;
        }
        
        html += `
        <div style="margin-bottom: 40px;">
            <h4 style="color: #2d3748; margin-bottom: 10px;">📄 Document Type Behavior Analysis
                <span class="info-icon">i
                    <div class="tooltip">
                        Document Type Behavior Analysis examines trends for each document type.
                        It categorizes document types as Growing, Stable, or Declining based on recent trends.
                        Growth is calculated using the last 3 months of available data.
                        This helps identify which document types are increasing or decreasing in usage.
                    </div>
                </span>
            </h4>
            <p style="font-size: 0.9em; color: #718096; margin-bottom: 20px;">
                Showing all document types sorted by average monthly volume. The percentage indicates the average 
                month-over-month trend, while the sparkline shows the recent 6-month pattern.
            </p>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(350px, 1fr)); gap: 15px;">`;
        
        // Create metric cards for each document type
        for (const [docType, metrics] of sortedDocTypes) {
            const trendColor = metrics.avgGrowth > 0 ? '#16a34a' : metrics.avgGrowth < 0 ? '#dc2626' : '#6b7280';
            const trendIcon = metrics.avgGrowth > 0 ? '↑' : metrics.avgGrowth < 0 ? '↓' : '→';
            
            // Get last 6 months of data for sparkline
            const last6Months = metrics.values.slice(-6);
            const sparklineData = this.createSparklineData(last6Months);
            
            html += `
            <div class="metric-card" style="padding: 15px 20px;">
                <div class="metric-label" style="font-size: 0.85em; margin-bottom: 8px;">${docType}</div>
                <div style="display: flex; align-items: center; justify-content: space-between; gap: 10px;">
                    <div style="flex: 1;">
                        <div class="metric-value" style="color: ${trendColor}; font-size: 1.3em; margin-bottom: 4px;">
                            ${trendIcon} ${Math.abs(metrics.avgGrowth).toFixed(1)}%
                        </div>
                        <div class="metric-detail" style="font-size: 0.75em; line-height: 1.3;">
                            Avg: ${Math.round(metrics.avgVolume).toLocaleString()}/mo<br>
                            <small style="color: #a0aec0; font-size: 0.9em;">Period: ${metrics.firstValue.toLocaleString()} → ${metrics.lastValue.toLocaleString()}</small>
                        </div>
                    </div>
                    <div style="text-align: center; flex-shrink: 0;">
                        <div style="transform: scale(0.8); transform-origin: center;">
                            <svg class="sparkline" viewBox="0 0 100 30" style="width: 80px; height: 30px;">
                                <path d="${sparklineData}" fill="none" stroke="#3182ce" stroke-width="2"/>
                            </svg>
                        </div>
                        <div style="font-size: 0.6em; color: #a0aec0; margin-top: -5px;">Last 6 mo</div>
                    </div>
                </div>
            </div>`;
        }
        
        html += `
            </div>
        </div>
        </div>`;
        
        return html;
    }
    
    generateDocTypeBehaviorKCs(data, sortedPeriods) {
        if (!data.tp_data || sortedPeriods.length < 2) {
            return "";
        }
        
        // Add the KC Character Analysis section wrapper
        let html = `<div style="border: 2px solid #e2e8f0; border-radius: 10px; padding: 20px; margin-bottom: 30px;">
            <h4 style="color: #1a365d; margin-top: 0; margin-bottom: 20px;">💲 KC Character Analysis
                <span class="info-icon">i
                    <div class="tooltip">
                        KC Character Analysis shows kilocharacter volumes for each document type.
                        It helps understand data complexity and size patterns across document types.
                        Higher KC values indicate larger or more complex documents.
                        Use this to optimize processing and storage for different document types.
                    </div>
                </span>
            </h4>`;
        
        // Analyze kilocharacter behavior by document type
        const kcTrends = {};
        const docTypeCategories = new Set();
        
        // Collect KC data by document type from Doc_Summary or TP_Doc_Summary
        for (const period of sortedPeriods) {
            const periodData = data.tp_data[period];
            if (!periodData) continue;
            
            // Check for Doc_Summary first, then fall back to TP_Doc_Summary
            const docData = periodData['Doc_Summary'] || periodData['TP_Doc_Summary'];
            if (docData) {
                const isDocSummary = periodData['Doc_Summary'] ? true : false;
                
                docData.forEach(row => {
                    // For TP_Doc_Summary, KC values might be in different structure
                    if (!isDocSummary) {
                        // First, check if there's a DOCS column with document type and separate KC columns
                        const docType = row['DOCS'] || row['Doc Type'] || row['Document Type'];
                        if (docType && !String(docType).toUpperCase().includes('TOTAL')) {
                            let kcCount = 0;
                            
                            // Look for KC-related columns
                            Object.keys(row).forEach(key => {
                                const keyUpper = key.toUpperCase();
                                if (keyUpper.includes('KC') && !keyUpper.includes('DOC')) {
                                    const value = parseFloat(row[key]) || 0;
                                    if (value > 0) {
                                        kcCount += value;
                                    }
                                }
                            });
                            
                            if (kcCount > 0) {
                                docTypeCategories.add(docType);
                                if (!kcTrends[docType]) {
                                    kcTrends[docType] = {};
                                }
                                if (!kcTrends[docType][period]) {
                                    kcTrends[docType][period] = 0;
                                }
                                kcTrends[docType][period] += kcCount;
                            }
                        }
                        
                        // Also check if document types are column names (like in the doc count analysis)
                        // This would mean KC values are stored differently
                        // For now, we'll focus on the DOCS column approach since KC data is typically structured that way
                    } else {
                        // For Doc_Summary sheets, use the original logic
                        const docType = (row['DOC'] || row['DOCS'] || row['Doc Type'] || row['Document Type'] || '').trim();
                        if (docType && !String(docType).toUpperCase().includes('TOTAL')) {
                            docTypeCategories.add(docType);
                            
                            if (!kcTrends[docType]) {
                                kcTrends[docType] = {};
                            }
                            
                            // Get total KC count from TOTAL-KCS column
                            let kcCount = parseFloat(row['TOTAL-KCS']) || 0;
                            
                            // If TOTAL-KCS doesn't exist, try other variations
                            if (kcCount === 0) {
                                Object.keys(row).forEach(key => {
                                    const keyUpper = key.toUpperCase();
                                    if ((keyUpper.includes('TOTAL') || keyUpper.includes('TTL')) && 
                                        keyUpper.includes('KC') && !keyUpper.includes('DOC')) {
                                        const val = parseFloat(row[key]) || 0;
                                        if (val > 0) {
                                            kcCount = val;
                                        }
                                    }
                                });
                            }
                            
                            if (kcCount > 0) {
                                if (!kcTrends[docType][period]) {
                                    kcTrends[docType][period] = 0;
                                }
                                kcTrends[docType][period] += kcCount;
                            }
                        }
                    }
                });
            }
        }
        
        // Calculate metrics for each document type
        const kcMetrics = {};
        for (const [docType, periods] of Object.entries(kcTrends)) {
            const values = sortedPeriods.map(p => periods[p] || 0);
            const nonZeroValues = values.filter(v => v > 0);
            
            if (nonZeroValues.length > 0) {
                // Calculate average monthly KC volume
                const avgVolume = nonZeroValues.reduce((a, b) => a + b, 0) / nonZeroValues.length;
                
                // Calculate month-over-month growth rate
                let avgGrowth = 0;
                let growthCount = 0;
                for (let i = 1; i < values.length; i++) {
                    if (values[i-1] > 0 && values[i] > 0) {
                        const growth = ((values[i] - values[i-1]) / values[i-1]) * 100;
                        avgGrowth += growth;
                        growthCount++;
                    }
                }
                avgGrowth = growthCount > 0 ? avgGrowth / growthCount : 0;
                
                // Get first and last non-zero values
                const firstValue = values.find(v => v > 0) || 0;
                const lastValue = [...values].reverse().find(v => v > 0) || 0;
                
                kcMetrics[docType] = {
                    avgVolume,
                    avgGrowth,
                    firstValue,
                    lastValue,
                    values,
                    total: nonZeroValues.reduce((a, b) => a + b, 0)
                };
            }
        }
        
        // Sort by average KC volume
        const sortedKCTypes = Object.entries(kcMetrics)
            .sort((a, b) => b[1].avgVolume - a[1].avgVolume);
        
        if (sortedKCTypes.length === 0) {
            html += `<p>No KC volume data available.</p></div>`;
            return html;
        }
        
        html += `
        <div style="margin-bottom: 40px;">
            <h4 style="color: #2d3748; margin-bottom: 10px;">💲 Document Type KC Volume Analysis
                <span class="info-icon">i
                    <div class="tooltip">
                        Document Type KC Volume Analysis examines kilocharacter trends for each document type.
                        It categorizes document types by KC volume patterns: Growing, Stable, or Declining.
                        This helps understand which document types are becoming more or less data-intensive.
                        Use this to optimize processing resources and identify changing document complexity.
                    </div>
                </span>
            </h4>
            <p style="font-size: 0.9em; color: #718096; margin-bottom: 20px;">
                Showing all document types sorted by average monthly KC volume. The percentage indicates the average 
                month-over-month trend, while the sparkline shows the recent 6-month pattern.
            </p>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(350px, 1fr)); gap: 15px;">`;
        
        // Create metric cards for each document type
        for (const [docType, metrics] of sortedKCTypes) {
            const trendColor = metrics.avgGrowth > 0 ? '#16a34a' : metrics.avgGrowth < 0 ? '#dc2626' : '#6b7280';
            const trendIcon = metrics.avgGrowth > 0 ? '↑' : metrics.avgGrowth < 0 ? '↓' : '→';
            
            // Get last 6 months of data for sparkline
            const last6Months = metrics.values.slice(-6);
            const sparklineData = this.createSparklineData(last6Months);
            
            html += `
            <div class="metric-card" style="padding: 15px 20px;">
                <div class="metric-label" style="font-size: 0.85em; margin-bottom: 8px;">${docType}</div>
                <div style="display: flex; align-items: center; justify-content: space-between; gap: 10px;">
                    <div style="flex: 1;">
                        <div class="metric-value" style="color: ${trendColor}; font-size: 1.3em; margin-bottom: 4px;">
                            ${trendIcon} ${Math.abs(metrics.avgGrowth).toFixed(1)}%
                        </div>
                        <div class="metric-detail" style="font-size: 0.75em; line-height: 1.3;">
                            Avg: ${Math.round(metrics.avgVolume).toLocaleString()} KC/mo<br>
                            <small style="color: #a0aec0; font-size: 0.9em;">Period: ${metrics.firstValue.toLocaleString()} → ${metrics.lastValue.toLocaleString()}</small>
                        </div>
                    </div>
                    <div style="text-align: center; flex-shrink: 0;">
                        <div style="transform: scale(0.8); transform-origin: center;">
                            <svg class="sparkline" viewBox="0 0 100 30" style="width: 80px; height: 30px;">
                                <path d="${sparklineData}" fill="none" stroke="#3182ce" stroke-width="2"/>
                            </svg>
                        </div>
                        <div style="font-size: 0.6em; color: #a0aec0; margin-top: -5px;">Last 6 mo</div>
                    </div>
                </div>
            </div>`;
        }
        
        html += `
            </div>
        </div>
        </div>`;
        
        return html;
    }
    
    createSparklineData(values) {
        if (!values || values.length === 0) {
            return 'M0,15 L100,15'; // Flat line if no data
        }
        
        const width = 100;
        const height = 30;
        const padding = 2;
        
        // Find min and max for scaling
        const max = Math.max(...values);
        const min = Math.min(...values);
        const range = max - min || 1;
        
        // Generate path data
        const points = values.map((value, index) => {
            const x = (index / (values.length - 1)) * (width - 2 * padding) + padding;
            const y = height - padding - ((value - min) / range) * (height - 2 * padding);
            return `${x},${y}`;
        });
        
        return `M${points.join(' L')}`;
    }
    
    createSparkline(values) {
        if (!values || values.length === 0) {
            return '';
        }
        
        const max = Math.max(...values);
        const min = Math.min(...values);
        const range = max - min || 1;
        
        // Create simple ASCII sparkline
        const chars = ['▁', '▂', '▃', '▄', '▅', '▆', '▇', '█'];
        
        const sparkline = values.map(v => {
            const normalized = (v - min) / range;
            const index = Math.floor(normalized * (chars.length - 1));
            return chars[index];
        }).join('');
        
        // Add trend indicator
        const lastValue = values[values.length - 1];
        const prevValue = values[values.length - 2] || lastValue;
        const trend = lastValue > prevValue ? '↑' : lastValue < prevValue ? '↓' : '→';
        
        return `<span style="font-family: monospace; letter-spacing: -2px;">${sparkline}</span> ${trend}`;
    }
    
    generateMonthlyHighlights(data, sortedPeriods) {
        if (sortedPeriods.length < 2) {
            return "";
        }
        
        const currentPeriod = sortedPeriods[sortedPeriods.length - 1];
        const prevPeriod = sortedPeriods[sortedPeriods.length - 2];
        
        // Collect highlights
        const highlights = [];
        
        // Check document volume changes
        if (data.trends && data.trends.Date_Summary && data.trends.Date_Summary.metric_trends) {
            const docTrend = data.trends.Date_Summary.metric_trends['TOTAL-DOC'] || [];
            const kcTrend = data.trends.Date_Summary.metric_trends['TOTAL-KCS'] || [];
            const periods = data.trends.Date_Summary.periods || [];
            
            const currentIdx = periods.indexOf(currentPeriod);
            const prevIdx = periods.indexOf(prevPeriod);
            
            if (currentIdx >= 0 && prevIdx >= 0) {
                const currentDocs = docTrend[currentIdx] || 0;
                const prevDocs = docTrend[prevIdx] || 0;
                const docChange = prevDocs > 0 ? ((currentDocs - prevDocs) / prevDocs * 100) : 0;
                
                if (Math.abs(docChange) > 10) {
                    highlights.push({
                        type: docChange > 0 ? 'positive' : 'negative',
                        icon: docChange > 0 ? '📈' : '📉',
                        text: `Document volume ${docChange > 0 ? 'increased' : 'decreased'} by ${Math.abs(docChange).toFixed(1)}% from previous month`
                    });
                }
                
                // Check KC efficiency
                const currentKCs = kcTrend[currentIdx] || 0;
                const prevKCs = kcTrend[prevIdx] || 0;
                
                if (currentDocs > 0 && prevDocs > 0 && currentKCs > 0 && prevKCs > 0) {
                    const currentEfficiency = currentDocs / currentKCs;
                    const prevEfficiency = prevDocs / prevKCs;
                    const effChange = ((currentEfficiency - prevEfficiency) / prevEfficiency * 100);
                    
                    if (Math.abs(effChange) > 5) {
                        highlights.push({
                            type: effChange > 0 ? 'positive' : 'warning',
                            icon: effChange > 0 ? '⚡' : '⚠️',
                            text: `Processing efficiency ${effChange > 0 ? 'improved' : 'declined'} by ${Math.abs(effChange).toFixed(1)}%`
                        });
                    }
                }
            }
        }
        
        // Check for new highs/lows
        if (data.trends && data.trends.Date_Summary && data.trends.Date_Summary.metric_trends) {
            const docTrend = data.trends.Date_Summary.metric_trends['TOTAL-DOC'] || [];
            if (docTrend.length > 0) {
                const currentValue = docTrend[docTrend.length - 1];
                const maxValue = Math.max(...docTrend);
                const minValue = Math.min(...docTrend);
                
                if (currentValue === maxValue && docTrend.length > 1) {
                    highlights.push({
                        type: 'positive',
                        icon: '🏆',
                        text: 'Document volume reached an all-time high'
                    });
                } else if (currentValue === minValue && docTrend.length > 1) {
                    highlights.push({
                        type: 'negative',
                        icon: '📊',
                        text: 'Document volume at lowest point in the analyzed period'
                    });
                }
            }
        }
        
        if (highlights.length === 0) {
            highlights.push({
                type: 'neutral',
                icon: '📋',
                text: 'Document processing volumes remained stable this month'
            });
        }
        
        let html = `
        <div style="margin-bottom: 40px;">
            <h4 style="color: #2d3748; margin-bottom: 20px;">🌟 Monthly Highlights - ${this.formatPeriodDisplay(currentPeriod)}
                <span class="info-icon">i
                    <div class="tooltip">
                        Monthly Highlights summarize key achievements and changes for the current period.
                        It includes top performers, fastest growing elements, and significant changes.
                        These insights help quickly understand the most important trends.
                        Focus areas are automatically identified based on volume and growth metrics.
                    </div>
                </span>
            </h4>
            <div style="display: grid; gap: 15px;">`;
        
        for (const highlight of highlights) {
            const bgColor = highlight.type === 'positive' ? '#d1fae5' : 
                           highlight.type === 'negative' ? '#fee2e2' : 
                           highlight.type === 'warning' ? '#fef3c7' : '#e0e7ff';
            
            html += `
                <div style="background: ${bgColor}; padding: 15px 20px; border-radius: 10px; display: flex; align-items: center; gap: 15px;">
                    <span style="font-size: 1.5em;">${highlight.icon}</span>
                    <span style="color: #1f2937; font-size: 0.95em;">${highlight.text}</span>
                </div>`;
        }
        
        html += `
            </div>
        </div>`;
        
        return html;
    }

    // TP Analysis Helper Methods
    extractTPData(data) {
        const tpData = {};
        
        // Extract TP data from all periods
        if (data.tp_data) {
            for (const [period, periodData] of Object.entries(data.tp_data)) {
                for (const [sheetName, sheetRows] of Object.entries(periodData)) {
                    // Only process TP_Summary sheets to avoid double counting
                    if (sheetName === 'TP_Summary' && Array.isArray(sheetRows)) {
                        sheetRows.forEach(row => {
                            // Extract TP ID - handle various column names
                            let tpId = null;
                            for (const [key, value] of Object.entries(row)) {
                                const keyStripped = key.trim();
                                if (['TP ID', 'TP-ID', 'Trading Partner', 'TP_ID', 'TP'].includes(keyStripped)) {
                                    tpId = String(value || '').trim();
                                    break;
                                }
                            }
                            
                            if (!tpId) return;
                            
                            if (!tpData[tpId]) {
                                tpData[tpId] = {
                                    name: tpId,
                                    periods: {},
                                    total_docs: 0,
                                    total_kcs: 0,
                                    inbound_docs: 0,
                                    outbound_docs: 0,
                                    inbound_kcs: 0,
                                    outbound_kcs: 0,
                                    doc_types: new Set()
                                };
                            }
                            
                            // Initialize period data
                            if (!tpData[tpId].periods[period]) {
                                tpData[tpId].periods[period] = {
                                    docs: 0,
                                    kcs: 0,
                                    inbound_docs: 0,
                                    outbound_docs: 0,
                                    inbound_kcs: 0,
                                    outbound_kcs: 0
                                };
                            }
                            
                            // Extract values
                            const totalDocs = parseFloat(row['TOTAL-DOC'] || 0);
                            const totalKcs = parseFloat(row['TOTAL-KCS'] || 0);
                            const inbDocs = parseFloat(row['INB-DOC'] || 0);
                            const outDocs = parseFloat(row['OUT-DOC'] || row['OUB-DOC'] || 0);
                            const inbKcs = parseFloat(row['INB-KCS'] || 0);
                            const outKcs = parseFloat(row['OUT-KCS'] || row['OUB-KCS'] || 0);
                            
                            // Update period data
                            tpData[tpId].periods[period].docs += totalDocs;
                            tpData[tpId].periods[period].kcs += totalKcs;
                            tpData[tpId].periods[period].inbound_docs += inbDocs;
                            tpData[tpId].periods[period].outbound_docs += outDocs;
                            tpData[tpId].periods[period].inbound_kcs += inbKcs;
                            tpData[tpId].periods[period].outbound_kcs += outKcs;
                            
                            // Update totals
                            tpData[tpId].total_docs += totalDocs;
                            tpData[tpId].total_kcs += totalKcs;
                            tpData[tpId].inbound_docs += inbDocs;
                            tpData[tpId].outbound_docs += outDocs;
                            tpData[tpId].inbound_kcs += inbKcs;
                            tpData[tpId].outbound_kcs += outKcs;
                        });
                    }
                    
                    // Extract document types from TP_Doc_Summary
                    if (sheetName === 'TP_Doc_Summary' && Array.isArray(sheetRows)) {
                        sheetRows.forEach(row => {
                            // Extract TP ID
                            let tpId = null;
                            let docType = null;
                            
                            for (const [key, value] of Object.entries(row)) {
                                const keyStripped = key.trim();
                                if (['TP ID', 'TP-ID', 'Trading Partner', 'TP_ID', 'TP'].includes(keyStripped)) {
                                    tpId = String(value || '').trim();
                                } else if (['DOCS', 'DOC', 'Document Type', 'Doc Type', 'DOC_TYPE'].includes(keyStripped)) {
                                    docType = String(value || '').trim();
                                }
                            }
                            
                            if (tpId && docType && tpData[tpId]) {
                                tpData[tpId].doc_types.add(docType);
                            }
                        });
                    }
                }
            }
        }
        
        return tpData;
    }

    analyzeTPData(tpData) {
        const analysis = {
            tp_totals: {},
            periods: {},
            doc_types_by_tp: {}
        };
        
        // Process each TP
        for (const [tpId, tpInfo] of Object.entries(tpData)) {
            // Calculate growth metrics
            const periods = Object.keys(tpInfo.periods).sort();
            let docGrowth = 0;
            let kcGrowth = 0;
            
            if (periods.length >= 2) {
                // Calculate average month-over-month growth
                const docValues = periods.map(p => tpInfo.periods[p].docs);
                const kcValues = periods.map(p => tpInfo.periods[p].kcs);
                
                const docChanges = [];
                const kcChanges = [];
                
                for (let i = 1; i < periods.length; i++) {
                    if (docValues[i-1] > 0) {
                        docChanges.push((docValues[i] - docValues[i-1]) / docValues[i-1] * 100);
                    }
                    if (kcValues[i-1] > 0) {
                        kcChanges.push((kcValues[i] - kcValues[i-1]) / kcValues[i-1] * 100);
                    }
                }
                
                docGrowth = docChanges.length > 0 ? docChanges.reduce((a, b) => a + b, 0) / docChanges.length : 0;
                kcGrowth = kcChanges.length > 0 ? kcChanges.reduce((a, b) => a + b, 0) / kcChanges.length : 0;
            }
            
            // Store TP analysis
            analysis.tp_totals[tpId] = {
                total_docs: tpInfo.total_docs,
                total_kcs: tpInfo.total_kcs,
                inbound_docs: tpInfo.inbound_docs,
                outbound_docs: tpInfo.outbound_docs,
                inbound_kcs: tpInfo.inbound_kcs,
                outbound_kcs: tpInfo.outbound_kcs,
                doc_growth: docGrowth,
                kc_growth: kcGrowth,
                periods: periods,
                doc_values: periods.map(p => tpInfo.periods[p].docs),
                kc_values: periods.map(p => tpInfo.periods[p].kcs)
            };
            
            // Store document types
            if (tpInfo.doc_types.size > 0) {
                analysis.doc_types_by_tp[tpId] = Array.from(tpInfo.doc_types);
            }
            
            // Track all periods
            periods.forEach(p => {
                analysis.periods[p] = true;
            });
        }
        
        return analysis;
    }

    generateTopTPsTable(tpAnalysis) {
        // Sort TPs by document volume - show all trading partners
        const sortedTPs = Object.entries(tpAnalysis.tp_totals)
            .sort((a, b) => b[1].total_docs - a[1].total_docs);
        
        // Calculate average documents per partner for health score
        const totalDocs = Object.values(tpAnalysis.tp_totals).reduce((sum, tp) => sum + tp.total_docs, 0);
        const avgDocsPerPartner = sortedTPs.length > 0 ? totalDocs / sortedTPs.length : 0;
        
        let html = `
        <div class="tp-chart-container">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                <div class="tp-chart-title">📊 All Trading Partners by Document Volume
                    <span class="info-icon">i
                        <div class="tooltip">
                            This chart displays all trading partners ranked by their total document volume.
                            The bar chart visualizes relative volumes across all partners.
                            Growth percentages show average month-over-month changes.
                            Use this to identify your most important trading relationships.
                        </div>
                    </span>
                </div>
                <div style="display: flex; gap: 10px;">
                    <button onclick="exportTableData('tp-doc-volume', 'json')" style="
                        background: #3182ce;
                        color: white;
                        border: none;
                        padding: 8px 16px;
                        border-radius: 5px;
                        cursor: pointer;
                        font-size: 14px;
                        transition: background 0.2s;
                    " onmouseover="this.style.background='#2563eb'" onmouseout="this.style.background='#3182ce'">
                        📥 Export JSON
                    </button>
                    <button onclick="exportTableData('tp-doc-volume', 'csv')" style="
                        background: #16a34a;
                        color: white;
                        border: none;
                        padding: 8px 16px;
                        border-radius: 5px;
                        cursor: pointer;
                        font-size: 14px;
                        transition: background 0.2s;
                    " onmouseover="this.style.background='#15803d'" onmouseout="this.style.background='#16a34a'">
                        📥 Export CSV
                    </button>
                    ${window.parent && window.parent.idCrossReference ? `
                    <div style="background: #f3f4f6; padding: 4px; border-radius: 8px; display: flex; gap: 4px; margin-left: 20px;">
                        <span style="padding: 6px 8px; color: #4b5563; font-size: 0.85em;">Display:</span>
                        <button onclick="setTPDisplayMode('id', 'tp-doc-volume-table')" 
                            class="display-mode-btn display-mode-id" 
                            data-mode="id"
                            style="
                                padding: 6px 12px;
                                border: none;
                                background: #3b82f6;
                                color: white;
                                border-radius: 6px;
                                cursor: pointer;
                                font-size: 0.85em;
                                transition: all 0.2s;
                            ">ID</button>
                        <button onclick="setTPDisplayMode('name', 'tp-doc-volume-table')" 
                            class="display-mode-btn display-mode-name" 
                            data-mode="name"
                            style="
                                padding: 6px 12px;
                                border: none;
                                background: transparent;
                                color: #6b7280;
                                border-radius: 6px;
                                cursor: pointer;
                                font-size: 0.85em;
                                transition: all 0.2s;
                            ">Name</button>
                        <button onclick="setTPDisplayMode('region', 'tp-doc-volume-table')" 
                            class="display-mode-btn display-mode-region" 
                            data-mode="region"
                            style="
                                padding: 6px 12px;
                                border: none;
                                background: transparent;
                                color: #6b7280;
                                border-radius: 6px;
                                cursor: pointer;
                                font-size: 0.85em;
                                transition: all 0.2s;
                            ">Region</button>
                    </div>
                    ` : ''}
                </div>
            </div>
            <div style="max-height: 600px; overflow-y: auto;">
            <table class="tp-table sortable" id="tp-doc-volume-table">
                <thead>
                    <tr>
                        <th>Rank</th>
                        <th>TP ID</th>
                        <th>Health Score</th>
                        <th>Total Documents</th>
                        <th>Inbound</th>
                        <th>Outbound</th>
                        <th>Growth Trend</th>
                    </tr>
                </thead>
                <tbody>`;
        
        sortedTPs.forEach(([tpId, tpInfo], index) => {
            const rank = index + 1;
            const rankClass = rank <= 3 ? 'top3' : '';
            const growth = tpInfo.doc_growth;
            const growthClass = growth > 0 ? 'positive' : growth < 0 ? 'negative' : '';
            const growthSymbol = growth > 0 ? '↑' : growth < 0 ? '↓' : '→';
            
            // Calculate health score
            const healthScore = this.calculatePartnerHealthScore({...tpInfo, avg_docs_per_partner: avgDocsPerPartner});
            
            html += `
                <tr>
                    <td><span class="tp-rank ${rankClass}">${rank}</span></td>
                    <td class="tp-id-cell" data-id="${tpId}"><strong>${tpId}</strong></td>
                    <td>${healthScore.badge}</td>
                    <td>${tpInfo.total_docs.toLocaleString()}</td>
                    <td>${tpInfo.inbound_docs.toLocaleString()}</td>
                    <td>${tpInfo.outbound_docs.toLocaleString()}</td>
                    <td class="tp-growth ${growthClass}">
                        ${growthSymbol} ${Math.abs(growth).toFixed(1)}%
                    </td>
                </tr>`;
        });
        
        html += `
                </tbody>
            </table>
            </div>
        </div>`;
        
        return html;
    }

    generateTPKCAnalysis(tpData) {
        const tpArray = Object.values(tpData);
        const sortedByKC = tpArray.sort((a, b) => b.kcVolume - a.kcVolume);
        
        // Calculate cumulative percentages
        const totalKC = tpArray.reduce((sum, tp) => sum + tp.kcVolume, 0);
        let cumulativeKC = 0;
        let tp80Count = 0;
        
        for (let i = 0; i < sortedByKC.length; i++) {
            cumulativeKC += sortedByKC[i].kcVolume;
            const cumulativePercent = (cumulativeKC / totalKC) * 100;
            
            if (cumulativePercent <= 80 && tp80Count === 0) {
                tp80Count = i + 1;
            }
            
            if (cumulativePercent >= 80) break;
        }
        
        return '';
    }

    generateTPGrowthAnalysis(analysis) {
        // Get TPs with growth data
        const tpsWithGrowth = Object.entries(analysis.tp_totals)
            .map(([tpId, tpInfo]) => ({
                tpId,
                docGrowth: tpInfo.doc_growth,
                kcGrowth: tpInfo.kc_growth,
                totalDocs: tpInfo.total_docs,
                totalKcs: tpInfo.total_kcs
            }))
            .filter(tp => tp.docGrowth !== 0); // Only show TPs with growth/decline
        
        // Sort by document growth
        const topGrowing = tpsWithGrowth
            .filter(tp => tp.docGrowth > 0)
            .sort((a, b) => b.docGrowth - a.docGrowth)
            .slice(0, 10);
        
        const topDeclining = tpsWithGrowth
            .filter(tp => tp.docGrowth < 0)
            .sort((a, b) => a.docGrowth - b.docGrowth)
            .slice(0, 10);
        
        let html = `
        <div class="tp-analysis-grid">
            <div class="tp-chart-container">
                <div class="tp-chart-title">📈 Top Growing Trading Partners
                    <span class="info-icon">i
                        <div class="tooltip">
                            Shows the top 10 trading partners with the highest growth rates.
                            Growth is calculated as average month-over-month percentage change.
                            Recent volume shows the most current period's document count.
                            Focus on these partners for expanding business opportunities.
                        </div>
                    </span>
                </div>
                <table class="tp-table">
                    <thead>
                        <tr>
                            <th>TP ID</th>
                            <th>Doc Growth</th>
                            <th>KC Growth</th>
                            <th>Total Volume</th>
                        </tr>
                    </thead>
                    <tbody>`;
        
        if (topGrowing.length > 0) {
            topGrowing.forEach(tp => {
                html += `
                    <tr>
                        <td class="tp-id-cell" data-id="${tp.tpId}"><strong>${tp.tpId}</strong></td>
                        <td class="tp-growth positive">↑ ${tp.docGrowth.toFixed(1)}%</td>
                        <td class="tp-growth ${tp.kcGrowth > 0 ? 'positive' : 'negative'}">
                            ${tp.kcGrowth > 0 ? '↑' : '↓'} ${Math.abs(tp.kcGrowth).toFixed(1)}%
                        </td>
                        <td>${tp.totalDocs.toLocaleString()} docs</td>
                    </tr>`;
            });
        } else {
            html += `<tr><td colspan="4" style="text-align: center; color: #718096;">No growing TPs found</td></tr>`;
        }
        
        html += `
                    </tbody>
                </table>
            </div>
            
            <div class="tp-chart-container">
                <div class="tp-chart-title">📉 Top Declining Trading Partners
                    <span class="info-icon">i
                        <div class="tooltip">
                            Shows the top 10 trading partners with the largest volume declines.
                            Decline is calculated as negative month-over-month percentage change.
                            Recent volume shows the most current period's document count.
                            These partners may need attention to reverse declining trends.
                        </div>
                    </span>
                </div>
                <table class="tp-table">
                    <thead>
                        <tr>
                            <th>TP ID</th>
                            <th>Doc Growth</th>
                            <th>KC Growth</th>
                            <th>Total Volume</th>
                        </tr>
                    </thead>
                    <tbody>`;
        
        if (topDeclining.length > 0) {
            topDeclining.forEach(tp => {
                html += `
                    <tr>
                        <td class="tp-id-cell" data-id="${tp.tpId}"><strong>${tp.tpId}</strong></td>
                        <td class="tp-growth negative">↓ ${Math.abs(tp.docGrowth).toFixed(1)}%</td>
                        <td class="tp-growth ${tp.kcGrowth > 0 ? 'positive' : 'negative'}">
                            ${tp.kcGrowth > 0 ? '↑' : '↓'} ${Math.abs(tp.kcGrowth).toFixed(1)}%
                        </td>
                        <td>${tp.totalDocs.toLocaleString()} docs</td>
                    </tr>`;
            });
        } else {
            html += `<tr><td colspan="4" style="text-align: center; color: #718096;">No declining TPs found</td></tr>`;
        }
        
        html += `
                    </tbody>
                </table>
            </div>
        </div>`;
        
        return html;
    }

    generateTPTrendsChart(tpAnalysis) {
        return '';
    }

    generateTPTrendsChartOld(tpAnalysis) {
        // Get top 5 TPs by document volume
        const top5TPs = Object.entries(tpAnalysis.tp_totals)
            .sort((a, b) => b[1].total_docs - a[1].total_docs)
            .slice(0, 5)
            .map(([tpId]) => tpId);
        
        if (top5TPs.length === 0) {
            return `<div class="tp-chart-container">
                <div class="tp-chart-title">📊 Volume Trends - Top 5 Trading Partners
                    <span class="info-icon">i
                        <div class="tooltip">
                            This line chart shows document volume trends for your top 5 trading partners.
                            Each line represents a different partner's monthly performance.
                            Trends help identify seasonal patterns and growth trajectories.
                            Use this to monitor your key relationships over time.
                        </div>
                    </span>
                </div>
                <p style="text-align: center; color: #718096; padding: 20px;">No data available for trends chart</p>
            </div>`;
        }
        
        // Get all periods sorted
        const sortedPeriods = Object.keys(tpAnalysis.periods).sort();
        
        // Prepare chart data
        const chartData = {};
        top5TPs.forEach(tpId => {
            const tpInfo = tpAnalysis.tp_totals[tpId];
            chartData[tpId] = [];
            
            // Fill in values for each period
            sortedPeriods.forEach(period => {
                const idx = tpInfo.periods.indexOf(period);
                if (idx >= 0) {
                    chartData[tpId].push(tpInfo.doc_values[idx] || 0);
                } else {
                    chartData[tpId].push(0);
                }
            });
        });
        
        // Find max value for scaling
        let maxValue = 0;
        Object.values(chartData).forEach(values => {
            const max = Math.max(...values);
            if (max > maxValue) maxValue = max;
        });
        
        // Create SVG chart
        const width = 800;
        const height = 400;
        const padding = 60;
        const chartWidth = width - 2 * padding;
        const chartHeight = height - 2 * padding;
        
        let html = `
        <div class="tp-chart-container">
            <div class="tp-chart-title">📊 Volume Trends - Top 5 Trading Partners</div>
            <svg width="${width}" height="${height}" viewBox="0 0 ${width} ${height}" style="width: 100%; height: auto; max-width: ${width}px;">
                <!-- Grid -->
                <defs>
                    <pattern id="gridTP" width="40" height="40" patternUnits="userSpaceOnUse">
                        <path d="M 40 0 L 0 0 0 40" fill="none" stroke="#e0e0e0" stroke-width="1"/>
                    </pattern>
                </defs>
                <rect x="${padding}" y="${padding}" width="${chartWidth}" height="${chartHeight}" fill="url(#gridTP)" opacity="0.5"/>
                
                <!-- Y-axis -->
                <line x1="${padding}" y1="${padding}" x2="${padding}" y2="${height - padding}" stroke="#666" stroke-width="2"/>
                
                <!-- X-axis -->
                <line x1="${padding}" y1="${height - padding}" x2="${width - padding}" y2="${height - padding}" stroke="#666" stroke-width="2"/>`;
        
        // Y-axis labels
        const yTicks = 5;
        for (let i = 0; i <= yTicks; i++) {
            const yValue = (maxValue * i / yTicks);
            const yPos = height - padding - (i * chartHeight / yTicks);
            html += `
                <text x="${padding - 10}" y="${yPos + 5}" text-anchor="end" font-size="11" fill="#666">${yValue.toLocaleString()}</text>
                <line x1="${padding - 5}" y1="${yPos}" x2="${padding}" y2="${yPos}" stroke="#666" stroke-width="1"/>`;
        }
        
        // X-axis labels
        const labelInterval = Math.max(1, Math.floor(sortedPeriods.length / 8));
        const xScale = chartWidth / (sortedPeriods.length - 1 || 1);
        
        for (let i = 0; i < sortedPeriods.length; i += labelInterval) {
            const xPos = padding + i * xScale;
            html += `
                <text x="${xPos}" y="${height - padding + 20}" text-anchor="middle" font-size="10" fill="#666">
                    ${this.formatPeriodDisplay(sortedPeriods[i])}
                </text>`;
        }
        
        // Draw lines for each TP
        const colors = ['#3b82f6', '#10b981', '#f59e0b', '#ef4444', '#8b5cf6'];
        top5TPs.forEach((tpId, idx) => {
            const values = chartData[tpId];
            const color = colors[idx % colors.length];
            
            // Generate path
            let path = '';
            values.forEach((value, i) => {
                const x = padding + i * xScale;
                const y = height - padding - (value / maxValue * chartHeight || 0);
                if (i === 0) {
                    path += `M${x},${y}`;
                } else {
                    path += ` L${x},${y}`;
                }
            });
            
            html += `
                <path d="${path}" fill="none" stroke="${color}" stroke-width="2" opacity="0.8"/>`;
            
            // Add dots
            values.forEach((value, i) => {
                const x = padding + i * xScale;
                const y = height - padding - (value / maxValue * chartHeight || 0);
                html += `
                    <circle cx="${x}" cy="${y}" r="3" fill="${color}">
                        <title>${tpId}: ${this.formatPeriodDisplay(sortedPeriods[i])} - ${value.toLocaleString()} docs</title>
                    </circle>`;
            });
        });
        
        // Legend
        const legendY = 30;
        top5TPs.forEach((tpId, idx) => {
            const color = colors[idx % colors.length];
            const legendX = width - 200 + (idx % 2) * 100;
            const legendYPos = legendY + Math.floor(idx / 2) * 20;
            html += `
                <circle cx="${legendX}" cy="${legendYPos}" r="4" fill="${color}"/>
                <text x="${legendX + 10}" y="${legendYPos + 4}" font-size="11" fill="#666">${tpId.substring(0, 10)}</text>`;
        });
        
        html += `
            </svg>
        </div>`;
        
        return html;
    }

    generateDocTypesAnalysis(docTypesByTP) {
        // Check if we have data
        if (!docTypesByTP || Object.keys(docTypesByTP).length === 0) {
            return `<div class="tp-chart-container">
                <div class="tp-chart-title">📄 Document Types by Trading Partner
                    <span class="info-icon">i
                        <div class="tooltip">
                            This table shows which document types each trading partner processes.
                            It helps understand the nature of your relationships with each partner.
                            Document counts are aggregated across all available periods.
                            Use this to identify specialization patterns among partners.
                        </div>
                    </span>
                </div>
                <p style="text-align: center; color: #718096; padding: 20px;">
                    No document type information available in the data.<br>
                    <small>Document types are typically found in TP_Doc_Summary sheets</small>
                </p>
            </div>`;
        }
        
        // Prepare data for display
        const tpsWithDocTypes = Object.entries(docTypesByTP)
            .filter(([_, types]) => types && types.length > 0)
            .map(([tpId, types]) => ({
                tpId,
                types: types,
                typeCount: types.length
            }))
            .sort((a, b) => b.typeCount - a.typeCount);
        
        // Create a heatmap visualization for top partners and document types
        const allDocTypes = new Set();
        Object.values(docTypesByTP).forEach(types => {
            types.forEach(type => allDocTypes.add(type));
        });
        
        const topTypes = Array.from(allDocTypes).slice(0, 10); // Top 10 document types
        const topPartners = tpsWithDocTypes.slice(0, 10); // Top 10 partners
        
        let html = '';
        
        
        // Original table
        html += `<div class="tp-chart-container">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                <div class="tp-chart-title">📄 Complete Document Types by Trading Partner
                    <span class="info-icon">i
                        <div class="tooltip">
                            This table shows all document types each trading partner processes.
                            It provides a complete view of the nature of your relationships with each partner.
                            Document counts are aggregated across all available periods.
                            Use this to identify specialization patterns among partners.
                        </div>
                    </span>
                </div>
                <div style="display: flex; gap: 10px;">
                    <button onclick="exportTableData('tp-doc-types', 'json')" style="
                        background: #3182ce;
                        color: white;
                        border: none;
                        padding: 8px 16px;
                        border-radius: 5px;
                        cursor: pointer;
                        font-size: 14px;
                        transition: background 0.2s;
                    " onmouseover="this.style.background='#2563eb'" onmouseout="this.style.background='#3182ce'">
                        📥 Export JSON
                    </button>
                    <button onclick="exportTableData('tp-doc-types', 'csv')" style="
                        background: #16a34a;
                        color: white;
                        border: none;
                        padding: 8px 16px;
                        border-radius: 5px;
                        cursor: pointer;
                        font-size: 14px;
                        transition: background 0.2s;
                    " onmouseover="this.style.background='#15803d'" onmouseout="this.style.background='#16a34a'">
                        📥 Export CSV
                    </button>
                    ${window.parent && window.parent.idCrossReference ? `
                    <div style="background: #f3f4f6; padding: 4px; border-radius: 8px; display: flex; gap: 4px; margin-left: 20px;">
                        <span style="padding: 6px 8px; color: #4b5563; font-size: 0.85em;">Display:</span>
                        <button onclick="setTPDisplayMode('id', 'tp-doc-types-table')" 
                            class="display-mode-btn display-mode-id" 
                            data-mode="id"
                            style="
                                padding: 6px 12px;
                                border: none;
                                background: #3b82f6;
                                color: white;
                                border-radius: 6px;
                                cursor: pointer;
                                font-size: 0.85em;
                                transition: all 0.2s;
                            ">ID</button>
                        <button onclick="setTPDisplayMode('name', 'tp-doc-types-table')" 
                            class="display-mode-btn display-mode-name" 
                            data-mode="name"
                            style="
                                padding: 6px 12px;
                                border: none;
                                background: transparent;
                                color: #6b7280;
                                border-radius: 6px;
                                cursor: pointer;
                                font-size: 0.85em;
                                transition: all 0.2s;
                            ">Name</button>
                        <button onclick="setTPDisplayMode('region', 'tp-doc-types-table')" 
                            class="display-mode-btn display-mode-region" 
                            data-mode="region"
                            style="
                                padding: 6px 12px;
                                border: none;
                                background: transparent;
                                color: #6b7280;
                                border-radius: 6px;
                                cursor: pointer;
                                font-size: 0.85em;
                                transition: all 0.2s;
                            ">Region</button>
                    </div>
                    ` : ''}
                </div>
            </div>
            <div style="max-height: 600px; overflow-y: auto;">
            <table class="tp-table" id="tp-doc-types-table">
                <thead style="position: sticky; top: 0; background: white; z-index: 10;">
                    <tr>
                        <th style="background: #f7fafc;">TP ID</th>
                        <th style="background: #f7fafc;">Document Types</th>
                        <th style="background: #f7fafc;">Type Count</th>
                    </tr>
                </thead>
                <tbody>`;
        
        // Show all TPs
        tpsWithDocTypes.forEach((tp, i) => {
            const docTypesHtml = tp.types
                .slice(0, 5)
                .map(dt => `<span class="doc-type-badge">${dt}</span>`)
                .join('');
            
            const moreTypes = tp.types.length > 5 ? 
                `<span class="doc-type-badge">+${tp.types.length - 5} more</span>` : '';
            
            const rowStyle = i % 2 === 1 ? 'style="background: #f7fafc;"' : '';
            
            html += `
                <tr ${rowStyle}>
                    <td class="tp-id-cell" data-id="${tp.tpId}"><strong>${tp.tpId}</strong></td>
                    <td>${docTypesHtml}${moreTypes}</td>
                    <td>${tp.typeCount}</td>
                </tr>`;
        });
        
        html += `
                </tbody>
            </table>
            </div>
            <div class="info-box" style="margin-top: 10px;">
                <strong>Total Trading Partners with Document Types:</strong> ${tpsWithDocTypes.length}
            </div>
        </div>`;
        
        return html;
    }

    generateTPSummaryDashboard(tpAnalysis, tpData) {
        // Calculate key metrics
        const totalTPs = Object.keys(tpAnalysis.tp_totals).length;
        const totalDocs = Object.values(tpAnalysis.tp_totals).reduce((sum, tp) => sum + tp.total_docs, 0);
        const totalKCs = Object.values(tpAnalysis.tp_totals).reduce((sum, tp) => sum + tp.total_kcs, 0);
        const periodsAnalyzed = Object.keys(tpAnalysis.periods).length;
        
        // Calculate growing vs declining partners
        let growingPartners = 0;
        let decliningPartners = 0;
        let stablePartners = 0;
        
        Object.values(tpAnalysis.tp_totals).forEach(tp => {
            if (tp.doc_growth > 5) growingPartners++;
            else if (tp.doc_growth < -5) decliningPartners++;
            else stablePartners++;
        });
        
        // Find top partner and their market share
        const sortedTPs = Object.entries(tpAnalysis.tp_totals)
            .sort((a, b) => b[1].total_docs - a[1].total_docs);
        const topPartner = sortedTPs[0];
        const topPartnerShare = totalDocs > 0 ? (topPartner[1].total_docs / totalDocs * 100).toFixed(1) : 0;
        
        // Calculate average documents per partner
        const avgDocsPerPartner = totalTPs > 0 ? Math.round(totalDocs / totalTPs) : 0;
        
        // Calculate efficiency metrics
        const avgDocsPerKC = totalKCs > 0 ? (totalDocs / totalKCs).toFixed(2) : 0;
        
        let html = `
        <div style="margin-bottom: 30px;">
            <!-- Summary Cards -->
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 20px; margin-bottom: 25px;">
                <!-- Total Partners Card -->
                <div style="background: linear-gradient(135deg, rgba(221, 214, 254, 0.3) 0%, rgba(196, 181, 253, 0.3) 100%); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); border: 1px solid rgba(221, 214, 254, 0.4); color: #6b21a8; padding: 25px; border-radius: 12px; box-shadow: 0 8px 32px rgba(139, 92, 246, 0.1);">
                    <div>
                        <div style="font-size: 0.9em; opacity: 0.8; margin-bottom: 5px; color: #581c87;">Active Trading Partners</div>
                        <div style="font-size: 2.5em; font-weight: bold; margin-bottom: 10px; color: #4c1d95;">${totalTPs.toLocaleString()}</div>
                        <div style="font-size: 0.85em; opacity: 0.8;">
                            <span style="color: #059669; font-weight: 600;">↑ ${growingPartners}</span> • 
                            <span style="color: #f59e0b; font-weight: 600;">→ ${stablePartners}</span> • 
                            <span style="color: #dc2626; font-weight: 600;">↓ ${decliningPartners}</span>
                        </div>
                    </div>
                </div>
                
                <!-- Document Volume Card -->
                <div style="background: linear-gradient(135deg, rgba(147, 197, 253, 0.3) 0%, rgba(96, 165, 250, 0.3) 100%); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); border: 1px solid rgba(147, 197, 253, 0.4); color: #1e40af; padding: 25px; border-radius: 12px; box-shadow: 0 8px 32px rgba(59, 130, 246, 0.1);">
                    <div>
                        <div style="font-size: 0.9em; opacity: 0.8; margin-bottom: 5px; color: #3730a3;">Total Documents</div>
                        <div style="font-size: 2.5em; font-weight: bold; margin-bottom: 10px; color: #1e3a8a;">${this.formatNumber(totalDocs)}</div>
                        <div style="font-size: 0.85em; opacity: 0.7; color: #3730a3;">
                            Avg ${avgDocsPerPartner.toLocaleString()} per partner
                        </div>
                    </div>
                </div>
                
                <!-- Efficiency Card -->
                <div style="background: linear-gradient(135deg, rgba(254, 243, 199, 0.3) 0%, rgba(253, 230, 138, 0.3) 100%); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); border: 1px solid rgba(254, 243, 199, 0.4); color: #b45309; padding: 25px; border-radius: 12px; box-shadow: 0 8px 32px rgba(245, 158, 11, 0.1);">
                    <div>
                        <div style="font-size: 0.9em; opacity: 0.8; margin-bottom: 5px; color: #92400e;">Efficiency Ratio</div>
                        <div style="font-size: 2.5em; font-weight: bold; margin-bottom: 10px; color: #78350f;">${avgDocsPerKC}</div>
                        <div style="font-size: 0.85em; opacity: 0.7; color: #92400e;">
                            Documents per KC
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Partner Distribution Chart -->
            <div style="background: linear-gradient(135deg, rgba(255, 255, 255, 0.5) 0%, rgba(249, 250, 251, 0.5) 100%); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); border: 1px solid rgba(229, 231, 235, 0.4); padding: 25px; border-radius: 12px; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.05); margin-bottom: 25px;">
                <h4 style="margin: 0 0 20px 0; color: #1e293b; font-weight: 600;">Partner Concentration Analysis</h4>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 25px;">
                    <div style="background: rgba(255, 255, 255, 0.6); padding: 15px; border-radius: 8px; border: 1px solid rgba(229, 231, 235, 0.3);">
                        <canvas id="partnerConcentrationChart" width="300" height="300"></canvas>
                    </div>
                    <div style="display: flex; flex-direction: column; justify-content: center;">
                        <h5 style="color: #334155; margin-bottom: 20px; font-weight: 600;">Key Insights</h5>
                        <div style="display: grid; gap: 12px;">
                            ${this.generateConcentrationInsights(tpAnalysis)}
                        </div>
                    </div>
                </div>
            </div>
        </div>`;
        
        // Add script for the pie chart
        html += `<script>
        setTimeout(() => {
            const ctx = document.getElementById('partnerConcentrationChart');
            if (ctx) {
                // Data passed from the server
                const sortedTPData = ${JSON.stringify(sortedTPs.slice(0, 5).map(([id, tp]) => ({
                    id: id,
                    docs: tp.total_docs
                })))};
                const totalDocs = ${totalDocs};
                
                // Calculate partner segments
                const top5Data = [];
                const top5Labels = [];
                let top5Total = 0;
                
                sortedTPData.forEach(tp => {
                    top5Data.push(tp.docs);
                    top5Labels.push(tp.id);
                    top5Total += tp.docs;
                });
                
                if (totalDocs - top5Total > 0) {
                    top5Data.push(totalDocs - top5Total);
                    top5Labels.push('Others');
                }
                
                new Chart(ctx.getContext('2d'), {
                    type: 'doughnut',
                    data: {
                        labels: top5Labels,
                        datasets: [{
                            data: top5Data,
                            backgroundColor: [
                                '#3b82f6',
                                '#10b981',
                                '#f59e0b',
                                '#ef4444',
                                '#8b5cf6',
                                '#e5e7eb'
                            ],
                            borderWidth: 2,
                            borderColor: '#ffffff'
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                position: 'right',
                                labels: {
                                    padding: 15,
                                    font: { size: 12 },
                                    generateLabels: function(chart) {
                                        const data = chart.data;
                                        return data.labels.map((label, i) => {
                                            const value = data.datasets[0].data[i];
                                            const percent = ((value / totalDocs) * 100).toFixed(1);
                                            return {
                                                text: label + ' (' + percent + '%)',
                                                fillStyle: data.datasets[0].backgroundColor[i],
                                                index: i
                                            };
                                        });
                                    }
                                }
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        const value = context.parsed;
                                        const percent = ((value / totalDocs) * 100).toFixed(1);
                                        return context.label + ': ' + value.toLocaleString() + ' docs (' + percent + '%)';
                                    }
                                }
                            }
                        }
                    }
                });
            }
        }, 100);
        </scr` + `ipt>`;
        
        return html;
    }
    
    generateConcentrationInsights(tpAnalysis) {
        const sortedTPs = Object.entries(tpAnalysis.tp_totals)
            .sort((a, b) => b[1].total_docs - a[1].total_docs);
        const totalDocs = Object.values(tpAnalysis.tp_totals).reduce((sum, tp) => sum + tp.total_docs, 0);
        
        let insights = [];
        
        // Calculate concentration metrics
        let cumulative = 0;
        let partners20 = 0;
        let partners50 = 0;
        let partners80 = 0;
        
        for (let i = 0; i < sortedTPs.length; i++) {
            cumulative += sortedTPs[i][1].total_docs;
            const percent = (cumulative / totalDocs) * 100;
            
            if (percent >= 20 && partners20 === 0) partners20 = i + 1;
            if (percent >= 50 && partners50 === 0) partners50 = i + 1;
            if (percent >= 80 && partners80 === 0) partners80 = i + 1;
        }
        
        // Generate insights
        // Calculate top partner's percentage
        const topPartnerPercent = sortedTPs.length > 0 ? (sortedTPs[0][1].total_docs / totalDocs * 100).toFixed(1) : 0;
        
        if (topPartnerPercent >= 20) {
            // If single partner has 20%+ of volume
            insights.push(`<div style="padding: 10px 14px; background: linear-gradient(135deg, rgba(254, 226, 226, 0.4) 0%, rgba(254, 202, 202, 0.4) 100%); backdrop-filter: blur(8px); border: 1px solid rgba(239, 68, 68, 0.3); border-left: 3px solid rgba(239, 68, 68, 0.8); border-radius: 6px; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.03);">
                <strong style="color: #991b1b;">High Concentration:</strong> <span style="color: #7f1d1d;">Top partner accounts for ${topPartnerPercent}% of volume</span>
            </div>`);
        } else if (partners20 <= 3) {
            // If 2-3 partners make up 20% of volume
            const cumulativePercent20 = partners20 > 0 ? ((sortedTPs.slice(0, partners20).reduce((sum, tp) => sum + tp[1].total_docs, 0) / totalDocs) * 100).toFixed(1) : 0;
            insights.push(`<div style="padding: 10px 14px; background: linear-gradient(135deg, rgba(254, 226, 226, 0.4) 0%, rgba(254, 202, 202, 0.4) 100%); backdrop-filter: blur(8px); border: 1px solid rgba(239, 68, 68, 0.3); border-left: 3px solid rgba(239, 68, 68, 0.8); border-radius: 6px; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.03);">
                <strong style="color: #991b1b;">High Concentration:</strong> <span style="color: #7f1d1d;">Top ${partners20} partners account for ${cumulativePercent20}% of volume</span>
            </div>`);
        }
        
        insights.push(`<div style="padding: 10px 14px; background: linear-gradient(135deg, rgba(219, 234, 254, 0.4) 0%, rgba(191, 219, 254, 0.4) 100%); backdrop-filter: blur(8px); border: 1px solid rgba(59, 130, 246, 0.3); border-left: 3px solid rgba(59, 130, 246, 0.8); border-radius: 6px; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.03);">
            <strong style="color: #1e40af;">80/20 Rule:</strong> <span style="color: #1e3a8a;">${partners80} out of ${sortedTPs.length} partners (${(partners80 / sortedTPs.length * 100).toFixed(0)}%) drive 80% of volume</span>
        </div>`);
        
        const avgDocsPerPartner = Math.round(totalDocs / sortedTPs.length);
        const partnersAboveAvg = sortedTPs.filter(([_, tp]) => tp.total_docs > avgDocsPerPartner).length;
        
        insights.push(`<div style="padding: 10px 14px; background: linear-gradient(135deg, rgba(209, 250, 229, 0.4) 0%, rgba(167, 243, 208, 0.4) 100%); backdrop-filter: blur(8px); border: 1px solid rgba(16, 185, 129, 0.3); border-left: 3px solid rgba(16, 185, 129, 0.8); border-radius: 6px; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.03);">
            <strong style="color: #065f46;">Distribution:</strong> <span style="color: #064e3b;">${partnersAboveAvg} out of ${sortedTPs.length} partners (${(partnersAboveAvg / sortedTPs.length * 100).toFixed(0)}%) exceed avg of ${avgDocsPerPartner.toLocaleString()} docs</span>
        </div>`);
        
        return insights.join('');
    }
    
    formatNumber(num) {
        if (num >= 1000000) {
            return (num / 1000000).toFixed(1) + 'M';
        } else if (num >= 1000) {
            return (num / 1000).toFixed(1) + 'K';
        }
        return num.toLocaleString();
    }
    
    generateTPSeasonalityAnalysis(tpAnalysis) {
        // Get ALL partners sorted by volume
        const allPartners = Object.entries(tpAnalysis.tp_totals)
            .sort((a, b) => b[1].total_docs - a[1].total_docs);
        
        if (allPartners.length === 0) {
            return '';
        }
        
        let html = `
        <div style="margin-top: 30px;">
            <h4 style="color: #2d3748; margin-bottom: 20px;">🌊 Partner Seasonality Patterns - All Trading Partners
                <span class="info-icon">i
                    <div class="tooltip">
                        This matrix shows seasonal patterns for ALL trading partners.
                        Each cell shows the monthly variation from that partner's average.
                        Green indicates above average months, red indicates below average.
                        Partners are sorted by total volume (highest to lowest).
                    </div>
                </span>
            </h4>
            <div style="background: white; padding: 15px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.05);">
                ${window.parent && window.parent.idCrossReference ? `
                <div style="margin-bottom: 10px; display: flex; justify-content: flex-end;">
                    <div style="background: #f3f4f6; padding: 4px; border-radius: 8px; display: flex; gap: 4px;">
                        <span style="padding: 6px 8px; color: #4b5563; font-size: 0.85em;">Display:</span>
                        <button onclick="setTPDisplayMode('id', 'tp-seasonality-table')" 
                            class="display-mode-btn display-mode-id" 
                            data-mode="id"
                            style="
                                padding: 6px 12px;
                                border: none;
                                background: #3b82f6;
                                color: white;
                                border-radius: 6px;
                                cursor: pointer;
                                font-size: 0.85em;
                                transition: all 0.2s;
                            ">ID</button>
                        <button onclick="setTPDisplayMode('name', 'tp-seasonality-table')" 
                            class="display-mode-btn display-mode-name" 
                            data-mode="name"
                            style="
                                padding: 6px 12px;
                                border: none;
                                background: transparent;
                                color: #6b7280;
                                border-radius: 6px;
                                cursor: pointer;
                                font-size: 0.85em;
                                transition: all 0.2s;
                            ">Name</button>
                        <button onclick="setTPDisplayMode('region', 'tp-seasonality-table')" 
                            class="display-mode-btn display-mode-region" 
                            data-mode="region"
                            style="
                                padding: 6px 12px;
                                border: none;
                                background: transparent;
                                color: #6b7280;
                                border-radius: 6px;
                                cursor: pointer;
                                font-size: 0.85em;
                                transition: all 0.2s;
                            ">Region</button>
                    </div>
                </div>
                ` : ''}
                <div style="max-height: 400px; overflow-y: auto; overflow-x: auto; border: 1px solid #e2e8f0;">
                    <table id="tp-seasonality-table" style="border-collapse: collapse; width: 100%; font-size: 0.75em;">
                        <thead style="position: sticky; top: 0; z-index: 20;">
                            <tr>
                                <th style="text-align: left; padding: 4px 6px; background: #f7fafc; border: 1px solid #e2e8f0; position: sticky; left: 0; z-index: 21; min-width: 80px;">Partner</th>
                                <th style="text-align: right; padding: 4px 6px; background: #f7fafc; border: 1px solid #e2e8f0; min-width: 70px;">Avg/Mo</th>
                                ${['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'].map(month => 
                                    `<th style="text-align: center; padding: 4px 6px; background: #f7fafc; border: 1px solid #e2e8f0; min-width: 80px; font-size: 0.85em;">${month}</th>`
                                ).join('')}
                            </tr>
                        </thead>
                        <tbody>`;
        
        // Calculate seasonality for ALL partners
        allPartners.forEach(([tpId, tpInfo], index) => {
            const monthlyVolumes = {};
            const monthCounts = {};
            
            // Aggregate volumes by month for this partner
            tpInfo.periods.forEach((period, idx) => {
                const month = period.split('-')[1];
                if (!monthlyVolumes[month]) {
                    monthlyVolumes[month] = 0;
                    monthCounts[month] = 0;
                }
                monthlyVolumes[month] += tpInfo.doc_values[idx] || 0;
                monthCounts[month]++;
            });
            
            // Calculate monthly averages
            const monthlyAverages = {};
            Object.keys(monthlyVolumes).forEach(month => {
                monthlyAverages[month] = monthlyVolumes[month] / monthCounts[month];
            });
            
            const values = Object.values(monthlyAverages);
            const overallAverage = values.length > 0 ? values.reduce((a, b) => a + b, 0) / values.length : 0;
            
            // Calculate seasonality factors
            const seasonalityFactors = {};
            Object.keys(monthlyAverages).forEach(month => {
                if (overallAverage > 0) {
                    seasonalityFactors[month] = ((monthlyAverages[month] - overallAverage) / overallAverage * 100).toFixed(1);
                } else {
                    seasonalityFactors[month] = '0.0';
                }
            });
            
            // Create table row for this partner
            html += `<tr style="${index % 2 === 0 ? 'background: #f9fafb;' : ''}">
                <td class="tp-id-cell" data-id="${tpId}" style="padding: 4px 6px; border: 1px solid #e2e8f0; font-weight: 500; position: sticky; left: 0; background: ${index % 2 === 0 ? '#f9fafb' : '#ffffff'}; z-index: 5; font-size: 0.85em;">${tpId}</td>
                <td style="padding: 4px 6px; border: 1px solid #e2e8f0; text-align: right; font-size: 0.85em;">${Math.round(overallAverage).toLocaleString()}</td>`;
            
            // Display month cells
            const months = ['01', '02', '03', '04', '05', '06', '07', '08', '09', '10', '11', '12'];
            
            months.forEach((month) => {
                const factor = parseFloat(seasonalityFactors[month] || 0);
                let bgColor, textColor, intensity;
                
                // Calculate color intensity based on factor magnitude
                if (factor > 20) {
                    bgColor = '#065f46';
                    textColor = '#ffffff';
                    intensity = 1;
                } else if (factor > 10) {
                    bgColor = '#10b981';
                    textColor = '#ffffff';
                    intensity = 0.8;
                } else if (factor > 5) {
                    bgColor = '#34d399';
                    textColor = '#065f46';
                    intensity = 0.6;
                } else if (factor > 0) {
                    bgColor = '#86efac';
                    textColor = '#065f46';
                    intensity = 0.4;
                } else if (factor < -20) {
                    bgColor = '#991b1b';
                    textColor = '#ffffff';
                    intensity = 1;
                } else if (factor < -10) {
                    bgColor = '#ef4444';
                    textColor = '#ffffff';
                    intensity = 0.8;
                } else if (factor < -5) {
                    bgColor = '#f87171';
                    textColor = '#991b1b';
                    intensity = 0.6;
                } else if (factor < 0) {
                    bgColor = '#fca5a5';
                    textColor = '#991b1b';
                    intensity = 0.4;
                } else {
                    bgColor = '#f3f4f6';
                    textColor = '#374151';
                    intensity = 0.2;
                }
                
                // Show value or dash if no data
                const displayValue = seasonalityFactors[month] ? 
                    `${factor > 0 ? '+' : ''}${factor}%` : 
                    '-';
                
                html += `
                <td style="
                    padding: 3px;
                    border: 1px solid #e2e8f0;
                    text-align: center;
                    background: ${bgColor};
                    color: ${textColor};
                    font-weight: ${Math.abs(factor) > 10 ? '600' : '400'};
                    font-size: 0.75em;
                    min-width: 45px;
                ">${displayValue}</td>`;
            });
            
            html += `</tr>`;
        });
        
        html += `
                        </tbody>
                    </table>
                </div>
                <div style="margin-top: 10px; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 10px;">
                    <div style="font-size: 0.7em; color: #6b7280; display: flex; align-items: center; flex-wrap: wrap; gap: 8px;">
                        <strong>Legend:</strong>
                        <span style="display: flex; align-items: center;">
                            <span style="display: inline-block; width: 12px; height: 10px; background: #065f46; margin-right: 3px; border-radius: 2px;"></span>
                            <span>+20%+</span>
                        </span>
                        <span style="display: flex; align-items: center;">
                            <span style="display: inline-block; width: 12px; height: 10px; background: #10b981; margin-right: 3px; border-radius: 2px;"></span>
                            <span>+10-20%</span>
                        </span>
                        <span style="display: flex; align-items: center;">
                            <span style="display: inline-block; width: 12px; height: 10px; background: #86efac; margin-right: 3px; border-radius: 2px;"></span>
                            <span>0-10%</span>
                        </span>
                        <span style="display: flex; align-items: center;">
                            <span style="display: inline-block; width: 12px; height: 10px; background: #f3f4f6; margin-right: 3px; border-radius: 2px;"></span>
                            <span>Avg</span>
                        </span>
                        <span style="display: flex; align-items: center;">
                            <span style="display: inline-block; width: 12px; height: 10px; background: #fca5a5; margin-right: 3px; border-radius: 2px;"></span>
                            <span>-10-0%</span>
                        </span>
                        <span style="display: flex; align-items: center;">
                            <span style="display: inline-block; width: 12px; height: 10px; background: #ef4444; margin-right: 3px; border-radius: 2px;"></span>
                            <span>-20--10%</span>
                        </span>
                        <span style="display: flex; align-items: center;">
                            <span style="display: inline-block; width: 12px; height: 10px; background: #991b1b; margin-right: 3px; border-radius: 2px;"></span>
                            <span>-20%+</span>
                        </span>
                    </div>
                    <div style="display: flex; gap: 8px;">
                        <button onclick="exportPartnerSeasonality('json')" style="
                            background: #3182ce;
                            color: white;
                            border: none;
                            padding: 6px 12px;
                            border-radius: 4px;
                            cursor: pointer;
                            font-size: 0.8em;
                        ">📥 Export JSON</button>
                        <button onclick="exportPartnerSeasonality('csv')" style="
                            background: #16a34a;
                            color: white;
                            border: none;
                            padding: 6px 12px;
                            border-radius: 4px;
                            cursor: pointer;
                            font-size: 0.8em;
                        ">📥 Export CSV</button>
                    </div>
                </div>
            </div>
        </div>`;
        
        // Add export functionality
        html += `
        <script>
        window.exportPartnerSeasonality = function(format) {
            // Find the seasonality table
            const tables = document.querySelectorAll('table');
            let seasonalityTable = null;
            
            // Find the table that contains Partner Seasonality data
            for (let table of tables) {
                const firstCell = table.querySelector('th');
                if (firstCell && firstCell.textContent.trim() === 'Partner') {
                    const avgCell = table.querySelector('th:nth-child(2)');
                    if (avgCell && avgCell.textContent.includes('Avg/Mo')) {
                        seasonalityTable = table;
                        break;
                    }
                }
            }
            
            if (!seasonalityTable) {
                alert('Seasonality table not found');
                return;
            }
            
            // Extract data from table
            const headers = [];
            const rows = [];
            
            // Get headers
            const headerCells = seasonalityTable.querySelectorAll('thead th');
            headerCells.forEach(cell => {
                headers.push(cell.textContent.trim());
            });
            
            // Get data rows
            const dataRows = seasonalityTable.querySelectorAll('tbody tr');
            dataRows.forEach(row => {
                const rowData = [];
                const cells = row.querySelectorAll('td');
                cells.forEach(cell => {
                    rowData.push(cell.textContent.trim());
                });
                if (rowData.length > 0) {
                    rows.push(rowData);
                }
            });
            
            let content, filename;
            const timestamp = new Date().toISOString().split('T')[0];
            
            if (format === 'json') {
                // Convert to JSON format
                const jsonData = rows.map(row => {
                    const obj = {};
                    headers.forEach((header, index) => {
                        obj[header] = row[index];
                    });
                    return obj;
                });
                
                content = JSON.stringify(jsonData, null, 2);
                filename = 'partner-seasonality-' + timestamp + '.json';
            } else if (format === 'csv') {
                // Convert to CSV format
                const csvRows = [headers.join(',')];
                rows.forEach(row => {
                    csvRows.push(row.map(cell => {
                        // Escape quotes and wrap in quotes if contains comma
                        const value = cell.replace(/"/g, '""');
                        return value.includes(',') ? '"' + value + '"' : value;
                    }).join(','));
                });
                
                content = csvRows.join('\\n');
                filename = 'partner-seasonality-' + timestamp + '.csv';
            }
            
            // Download file
            const blob = new Blob([content], { type: format === 'json' ? 'application/json' : 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
        };
        </scr` + `ipt>`;
        
        return html;
    }
    
    calculatePartnerHealthScore(tpInfo) {
        let score = 0;
        let factors = [];
        
        // Growth factor (30 points)
        if (tpInfo.doc_growth > 20) {
            score += 30;
            factors.push('Strong growth');
        } else if (tpInfo.doc_growth > 5) {
            score += 20;
            factors.push('Moderate growth');
        } else if (tpInfo.doc_growth > -5) {
            score += 10;
            factors.push('Stable');
        } else {
            factors.push('Declining');
        }
        
        // Volume consistency (25 points)
        if (tpInfo.doc_values && tpInfo.doc_values.length > 3) {
            const recent = tpInfo.doc_values.slice(-3);
            const avg = recent.reduce((a, b) => a + b, 0) / recent.length;
            const variance = recent.reduce((sum, val) => sum + Math.pow(val - avg, 2), 0) / recent.length;
            const cv = avg > 0 ? Math.sqrt(variance) / avg : 1; // Coefficient of variation
            
            if (cv < 0.1) {
                score += 25;
                factors.push('Very consistent');
            } else if (cv < 0.3) {
                score += 15;
                factors.push('Consistent');
            } else if (cv < 0.5) {
                score += 5;
                factors.push('Variable');
            } else {
                factors.push('Highly variable');
            }
        }
        
        // Document diversity (25 points) - using efficiency as proxy
        const efficiency = tpInfo.total_kcs > 0 ? tpInfo.total_docs / tpInfo.total_kcs : 0;
        if (efficiency > 5) {
            score += 25;
            factors.push('High efficiency');
        } else if (efficiency > 3) {
            score += 15;
            factors.push('Good efficiency');
        } else if (efficiency > 1) {
            score += 5;
            factors.push('Low efficiency');
        }
        
        // Volume significance (20 points)
        // This will be calculated relative to average in the calling context
        const avgDocsPerPartner = tpInfo.avg_docs_per_partner || 0;
        if (tpInfo.total_docs > avgDocsPerPartner * 2) {
            score += 20;
            factors.push('High volume');
        } else if (tpInfo.total_docs > avgDocsPerPartner) {
            score += 10;
            factors.push('Above average volume');
        } else if (tpInfo.total_docs > avgDocsPerPartner * 0.5) {
            score += 5;
            factors.push('Below average volume');
        } else {
            factors.push('Low volume');
        }
        
        // Determine health level and badge
        let level, color, bgColor, icon;
        if (score >= 80) {
            level = 'Excellent';
            color = '#065f46';
            bgColor = '#d1fae5';
            icon = '🌟';
        } else if (score >= 60) {
            level = 'Good';
            color = '#059669';
            bgColor = '#86efac';
            icon = '✅';
        } else if (score >= 40) {
            level = 'Fair';
            color = '#d97706';
            bgColor = '#fed7aa';
            icon = '⚠️';
        } else {
            level = 'At Risk';
            color = '#dc2626';
            bgColor = '#fee2e2';
            icon = '⚡';
        }
        
        const tooltip = `Health Score: ${score}/100\n${factors.join(', ')}`;
        const badge = `<span style="
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 4px 12px;
            background: ${bgColor};
            color: ${color};
            border-radius: 20px;
            font-size: 0.85em;
            font-weight: 600;
            cursor: help;
        " title="${tooltip}">
            ${icon} ${level}
        </span>`;
        
        return {
            score,
            level,
            badge,
            factors
        };
    }

    // Document Analysis Helper Methods
    extractDocumentData(data) {
        const docData = {};
        
        // Look for document-related sheets
        const docSheets = [];
        const sheetsAnalyzed = data.sheets_analyzed || [];
        
        for (const sheetName of sheetsAnalyzed) {
            if (sheetName.toLowerCase().includes('doc') && 
                (sheetName.toLowerCase().includes('summary') || sheetName.toLowerCase().includes('tp'))) {
                docSheets.push(sheetName);
            }
        }
        
        if (docSheets.length === 0) {
            return null;
        }
        
        
        // Extract data for each period
        for (const period of Object.keys(data.summary || {}).sort()) {
            docData[period] = {
                documents_by_type: {},
                documents_by_tp: {},
                tp_type_matrix: {},
                tp_type_kc_matrix: {}
            };
            
            // Check stored data
            if (data.tp_data && data.tp_data[period]) {
                for (const [sheetName, sheetRows] of Object.entries(data.tp_data[period])) {
                    if (docSheets.includes(sheetName)) {
                        for (const row of sheetRows) {
                            // Extract TP - handle columns with spaces
                            let tpId = null;
                            let docType = null;
                            
                            for (const [key, value] of Object.entries(row)) {
                                const keyStripped = key.trim();
                                if (['TP ID', 'TP-ID', 'Trading Partner', 'TP_ID', 'TP'].includes(keyStripped)) {
                                    tpId = value ? String(value).trim() : null;
                                } else if (['DOCS', 'DOC', 'Docs', 'docs', 'Document Type', 'Doc Type', 'DOC_TYPE', 'DOC TYPE'].includes(keyStripped)) {
                                    docType = value ? String(value).trim() : null;
                                }
                            }
                            
                            if (tpId && docType) {
                                // Get actual document volumes and KCs - handle columns with spaces
                                let totalDocs = 0;
                                let inbDocs = 0;
                                let outDocs = 0;
                                let totalKcs = 0;
                                let inbKcs = 0;
                                let outKcs = 0;
                                
                                // Log column names for debugging
                                if (!this._columnsLogged) {
                                    this._columnsLogged = true;
                                }
                                
                                for (const [key, value] of Object.entries(row)) {
                                    const keyStripped = key.trim();
                                    const keyUpper = keyStripped.toUpperCase();
                                    
                                    // Check for document columns - more flexible matching
                                    if (keyUpper === 'TOTAL-DOC' || keyUpper === 'TOTAL DOCS' || keyUpper === 'TTL DOCS' ||
                                        keyUpper === 'TOTAL DOC' || keyUpper === 'TTL-DOC' || keyUpper === 'TOTAL_DOCS') {
                                        totalDocs = parseFloat(value) || 0;
                                        if (totalDocs > 0 && !this._foundDocsLogged) {
                                            this._foundDocsLogged = true;
                                        }
                                    } else if (keyUpper === 'INB-DOC' || keyUpper === 'INBOUND DOCS' || keyUpper === 'INB DOCS' ||
                                              keyUpper === 'INBOUND DOC' || keyUpper === 'INB_DOCS') {
                                        inbDocs = parseFloat(value) || 0;
                                    } else if (keyUpper === 'OUTB-DOC' || keyUpper === 'OUTBOUND DOCS' || keyUpper === 'OUT DOCS' ||
                                              keyUpper === 'OUTBOUND DOC' || keyUpper === 'OUT-DOC' || keyUpper === 'OUT_DOCS') {
                                        outDocs = parseFloat(value) || 0;
                                    }
                                    // Check for KC columns
                                    else if (keyUpper === 'TOTAL-KCS' || keyUpper === 'TOTAL KCS' || keyUpper === 'TTL KCS' ||
                                            keyUpper === 'TOTAL KC' || keyUpper === 'TTL-KC' || keyUpper === 'TOTAL_KCS') {
                                        totalKcs = parseFloat(value) || 0;
                                        if (totalKcs > 0 && !this._foundKcsLogged) {
                                            this._foundKcsLogged = true;
                                        }
                                    } else if (keyUpper === 'INB-KCS' || keyUpper === 'INBOUND KCS' || keyUpper === 'INB KCS' ||
                                              keyUpper === 'INBOUND KC' || keyUpper === 'INB_KCS') {
                                        inbKcs = parseFloat(value) || 0;
                                    } else if (keyUpper === 'OUTB-KCS' || keyUpper === 'OUTBOUND KCS' || keyUpper === 'OUT KCS' ||
                                              keyUpper === 'OUTBOUND KC' || keyUpper === 'OUT-KCS' || keyUpper === 'OUT_KCS') {
                                        outKcs = parseFloat(value) || 0;
                                    }
                                }
                                
                                // Store in matrices
                                if (!docData[period].tp_type_matrix[tpId]) {
                                    docData[period].tp_type_matrix[tpId] = {};
                                }
                                if (!docData[period].tp_type_kc_matrix[tpId]) {
                                    docData[period].tp_type_kc_matrix[tpId] = {};
                                }
                                
                                docData[period].tp_type_matrix[tpId][docType] = {
                                    total: totalDocs,
                                    inbound: inbDocs,
                                    outbound: outDocs
                                };
                                
                                docData[period].tp_type_kc_matrix[tpId][docType] = {
                                    total: totalKcs,
                                    inbound: inbKcs,
                                    outbound: outKcs
                                };
                                
                                // Update document by type summary
                                if (!docData[period].documents_by_type[docType]) {
                                    docData[period].documents_by_type[docType] = {
                                        total_docs: 0,
                                        total_kcs: 0,
                                        tp_count: 0
                                    };
                                }
                                docData[period].documents_by_type[docType].total_docs += totalDocs;
                                docData[period].documents_by_type[docType].total_kcs += totalKcs;
                                docData[period].documents_by_type[docType].tp_count += 1;
                                
                                // Update documents by TP summary
                                if (!docData[period].documents_by_tp[tpId]) {
                                    docData[period].documents_by_tp[tpId] = {
                                        total_docs: 0,
                                        total_kcs: 0,
                                        doc_types: 0
                                    };
                                }
                                docData[period].documents_by_tp[tpId].total_docs += totalDocs;
                                docData[period].documents_by_tp[tpId].total_kcs += totalKcs;
                                docData[period].documents_by_tp[tpId].doc_types += 1;
                                
                                // Log when we find data
                                if ((totalDocs > 0 || totalKcs > 0) && !this._dataFoundLogged) {
                                    this._dataFoundLogged = true;
                                }
                            }
                        }
                    }
                }
            }
        }
        
        
        return docData;
    }

    analyzeDocumentTrends(docData) {
        const analysis = {
            periods: Object.keys(docData).sort(),
            document_types: new Set(),
            tp_document_counts: {},
            type_trends: {},
            monthly_totals: {},
            total_documents: 0
        };
        
        // Collect all document types and calculate trends
        for (const period of analysis.periods) {
            const periodData = docData[period];
            let monthlyTotal = 0;
            
            // Document types
            for (const [docType, data] of Object.entries(periodData.documents_by_type)) {
                analysis.document_types.add(docType);
                
                if (!analysis.type_trends[docType]) {
                    analysis.type_trends[docType] = {
                        periods: [],
                        counts: [],
                        kcs: []
                    };
                }
                
                analysis.type_trends[docType].periods.push(period);
                analysis.type_trends[docType].counts.push(data.total_docs);
                analysis.type_trends[docType].kcs.push(data.total_kcs);
                monthlyTotal += data.total_docs;
                analysis.total_documents += data.total_docs;
            }
            
            // TP counts
            for (const [tpId, data] of Object.entries(periodData.documents_by_tp)) {
                if (!analysis.tp_document_counts[tpId]) {
                    analysis.tp_document_counts[tpId] = 0;
                }
                analysis.tp_document_counts[tpId] += data.total_docs;
            }
            
            analysis.monthly_totals[period] = monthlyTotal;
        }
        
        return analysis;
    }

    generateMonthlyDocAnalysis(docAnalysis) {
        let html = `<div class="doc-analysis-container">
            <h4 style="color: #2d3748; margin-bottom: 20px;">📊 Document Volume Summary
                <span class="info-icon">i
                    <div class="tooltip">
                        Document Volume Summary provides a comprehensive overview of all document types.
                        It shows total volumes, percentages of overall traffic, and trend indicators.
                        The summary helps identify your most important document types at a glance.
                        Use this to prioritize optimization efforts and resource allocation.
                    </div>
                </span>
            </h4>`;
        
        // Get recent periods for comparison
        const periods = docAnalysis.periods;
        if (periods.length >= 2) {
            const currentPeriod = periods[periods.length - 1];
            const prevPeriod = periods[periods.length - 2];
            
            const currentTotal = docAnalysis.monthly_totals[currentPeriod];
            const prevTotal = docAnalysis.monthly_totals[prevPeriod];
            
            // Calculate change
            const change = prevTotal > 0 ? ((currentTotal - prevTotal) / prevTotal * 100) : 0;
            const changeClass = change > 0 ? "change-positive" : change < 0 ? "change-negative" : "";
            
            // Calculate average
            const totalVolume = Object.values(docAnalysis.monthly_totals).reduce((sum, val) => sum + val, 0);
            const avgVolume = periods.length > 0 ? totalVolume / periods.length : 0;
            
            html += `
            <div class="metrics-grid" style="margin-bottom: 30px;">
                <div class="metric-card">
                    <div class="metric-label">Current Period (${this.formatPeriodDisplay(currentPeriod)})</div>
                    <div class="metric-value">${currentTotal.toLocaleString()}</div>
                    <div class="metric-detail">Documents Processed</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Period-over-Period Change</div>
                    <div class="metric-value ${changeClass}">${change >= 0 ? '+' : ''}${change.toFixed(1)}%</div>
                    <div class="metric-detail">vs ${this.formatPeriodDisplay(prevPeriod)}</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Average Volume</div>
                    <div class="metric-value">${Math.round(avgVolume).toLocaleString()}</div>
                    <div class="metric-detail">Per Period</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Total Documents</div>
                    <div class="metric-value">${docAnalysis.total_documents.toLocaleString()}</div>
                    <div class="metric-detail">All Periods</div>
                </div>
            </div>`;
        }
        
        // Monthly breakdown table
        if (periods.length > 0) {
            html += `
            <div class="doc-table-container" style="margin-top: 30px;">
                <h5 style="color: #4a5568; margin-bottom: 15px; font-size: 1.1em;">📅 Period Breakdown - All Periods</h5>
                <div style="max-height: 400px; overflow-y: auto; border: 1px solid #e2e8f0; border-radius: 8px;">
                    <table class="data-table" style="width: 100%;">
                        <thead style="position: sticky; top: 0; background: #f7fafc; z-index: 10;">
                            <tr>
                                <th style="text-align: left; padding: 12px;">Period</th>
                                <th style="text-align: right; padding: 12px;">Document Count</th>
                                <th style="text-align: right; padding: 12px;">KC Count</th>
                                <th style="text-align: center; padding: 12px;">Doc Change</th>
                                <th style="text-align: center; padding: 12px;">KC Change</th>
                            </tr>
                        </thead>
                        <tbody>`;
            
            // Calculate KC totals per period
            const kcTotals = {};
            Object.values(docAnalysis.type_trends).forEach(trend => {
                trend.periods.forEach((period, index) => {
                    kcTotals[period] = (kcTotals[period] || 0) + (trend.kcs[index] || 0);
                });
            });
            
            // Show all periods instead of just last 6
            periods.forEach((period, index) => {
                const docCount = docAnalysis.monthly_totals[period];
                const kcCount = kcTotals[period] || 0;
                let docChangeText = '-';
                let kcChangeText = '-';
                
                if (index > 0) {
                    const prevDocCount = docAnalysis.monthly_totals[periods[index - 1]];
                    const prevKcCount = kcTotals[periods[index - 1]] || 0;
                    
                    if (prevDocCount > 0) {
                        const docChange = ((docCount - prevDocCount) / prevDocCount * 100);
                        const changeClass = docChange > 0 ? 'change-positive' : docChange < 0 ? 'change-negative' : '';
                        docChangeText = `<span class="${changeClass}">${docChange >= 0 ? '+' : ''}${docChange.toFixed(1)}%</span>`;
                    }
                    
                    if (prevKcCount > 0) {
                        const kcChange = ((kcCount - prevKcCount) / prevKcCount * 100);
                        const changeClass = kcChange > 0 ? 'change-positive' : kcChange < 0 ? 'change-negative' : '';
                        kcChangeText = `<span class="${changeClass}">${kcChange >= 0 ? '+' : ''}${kcChange.toFixed(1)}%</span>`;
                    }
                }
                
                // Highlight the most recent period
                const rowStyle = index === periods.length - 1 ? ' style="background-color: #e6f7ff;"' : '';
                
                html += `
                        <tr${rowStyle}>
                            <td style="padding: 10px;"><strong>${this.formatPeriodDisplay(period)}</strong></td>
                            <td style="text-align: right; padding: 10px;">${docCount.toLocaleString()}</td>
                            <td style="text-align: right; padding: 10px;">${Math.round(kcCount).toLocaleString()}</td>
                            <td style="text-align: center; padding: 10px;">${docChangeText}</td>
                            <td style="text-align: center; padding: 10px;">${kcChangeText}</td>
                        </tr>`;
            });
            
            // Add totals row
            const totalDocs = Object.values(docAnalysis.monthly_totals).reduce((sum, val) => sum + val, 0);
            const totalKCs = Object.values(kcTotals).reduce((sum, val) => sum + val, 0);
            
            html += `
                        <tr style="border-top: 2px solid #cbd5e0; font-weight: bold; background-color: #f7fafc;">
                            <td style="padding: 10px;">Total</td>
                            <td style="text-align: right; padding: 10px;">${totalDocs.toLocaleString()}</td>
                            <td style="text-align: right; padding: 10px;">${Math.round(totalKCs).toLocaleString()}</td>
                            <td style="text-align: center; padding: 10px;">-</td>
                            <td style="text-align: center; padding: 10px;">-</td>
                        </tr>
                    </tbody>
                </table>
                </div>
            </div>`;
        }
        
        html += `</div>`;
        return html;
    }

    generateDocTypeDistribution(docAnalysis) {
        let html = `<div class="doc-distribution-wrapper">
            <h4 style="color: #2d3748; margin-bottom: 10px; font-size: 1.2em;">📊 Document Type Distribution
                <span class="info-icon">i
                    <div class="tooltip">
                        Document Type Distribution visualizes the relative volume of each document type.
                        The bar chart shows what percentage of total documents each type represents.
                        This helps understand your document mix and identify dominant types.
                        Use this to ensure balanced processing across different document categories.
                    </div>
                </span>
            </h4>
            <p style="color: #718096; font-size: 0.9em; margin-bottom: 20px;">Overview of document types processed across all periods</p>
            <div class="doc-type-grid">`;
        
        // Calculate total for each document type
        const typeTotals = {};
        for (const [docType, trendData] of Object.entries(docAnalysis.type_trends)) {
            typeTotals[docType] = trendData.counts.reduce((sum, count) => sum + count, 0);
        }
        
        // Sort by total count - show all document types
        const sortedTypes = Object.entries(typeTotals)
            .sort(([, a], [, b]) => b - a);
        
        const totalDocs = Object.values(typeTotals).reduce((sum, count) => sum + count, 0);
        
        // Create document type cards
        sortedTypes.forEach(([docType, count]) => {
            const percentage = (count / totalDocs * 100).toFixed(1);
            const trendData = docAnalysis.type_trends[docType];
            
            // No trend indicators as requested
            
            html += `
                <div class="doc-type-card">
                    <div class="doc-type-name">${docType}</div>
                    <div class="doc-type-count">${count.toLocaleString()}</div>
                    <div class="doc-type-percentage">${percentage}%</div>
                </div>`;
        });
        
        html += `
            </div>
            <!-- Trend analysis note removed as requested -->
        </div>`;
        
        return html;
    }

    generateDocKCTrendsChart(docAnalysis, data) {
        
        let html = `<div class="chart-container" style="background: white; padding: 25px; border-radius: 12px; margin-bottom: 30px; box-shadow: 0 2px 8px rgba(0,0,0,0.05);">
            <h4 style="color: #2d3748; margin-bottom: 20px;">📊 Document Count vs KC Count Trends
                <span class="info-icon">i
                    <div class="tooltip">
                        This chart shows the total document count and KC count trends over time.
                        The dual-axis chart helps visualize the relationship between document volume and KC processing.
                        Use this to identify efficiency trends and processing patterns across periods.
                    </div>
                </span>
            </h4>
            <div style="position: relative; height: 400px;">
                <canvas id="docKCTrendsChart"></canvas>
            </div>
        </div>`;
        
        // Calculate total document counts and KC counts per period
        const docCounts = {};
        const kcCounts = {};
        
        docAnalysis.periods.forEach(period => {
            docCounts[period] = 0;
            kcCounts[period] = 0;
        });
        
        // Sum up document counts across all types
        if (docAnalysis.type_trends) {
            Object.values(docAnalysis.type_trends).forEach(trend => {
                trend.periods.forEach((period, index) => {
                    if (trend.counts && trend.counts[index]) {
                        docCounts[period] = (docCounts[period] || 0) + trend.counts[index];
                    }
                });
            });
        } else if (docAnalysis.monthly_totals) {
            // Use monthly totals if available
            Object.entries(docAnalysis.monthly_totals).forEach(([period, total]) => {
                docCounts[period] = total;
            });
        }
        
        // Extract KC counts from type_trends
        if (docAnalysis.type_trends) {
            Object.values(docAnalysis.type_trends).forEach(trend => {
                trend.periods.forEach((period, index) => {
                    if (trend.kcs && trend.kcs[index]) {
                        kcCounts[period] = (kcCounts[period] || 0) + trend.kcs[index];
                    }
                });
            });
        }
        
        // If no KC data from type_trends, try data.summary
        if (Object.values(kcCounts).every(v => v === 0) && data && data.summary) {
            Object.entries(data.summary).forEach(([period, periodData]) => {
                // Look for total_kcs or calculate from documents
                if (periodData.total_kcs) {
                    kcCounts[period] = periodData.total_kcs;
                } else if (periodData.total_documents_kcs) {
                    kcCounts[period] = periodData.total_documents_kcs;
                }
            });
        }
        
        const docCountData = docAnalysis.periods.map(period => docCounts[period] || 0);
        const kcCountData = docAnalysis.periods.map(period => Math.round(kcCounts[period] || 0));
        
        // Calculate trend lines using linear regression
        const calculateTrendLine = (data) => {
            const n = data.length;
            let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;
            
            for (let i = 0; i < n; i++) {
                sumX += i;
                sumY += data[i];
                sumXY += i * data[i];
                sumX2 += i * i;
            }
            
            const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
            const intercept = (sumY - slope * sumX) / n;
            
            return data.map((_, i) => Math.round(slope * i + intercept));
        };
        
        const docTrendData = calculateTrendLine(docCountData);
        const kcTrendData = calculateTrendLine(kcCountData);
        
        // Format period labels
        const periodLabels = docAnalysis.periods.map(p => this.formatPeriodDisplay(p));
        
        const chartScript = `<scr` + `ipt>`+`
            setTimeout(() => {
                try {
                    const ctx = document.getElementById('docKCTrendsChart');
                    if (ctx) {
                        new Chart(ctx.getContext('2d'), {
                            type: 'line',
                            data: {
                                labels: ` + JSON.stringify(periodLabels) + `,
                                datasets: [
                                    {
                                        label: 'Document Count',
                                        data: ` + JSON.stringify(docCountData) + `,
                                        borderColor: 'rgba(59, 130, 246, 1)',
                                        backgroundColor: 'rgba(59, 130, 246, 0.1)',
                                        tension: 0.2,
                                        yAxisID: 'y',
                                        pointRadius: 4,
                                        pointHoverRadius: 6
                                    },
                                    {
                                        label: 'Document Trend',
                                        data: ` + JSON.stringify(docTrendData) + `,
                                        borderColor: 'rgba(59, 130, 246, 0.5)',
                                        borderDash: [5, 5],
                                        borderWidth: 2,
                                        fill: false,
                                        pointRadius: 0,
                                        pointHoverRadius: 0,
                                        yAxisID: 'y'
                                    },
                                    {
                                        label: 'KC Count',
                                        data: ` + JSON.stringify(kcCountData) + `,
                                        borderColor: 'rgba(16, 185, 129, 1)',
                                        backgroundColor: 'rgba(16, 185, 129, 0.1)',
                                        tension: 0.2,
                                        yAxisID: 'y1',
                                        pointRadius: 4,
                                        pointHoverRadius: 6
                                    },
                                    {
                                        label: 'KC Trend',
                                        data: ` + JSON.stringify(kcTrendData) + `,
                                        borderColor: 'rgba(16, 185, 129, 0.5)',
                                        borderDash: [5, 5],
                                        borderWidth: 2,
                                        fill: false,
                                        pointRadius: 0,
                                        pointHoverRadius: 0,
                                        yAxisID: 'y1'
                                    }
                                ]
                            },
                            options: {
                                responsive: true,
                                maintainAspectRatio: false,
                                interaction: {
                                    mode: 'index',
                                    intersect: false
                                },
                                plugins: {
                                    legend: {
                                        position: 'bottom'
                                    },
                                    tooltip: {
                                        callbacks: {
                                            label: function(context) {
                                                let label = context.dataset.label || '';
                                                if (label) label += ': ';
                                                label += context.parsed.y.toLocaleString();
                                                return label;
                                            }
                                        }
                                    }
                                },
                                scales: {
                                    y: {
                                        type: 'linear',
                                        display: true,
                                        position: 'left',
                                        beginAtZero: true,
                                        title: {
                                            display: true,
                                            text: 'Document Count'
                                        }
                                    },
                                    y1: {
                                        type: 'linear',
                                        display: true,
                                        position: 'right',
                                        beginAtZero: true,
                                        title: {
                                            display: true,
                                            text: 'KC Count'
                                        },
                                        grid: {
                                            drawOnChartArea: false
                                        }
                                    }
                                }
                            }
                        });
                    }
                } catch (error) {
                    console.error('Error creating docKCTrendsChart:', error);
                }
            }, 100);
        </scr` + `ipt>`;
        
        html += chartScript;
        return html;
    }

    generateTPDocVolumeAnalysis(docAnalysis) {
        let html = `<div class="tp-doc-volume-wrapper" style="margin-top: 30px;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                <h4 style="color: #2d3748; margin: 0; font-size: 1.1em;">🏢 Top Trading Partners by Document Volume
                    <span class="info-icon">i
                        <div class="tooltip">
                            This section highlights your top 15 trading partners by document volume.
                            It shows their total document counts, KC counts, and percentage of overall traffic.
                            The table helps identify your most important trading relationships.
                            Focus on these key partners for business development and optimization.
                        </div>
                    </span>
                </h4>
                ${window.parent && window.parent.idCrossReference ? `
                <div style="background: #f3f4f6; padding: 4px; border-radius: 8px; display: flex; gap: 4px;">
                    <span style="padding: 6px 8px; color: #4b5563; font-size: 0.85em;">Display:</span>
                    <button onclick="setTPDisplayMode('id', 'doc-tp-volume-table')" 
                        class="display-mode-btn display-mode-id" 
                        data-mode="id"
                        style="
                            padding: 6px 12px;
                            border: none;
                            background: #3b82f6;
                            color: white;
                            border-radius: 6px;
                            cursor: pointer;
                            font-size: 0.85em;
                            transition: all 0.2s;
                        ">ID</button>
                    <button onclick="setTPDisplayMode('name', 'doc-tp-volume-table')" 
                        class="display-mode-btn display-mode-name" 
                        data-mode="name"
                        style="
                            padding: 6px 12px;
                            border: none;
                            background: transparent;
                            color: #6b7280;
                            border-radius: 6px;
                            cursor: pointer;
                            font-size: 0.85em;
                            transition: all 0.2s;
                        ">Name</button>
                    <button onclick="setTPDisplayMode('region', 'doc-tp-volume-table')" 
                        class="display-mode-btn display-mode-region" 
                        data-mode="region"
                        style="
                            padding: 6px 12px;
                            border: none;
                            background: transparent;
                            color: #6b7280;
                            border-radius: 6px;
                            cursor: pointer;
                            font-size: 0.85em;
                            transition: all 0.2s;
                        ">Region</button>
                </div>
                ` : ''}
            </div>`;
        
        // Calculate KC totals by TP
        const tpKcTotals = {};
        Object.values(docAnalysis.type_trends).forEach(trend => {
            trend.periods.forEach((period, index) => {
                // Need to get TP data from the raw docData
                const periodData = this.docData && this.docData[period];
                if (periodData && periodData.documents_by_tp) {
                    Object.entries(periodData.documents_by_tp).forEach(([tp, data]) => {
                        tpKcTotals[tp] = (tpKcTotals[tp] || 0) + (data.total_kcs || 0);
                    });
                }
            });
        });
        
        // Sort TPs by document count
        const sortedTPs = Object.entries(docAnalysis.tp_document_counts)
            .sort(([, a], [, b]) => b - a)
            .slice(0, 15);
        
        if (sortedTPs.length === 0) {
            html += `<p style="text-align: center; color: #718096;">No trading partner data available.</p>`;
        } else {
            html += `
            <div style="max-height: 400px; overflow-y: auto; border: 1px solid #e2e8f0; border-radius: 8px;">
                <table class="data-table" id="doc-tp-volume-table" style="width: 100%;">
                    <thead style="position: sticky; top: 0; background: #f7fafc; z-index: 10;">
                        <tr>
                            <th style="text-align: center; padding: 12px; width: 60px;">Rank</th>
                            <th style="text-align: left; padding: 12px;">Trading Partner</th>
                            <th style="text-align: right; padding: 12px;">Document Count</th>
                            <th style="text-align: right; padding: 12px;">KC Count</th>
                            <th style="text-align: center; padding: 12px;">% of Total Docs</th>
                        </tr>
                    </thead>
                    <tbody>`;
            
            sortedTPs.forEach(([tp, count], index) => {
                const percentage = (count / docAnalysis.total_documents * 100).toFixed(1);
                const kcCount = tpKcTotals[tp] || 0;
                
                // Highlight top 3
                const rowStyle = index < 3 ? ' style="background-color: #f7fafc;"' : '';
                
                html += `
                        <tr${rowStyle}>
                            <td style="text-align: center; padding: 10px;">
                                ${index < 3 ? `<strong>${index + 1}</strong>` : index + 1}
                            </td>
                            <td class="tp-id-cell" data-id="${tp}" style="padding: 10px;"><strong>${tp}</strong></td>
                            <td style="text-align: right; padding: 10px;">${count.toLocaleString()}</td>
                            <td style="text-align: right; padding: 10px;">${Math.round(kcCount).toLocaleString()}</td>
                            <td style="text-align: center; padding: 10px;">
                                <span style="font-weight: 600;">${percentage}%</span>
                            </td>
                        </tr>`;
            });
            
            html += `
                    </tbody>
                </table>
            </div>`;
            
            // Summary
            const topTpsCount = sortedTPs.reduce((sum, [, count]) => sum + count, 0);
            const topTpsPercentage = (topTpsCount / docAnalysis.total_documents * 100).toFixed(1);
            
            html += `
            <div class="info-box" style="margin-top: 15px;">
                <strong>Concentration:</strong> Top ${sortedTPs.length} trading partners account for 
                ${topTpsPercentage}% of all documents
            </div>`;
        }
        
        html += `</div>`;
        return html;
    }


    generateEfficiencyMetrics(docAnalysis) {
        let html = `
        <div class="efficiency-dashboard" style="margin-bottom: 30px;">
            <h4 style="color: #2d3748; margin-bottom: 20px; font-size: 1.1em;">📊 Efficiency Metrics Dashboard</h4>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">`;
        
        // Calculate efficiency metrics
        const kcTotals = {};
        Object.values(docAnalysis.type_trends).forEach(trend => {
            trend.periods.forEach((period, index) => {
                kcTotals[period] = (kcTotals[period] || 0) + (trend.kcs[index] || 0);
            });
        });
        
        // Overall efficiency
        const totalDocs = docAnalysis.total_documents;
        const totalKCs = Object.values(kcTotals).reduce((sum, kc) => sum + kc, 0);
        const overallEfficiency = totalKCs > 0 ? (totalDocs / totalKCs).toFixed(2) : 0;
        
        // Period-by-period efficiency
        const efficiencyByPeriod = {};
        docAnalysis.periods.forEach(period => {
            const docs = docAnalysis.monthly_totals[period];
            const kcs = kcTotals[period];
            efficiencyByPeriod[period] = kcs > 0 ? (docs / kcs).toFixed(2) : 0;
        });
        
        // Best and worst efficiency
        const efficiencyValues = Object.values(efficiencyByPeriod).map(e => parseFloat(e)).filter(e => e > 0);
        const bestEfficiency = Math.max(...efficiencyValues);
        const worstEfficiency = Math.min(...efficiencyValues);
        
        // Trend calculation
        const recentEfficiencies = Object.entries(efficiencyByPeriod).slice(-3);
        let efficiencyTrend = 'stable';
        if (recentEfficiencies.length >= 2) {
            const recent = parseFloat(recentEfficiencies[recentEfficiencies.length - 1][1]);
            const previous = parseFloat(recentEfficiencies[recentEfficiencies.length - 2][1]);
            if (recent > previous * 1.05) efficiencyTrend = 'improving';
            else if (recent < previous * 0.95) efficiencyTrend = 'declining';
        }
        
        html += `
                <div style="background: linear-gradient(135deg, rgba(241, 245, 249, 0.5) 0%, rgba(226, 232, 240, 0.5) 100%); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); border: 1px solid rgba(203, 213, 225, 0.4); padding: 20px; border-radius: 8px; text-align: center; box-shadow: 0 4px 16px rgba(0, 0, 0, 0.05);">
                    <div style="font-size: 2em; font-weight: bold; color: #1e293b;">${overallEfficiency}</div>
                    <div style="color: #64748b; margin-top: 5px;">Overall Docs/KC Ratio</div>
                </div>
                <div style="background: linear-gradient(135deg, rgba(167, 243, 208, 0.3) 0%, rgba(110, 231, 183, 0.3) 100%); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); border: 1px solid rgba(167, 243, 208, 0.4); padding: 20px; border-radius: 8px; text-align: center; box-shadow: 0 4px 16px rgba(16, 185, 129, 0.08);">
                    <div style="font-size: 2em; font-weight: bold; color: #064e3b;">${bestEfficiency}</div>
                    <div style="color: #047857; margin-top: 5px;">Best Efficiency</div>
                </div>
                <div style="background: linear-gradient(135deg, rgba(254, 226, 226, 0.3) 0%, rgba(254, 202, 202, 0.3) 100%); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); border: 1px solid rgba(254, 226, 226, 0.4); padding: 20px; border-radius: 8px; text-align: center; box-shadow: 0 4px 16px rgba(239, 68, 68, 0.08);">
                    <div style="font-size: 2em; font-weight: bold; color: #7f1d1d;">${worstEfficiency}</div>
                    <div style="color: #b91c1c; margin-top: 5px;">Worst Efficiency</div>
                </div>
                <div style="background: ${efficiencyTrend === 'improving' ? 'linear-gradient(135deg, rgba(209, 250, 229, 0.3) 0%, rgba(167, 243, 208, 0.3) 100%)' : efficiencyTrend === 'declining' ? 'linear-gradient(135deg, rgba(254, 226, 226, 0.3) 0%, rgba(254, 202, 202, 0.3) 100%)' : 'linear-gradient(135deg, rgba(243, 244, 246, 0.3) 0%, rgba(229, 231, 235, 0.3) 100%)'}; 
                            backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); 
                            border: 1px solid ${efficiencyTrend === 'improving' ? 'rgba(167, 243, 208, 0.4)' : efficiencyTrend === 'declining' ? 'rgba(254, 226, 226, 0.4)' : 'rgba(229, 231, 235, 0.4)'};
                            padding: 20px; border-radius: 8px; text-align: center; box-shadow: 0 4px 16px rgba(0, 0, 0, 0.05);">
                    <div style="font-size: 1.5em; font-weight: bold; color: ${efficiencyTrend === 'improving' ? '#065f46' : efficiencyTrend === 'declining' ? '#991b1b' : '#374151'};">
                        ${efficiencyTrend === 'improving' ? '↑' : efficiencyTrend === 'declining' ? '↓' : '→'} 
                        ${efficiencyTrend.charAt(0).toUpperCase() + efficiencyTrend.slice(1)}
                    </div>
                    <div style="color: #6b7280; margin-top: 5px;">Efficiency Trend</div>
                </div>
            </div>
        </div>`;
        
        return html;
    }


    generatePredictiveAnalytics(docAnalysis) {
        let html = `
        <div class="predictive-analytics" style="margin-bottom: 30px;">
            <h4 style="color: #2d3748; margin-bottom: 20px; font-size: 1.1em;">🔮 Predictive Analytics & Seasonality</h4>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                <!-- Forecast Chart -->
                <div style="background: white; padding: 20px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.05);">
                    <h5 style="margin-bottom: 15px;">3-Period Forecast</h5>
                    <div style="position: relative; height: 300px;">
                        <canvas id="forecastChart"></canvas>
                    </div>
                </div>
                
                <!-- Seasonality Analysis -->
                <div style="background: white; padding: 20px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.05);">
                    <h5 style="margin-bottom: 15px;">Seasonality Pattern</h5>
                    <div id="docSeasonalityFilterContainer" style="margin-bottom: 15px;">
                        <!-- Year filter will be added here if multiple years exist -->
                    </div>
                    <div id="seasonalityAnalysis" style="min-height: 300px; overflow: hidden;">
                        <!-- Will be populated by script -->
                    </div>
                </div>
            </div>
        </div>`;
        
        // Calculate simple linear regression for forecast
        const periods = docAnalysis.periods;
        const values = periods.map(p => docAnalysis.monthly_totals[p]);
        
        // Linear regression
        const n = values.length;
        let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;
        for (let i = 0; i < n; i++) {
            sumX += i;
            sumY += values[i];
            sumXY += i * values[i];
            sumX2 += i * i;
        }
        const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
        const intercept = (sumY - slope * sumX) / n;
        
        // Generate forecast
        const forecastPeriods = [];
        const forecastValues = [];
        for (let i = 0; i < 3; i++) {
            const nextIndex = n + i;
            forecastValues.push(Math.round(slope * nextIndex + intercept));
            
            // Generate next period name
            const lastPeriod = periods[periods.length - 1];
            const [year, month] = lastPeriod.split('-').map(Number);
            const nextMonth = ((parseInt(month) + i) % 12) + 1;
            const nextYear = year + Math.floor((parseInt(month) + i) / 12);
            forecastPeriods.push(`${nextYear}-${String(nextMonth).padStart(2, '0')}`);
        }
        
        // Seasonality analysis with year support
        const monthlyAverages = {};
        const monthCounts = {};
        const yearlyData = {};
        const availableYears = new Set();
        
        periods.forEach(period => {
            const [year, month] = period.split('-');
            availableYears.add(year);
            
            // Overall aggregation
            if (!monthlyAverages[month]) {
                monthlyAverages[month] = 0;
                monthCounts[month] = 0;
            }
            monthlyAverages[month] += docAnalysis.monthly_totals[period];
            monthCounts[month]++;
            
            // Year-specific aggregation
            if (!yearlyData[year]) {
                yearlyData[year] = {
                    monthlyVolumes: {},
                    monthCounts: {}
                };
            }
            if (!yearlyData[year].monthlyVolumes[month]) {
                yearlyData[year].monthlyVolumes[month] = 0;
                yearlyData[year].monthCounts[month] = 0;
            }
            yearlyData[year].monthlyVolumes[month] += docAnalysis.monthly_totals[period];
            yearlyData[year].monthCounts[month]++;
        });
        
        // Calculate averages for all years combined
        Object.keys(monthlyAverages).forEach(month => {
            if (monthCounts[month] > 0) {
                monthlyAverages[month] = monthlyAverages[month] / monthCounts[month];
            }
        });
        
        const overallAverage = values.length > 0 ? values.reduce((a, b) => a + b, 0) / values.length : 0;
        const seasonalityFactors = {};
        Object.keys(monthlyAverages).forEach(month => {
            seasonalityFactors[month] = ((monthlyAverages[month] - overallAverage) / overallAverage * 100).toFixed(1);
        });
        
        // Calculate year-specific seasonality factors
        const yearlySeasonalityFactors = {};
        Object.keys(yearlyData).forEach(year => {
            const yearMonthlyAverages = {};
            Object.keys(yearlyData[year].monthlyVolumes).forEach(month => {
                if (yearlyData[year].monthCounts[month] > 0) {
                    yearMonthlyAverages[month] = yearlyData[year].monthlyVolumes[month] / yearlyData[year].monthCounts[month];
                }
            });
            
            const yearValues = Object.values(yearMonthlyAverages);
            const yearOverallAverage = yearValues.length > 0 ? yearValues.reduce((a, b) => a + b, 0) / yearValues.length : 0;
            
            yearlySeasonalityFactors[year] = {
                factors: {},
                average: yearOverallAverage
            };
            
            Object.keys(yearMonthlyAverages).forEach(month => {
                yearlySeasonalityFactors[year].factors[month] = ((yearMonthlyAverages[month] - yearOverallAverage) / yearOverallAverage * 100).toFixed(1);
            });
        });
        
        const yearArray = Array.from(availableYears).sort();
        const showYearFilter = yearArray.length > 1;
        
        html += `<script>
        setTimeout(() => {
            // Forecast Chart
            const forecastCtx = document.getElementById('forecastChart');
            if (forecastCtx) {
                const periodLabels = ` + JSON.stringify(periods.map(p => this.formatPeriodDisplay(p))) + `;
                const forecastLabels = ` + JSON.stringify(forecastPeriods.map(p => this.formatPeriodDisplay(p))) + `;
                const historicalData = ` + JSON.stringify(values) + `;
                const forecastData = ` + JSON.stringify(forecastValues) + `;
                const trendLineData = ` + JSON.stringify([...Array(n + 3).keys()].map(i => slope * i + intercept)) + `;
                
                new Chart(forecastCtx.getContext('2d'), {
                    type: 'line',
                    data: {
                        labels: [...periodLabels, ...forecastLabels],
                        datasets: [{
                            label: 'Historical',
                            data: [...historicalData, ...Array(3).fill(null)],
                            borderColor: 'rgba(59, 130, 246, 1)',
                            backgroundColor: 'rgba(59, 130, 246, 0.1)',
                            tension: 0.2
                        }, {
                            label: 'Forecast',
                            data: [...Array(historicalData.length).fill(null), historicalData[historicalData.length - 1], ...forecastData],
                            borderColor: 'rgba(239, 68, 68, 1)',
                            backgroundColor: 'rgba(239, 68, 68, 0.1)',
                            borderDash: [5, 5],
                            tension: 0.2
                        }, {
                            label: 'Trend Line',
                            data: trendLineData,
                            borderColor: 'rgba(107, 114, 128, 0.5)',
                            borderDash: [2, 2],
                            borderWidth: 1,
                            pointRadius: 0,
                            fill: false
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { position: 'bottom' },
                            annotation: {
                                annotations: {
                                    line1: {
                                        type: 'line',
                                        xMin: ` + (values.length - 0.5) + `,
                                        xMax: ` + (values.length - 0.5) + `,
                                        borderColor: 'rgba(0, 0, 0, 0.3)',
                                        borderWidth: 2,
                                        borderDash: [6, 6],
                                        label: {
                                            content: 'Forecast Start',
                                            enabled: true,
                                            position: 'top'
                                        }
                                    }
                                }
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: 'Document Count'
                                }
                            }
                        }
                    }
                });
            }
            
            // Add year filter if multiple years
            const filterContainer = document.getElementById('docSeasonalityFilterContainer');
            const showYearFilter = ${showYearFilter};
            const yearArray = ${JSON.stringify(yearArray).replace(/</g, '\\u003c')};
            
            if (filterContainer && showYearFilter) {
                filterContainer.innerHTML = \`
                    <label style="font-weight: 500; color: #374151; margin-right: 10px;">Year Filter:</label>
                    <select id="docSeasonalityYearFilter" onchange="updateDocSeasonalityDisplay()" style="
                        padding: 8px 12px;
                        border: 1px solid #d1d5db;
                        border-radius: 6px;
                        background: white;
                        color: #374151;
                        font-size: 0.9em;
                        cursor: pointer;">
                        <option value="all">All Years Combined</option>
                        \${yearArray.map(year => '<option value="' + year + '">' + year + '</option>').join('')}
                    </select>\`;
            }
            
            // Store data globally for filter updates
            window.docSeasonalityData = {
                all: {
                    factors: ${JSON.stringify(seasonalityFactors).replace(/</g, '\\u003c')},
                    average: ${overallAverage}
                },
                yearly: ${JSON.stringify(yearlySeasonalityFactors).replace(/</g, '\\u003c')}
            };
            
            // Function to update seasonality display
            window.updateDocSeasonalityDisplay = function() {
                const seasonalityDiv = document.getElementById('seasonalityAnalysis');
                const yearFilter = document.getElementById('docSeasonalityYearFilter');
                const selectedYear = yearFilter ? yearFilter.value : 'all';
                
                if (seasonalityDiv && window.docSeasonalityData) {
                    const months = ['01', '02', '03', '04', '05', '06', '07', '08', '09', '10', '11', '12'];
                    const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                    
                    // Get data for selected year
                    let currentFactors, currentAverage;
                    if (selectedYear === 'all') {
                        currentFactors = window.docSeasonalityData.all.factors;
                        currentAverage = window.docSeasonalityData.all.average;
                    } else {
                        currentFactors = window.docSeasonalityData.yearly[selectedYear].factors;
                        currentAverage = window.docSeasonalityData.yearly[selectedYear].average;
                    }
                    
                    // Create a more visual heatmap-style display
                    let seasonalHTML = '<div style="padding: 10px;">';
                
                // Title and legend
                seasonalHTML += '<div style="margin-bottom: 10px;">';
                seasonalHTML += '<div style="display: flex; flex-direction: column; gap: 8px;">';
                    seasonalHTML += '<span style="font-weight: 600; color: #374151; font-size: 0.95em;">Monthly Variation from Average' + 
                        (selectedYear !== 'all' ? ' (' + selectedYear + ')' : '') + '</span>';
                seasonalHTML += '<div style="display: flex; flex-wrap: wrap; align-items: center; gap: 12px; font-size: 0.75em;">';
                seasonalHTML += '<span style="display: flex; align-items: center; gap: 4px;"><span style="width: 16px; height: 10px; background: #10b981; border-radius: 2px;"></span>Above Avg</span>';
                seasonalHTML += '<span style="display: flex; align-items: center; gap: 4px;"><span style="width: 16px; height: 10px; background: #6b7280; border-radius: 2px;"></span>Average</span>';
                seasonalHTML += '<span style="display: flex; align-items: center; gap: 4px;"><span style="width: 16px; height: 10px; background: #ef4444; border-radius: 2px;"></span>Below Avg</span>';
                seasonalHTML += '</div></div></div>';
                
                // Create circular month display with responsive sizing
                seasonalHTML += '<div style="position: relative; width: 240px; height: 240px; margin: 0 auto;">';
                
                // Draw center circle with average
                seasonalHTML += '<div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; background: #f9fafb; border-radius: 50%; width: 80px; height: 80px; display: flex; flex-direction: column; justify-content: center; align-items: center; box-shadow: 0 0 0 2px #e5e7eb;">';
                seasonalHTML += '<div style="font-size: 0.7em; color: #6b7280;">Average</div>';
                seasonalHTML += '<div style="font-size: 1em; font-weight: bold; color: #374151;">' + Math.round(currentAverage) + '</div>';
                seasonalHTML += '<div style="font-size: 0.65em; color: #6b7280;">docs/mo</div>';
                seasonalHTML += '</div>';
                
                // Draw months in a circle
                months.forEach((month, index) => {
                    const factor = parseFloat(currentFactors[month] || 0);
                    const angle = (index * 30 - 90) * Math.PI / 180; // Start from top
                    const radius = 95; // Reduced from 120
                    const x = 120 + radius * Math.cos(angle); // Center at 120 (half of 240)
                    const y = 120 + radius * Math.sin(angle); // Center at 120 (half of 240)
                    
                    // Determine color and intensity
                    let bgColor, textColor;
                    const absFactor = Math.abs(factor);
                    if (factor > 0) {
                        if (absFactor > 20) {
                            bgColor = '#065f46';
                            textColor = '#ffffff';
                        } else if (absFactor > 10) {
                            bgColor = '#10b981';
                            textColor = '#ffffff';
                        } else {
                            bgColor = '#86efac';
                            textColor = '#065f46';
                        }
                    } else if (factor < 0) {
                        if (absFactor > 20) {
                            bgColor = '#991b1b';
                            textColor = '#ffffff';
                        } else if (absFactor > 10) {
                            bgColor = '#ef4444';
                            textColor = '#ffffff';
                        } else {
                            bgColor = '#fca5a5';
                            textColor = '#991b1b';
                        }
                    } else {
                        bgColor = '#e5e7eb';
                        textColor = '#374151';
                    }
                    
                    seasonalHTML += '<div style="position: absolute; left: ' + x + 'px; top: ' + y + 'px; transform: translate(-50%, -50%);">' +
                        '<div style="width: 42px; height: 42px; border-radius: 50%; background: ' + bgColor + '; ' +
                        'display: flex; flex-direction: column; justify-content: center; align-items: center;' +
                        'box-shadow: 0 2px 4px rgba(0,0,0,0.1); cursor: pointer; transition: all 0.2s;"' +
                        ' onmouseover="this.style.transform=&apos;scale(1.15)&apos;; this.style.zIndex=&apos;10&apos;;"' +
                        ' onmouseout="this.style.transform=&apos;scale(1)&apos;; this.style.zIndex=&apos;1&apos;;">' +
                        '<div style="font-size: 0.7em; font-weight: 600; color: ' + textColor + ';">' + monthNames[index] + '</div>' +
                        '<div style="font-size: 0.6em; color: ' + textColor + ';">' + (factor > 0 ? '+' : '') + factor + '%</div>' +
                        '</div>' +
                        '</div>';
                });
                
                seasonalHTML += '</div>';
                
                // Analysis summary
                seasonalHTML += '<div style="margin-top: 15px; padding: 12px; background: #f9fafb; border-radius: 8px;">';
                seasonalHTML += '<h6 style="margin: 0 0 8px 0; color: #374151; font-size: 0.85em;">Seasonality Analysis</h6>';
                
                const seasonalityData = Object.entries(currentFactors)
                    .map(([m, f]) => ({ month: monthNames[parseInt(m) - 1], factor: parseFloat(f) }))
                    .sort((a, b) => b.factor - a.factor);
                
                const strongPatterns = seasonalityData.filter(d => Math.abs(d.factor) > 15);
                const moderatePatterns = seasonalityData.filter(d => Math.abs(d.factor) > 5 && Math.abs(d.factor) <= 15);
                
                if (strongPatterns.length > 0) {
                    seasonalHTML += '<div style="margin-bottom: 6px; font-size: 0.8em;">';
                    seasonalHTML += '<span style="color: #374151; font-weight: 600;">Strong Patterns:</span> ';
                    strongPatterns.forEach((p, i) => {
                        const isHigh = p.factor > 0;
                        seasonalHTML += '<span style="color: ' + (isHigh ? '#065f46' : '#991b1b') + '; font-weight: 500;">' + p.month + ' (' + (isHigh ? '+' : '') + p.factor.toFixed(1) + '%)</span>';
                        if (i < strongPatterns.length - 1) seasonalHTML += ', ';
                    });
                    seasonalHTML += '</div>';
                }
                
                if (moderatePatterns.length > 0) {
                    seasonalHTML += '<div style="margin-bottom: 6px; font-size: 0.8em;">';
                    seasonalHTML += '<span style="color: #374151; font-weight: 600;">Moderate Patterns:</span> ';
                    moderatePatterns.forEach((p, i) => {
                        const isHigh = p.factor > 0;
                        seasonalHTML += '<span style="color: ' + (isHigh ? '#10b981' : '#ef4444') + ';">' + p.month + ' (' + (isHigh ? '+' : '') + p.factor.toFixed(1) + '%)</span>';
                        if (i < moderatePatterns.length - 1) seasonalHTML += ', ';
                    });
                    seasonalHTML += '</div>';
                }
                
                // Overall seasonality score
                const seasonalityScore = Math.sqrt(seasonalityData.reduce((sum, d) => sum + d.factor * d.factor, 0) / seasonalityData.length);
                seasonalHTML += '<div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #e5e7eb; font-size: 0.8em;">';
                seasonalHTML += '<span style="color: #6b7280;">Seasonality Strength: </span>' +
                                 '<span style="font-weight: 600; color: ' + (seasonalityScore < 10 ? '#10b981' : seasonalityScore < 20 ? '#f59e0b' : '#ef4444') + ';">' +
                                    (seasonalityScore < 10 ? 'Low' : seasonalityScore < 20 ? 'Moderate' : 'High') + 
                                    ' (' + seasonalityScore.toFixed(1) + '% variation)' +
                                 '</span>';
                seasonalHTML += '</div>';
                
                    seasonalHTML += '</div></div>';
                    seasonalityDiv.innerHTML = seasonalHTML;
                }
            };
            
            // Initialize the display
            updateDocSeasonalityDisplay();
        }, 100);` +
        '</scr' + 'ipt>';
        
        return html;
    }

    generatePerformanceIndicators(docAnalysis) {
        let html = `
        <div class="performance-indicators" style="margin-bottom: 30px;">
            <h4 style="color: #2d3748; margin-bottom: 20px; font-size: 1.1em;">🎯 Performance Indicators</h4>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px;">`;
        
        // Calculate CAGR
        const periods = docAnalysis.periods;
        const years = periods.length / 12;
        const firstTotal = docAnalysis.monthly_totals[periods[0]];
        const lastTotal = docAnalysis.monthly_totals[periods[periods.length - 1]];
        const cagr = years > 0 ? (Math.pow(lastTotal / firstTotal, 1 / years) - 1) * 100 : 0;
        
        // Calculate volatility
        const monthlyGrowths = [];
        for (let i = 1; i < periods.length; i++) {
            const prev = docAnalysis.monthly_totals[periods[i - 1]];
            const curr = docAnalysis.monthly_totals[periods[i]];
            if (prev > 0) {
                monthlyGrowths.push((curr - prev) / prev * 100);
            }
        }
        const avgGrowth = monthlyGrowths.reduce((a, b) => a + b, 0) / monthlyGrowths.length;
        const volatility = Math.sqrt(
            monthlyGrowths.reduce((sum, growth) => sum + Math.pow(growth - avgGrowth, 2), 0) / monthlyGrowths.length
        );
        
        // Concentration risk
        const topTP = Object.entries(docAnalysis.tp_document_counts).sort(([,a], [,b]) => b - a)[0];
        const concentrationRisk = topTP ? (topTP[1] / docAnalysis.total_documents * 100) : 0;
        
        html += `
                <div style="background: linear-gradient(135deg, rgba(219, 234, 254, 0.3) 0%, rgba(191, 219, 254, 0.3) 100%); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); border: 1px solid rgba(147, 197, 253, 0.4); padding: 20px; border-radius: 8px; border-left: 4px solid rgba(59, 130, 246, 0.6); box-shadow: 0 4px 16px rgba(59, 130, 246, 0.08);">
                    <h5 style="margin: 0 0 10px 0; color: #1e40af;">Compound Annual Growth Rate (CAGR)</h5>
                    <div style="font-size: 2em; font-weight: bold; color: #1e3a8a;">${cagr.toFixed(1)}%</div>
                    <p style="margin: 10px 0 0 0; color: #64748b; font-size: 0.9em;">
                        Average yearly growth rate over ${years.toFixed(1)} years
                    </p>
                </div>
                
                <div style="background: linear-gradient(135deg, rgba(254, 243, 199, 0.3) 0%, rgba(253, 230, 138, 0.3) 100%); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); border: 1px solid rgba(252, 211, 77, 0.4); padding: 20px; border-radius: 8px; border-left: 4px solid rgba(245, 158, 11, 0.6); box-shadow: 0 4px 16px rgba(245, 158, 11, 0.08);">
                    <h5 style="margin: 0 0 10px 0; color: #92400e;">Volatility Index</h5>
                    <div style="font-size: 2em; font-weight: bold; color: #78350f;">${volatility.toFixed(1)}%</div>
                    <p style="margin: 10px 0 0 0; color: #64748b; font-size: 0.9em;">
                        ${volatility < 10 ? 'Low volatility - stable growth' : 
                          volatility < 20 ? 'Moderate volatility - some fluctuation' : 
                          'High volatility - significant fluctuation'}
                    </p>
                </div>
                
                <div style="background: ${concentrationRisk > 30 ? 'linear-gradient(135deg, rgba(254, 226, 226, 0.3) 0%, rgba(254, 202, 202, 0.3) 100%)' : 'linear-gradient(135deg, rgba(209, 250, 229, 0.3) 0%, rgba(167, 243, 208, 0.3) 100%)'}; 
                            backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);
                            border: 1px solid ${concentrationRisk > 30 ? 'rgba(252, 165, 165, 0.4)' : 'rgba(134, 239, 172, 0.4)'};
                            padding: 20px; border-radius: 8px; 
                            border-left: 4px solid ${concentrationRisk > 30 ? 'rgba(239, 68, 68, 0.6)' : 'rgba(16, 185, 129, 0.6)'};
                            box-shadow: 0 4px 16px ${concentrationRisk > 30 ? 'rgba(239, 68, 68, 0.08)' : 'rgba(16, 185, 129, 0.08)'};">
                    <h5 style="margin: 0 0 10px 0; color: ${concentrationRisk > 30 ? '#991b1b' : '#065f46'};">
                        Concentration Risk
                    </h5>
                    <div style="font-size: 2em; font-weight: bold; color: ${concentrationRisk > 30 ? '#7f1d1d' : '#064e3b'};">
                        ${concentrationRisk.toFixed(1)}%
                    </div>
                    <p style="margin: 10px 0 0 0; color: #64748b; font-size: 0.9em;">
                        Top partner: ${topTP ? topTP[0] : 'N/A'} handles ${concentrationRisk.toFixed(1)}% of volume
                    </p>
                </div>
            </div>
        </div>`;
        
        return html;
    }

    generateTPDocMatrixTables(docData, docAnalysis) {
        try {
            const htmlParts = [];
            htmlParts.push(`<div class="tp-doc-matrix-wrapper">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                    <h4 style="color: #2d3748; margin: 0;">📊 TP-Document Type Matrix
                        <span class="info-icon">i
                            <div class="tooltip">
                                The TP-Document Type Matrix provides a comprehensive view of all trading partner and document type combinations.
                                Each cell shows the total document count for that specific combination.
                                The matrix includes search and filter capabilities to find specific patterns.
                                Use this to analyze business relationships and document flow patterns.
                            </div>
                        </span>
                    </h4>
                    <div style="display: flex; gap: 10px;">
                        <button onclick="exportTableData('tp-doc-matrix', 'json')" style="
                            background: #3182ce;
                            color: white;
                            border: none;
                            padding: 8px 16px;
                            border-radius: 5px;
                            cursor: pointer;
                            font-size: 14px;
                            transition: background 0.2s;
                        " onmouseover="this.style.background='#2563eb'" onmouseout="this.style.background='#3182ce'">
                            📥 Export JSON
                        </button>
                        <button onclick="exportTableData('tp-doc-matrix', 'csv')" style="
                            background: #16a34a;
                            color: white;
                            border: none;
                            padding: 8px 16px;
                            border-radius: 5px;
                            cursor: pointer;
                            font-size: 14px;
                            transition: background 0.2s;
                        " onmouseover="this.style.background='#15803d'" onmouseout="this.style.background='#16a34a'">
                            📥 Export CSV
                        </button>
                        ${window.parent && window.parent.idCrossReference ? `
                        <div style="background: #f3f4f6; padding: 4px; border-radius: 8px; display: flex; gap: 4px; margin-left: 20px;">
                            <span style="padding: 6px 8px; color: #4b5563; font-size: 0.85em;">Display:</span>
                            <button onclick="setTPDisplayMode('id', 'tp-doc-matrix-table')" 
                                class="display-mode-btn display-mode-id" 
                                data-mode="id"
                                style="
                                    padding: 6px 12px;
                                    border: none;
                                    background: #3b82f6;
                                    color: white;
                                    border-radius: 6px;
                                    cursor: pointer;
                                    font-size: 0.85em;
                                    transition: all 0.2s;
                                ">ID</button>
                            <button onclick="setTPDisplayMode('name', 'tp-doc-matrix-table')" 
                                class="display-mode-btn display-mode-name" 
                                data-mode="name"
                                style="
                                    padding: 6px 12px;
                                    border: none;
                                    background: transparent;
                                    color: #6b7280;
                                    border-radius: 6px;
                                    cursor: pointer;
                                    font-size: 0.85em;
                                    transition: all 0.2s;
                                ">Name</button>
                            <button onclick="setTPDisplayMode('region', 'tp-doc-matrix-table')" 
                                class="display-mode-btn display-mode-region" 
                                data-mode="region"
                                style="
                                    padding: 6px 12px;
                                    border: none;
                                    background: transparent;
                                    color: #6b7280;
                                    border-radius: 6px;
                                    cursor: pointer;
                                    font-size: 0.85em;
                                    transition: all 0.2s;
                                ">Region</button>
                        </div>
                        ` : ''}
                    </div>
                </div>`);
        
        // Get all periods
        const periods = docAnalysis.periods;
        if (periods.length === 0) {
            htmlParts.push(`<p style="text-align: center; color: #718096;">No matrix data available.</p></div>`);
            return htmlParts.join('');
        }
        
        // Aggregate data from all periods
        const allPeriodsMatrix = {};
        const tpTotals = {};
        const docTypeTotals = {};
        
        // Combine data from all periods
        for (const period of periods) {
            const periodData = docData[period];
            if (periodData && periodData.tp_type_matrix) {
                for (const [tp, types] of Object.entries(periodData.tp_type_matrix)) {
                    if (!allPeriodsMatrix[tp]) {
                        allPeriodsMatrix[tp] = {};
                    }
                    
                    for (const [docType, counts] of Object.entries(types)) {
                        if (!allPeriodsMatrix[tp][docType]) {
                            allPeriodsMatrix[tp][docType] = { total: 0 };
                        }
                        
                        // Sum the counts across all periods
                        allPeriodsMatrix[tp][docType].total += counts.total || 0;
                        
                        // Update totals
                        if (!tpTotals[tp]) tpTotals[tp] = 0;
                        if (!docTypeTotals[docType]) docTypeTotals[docType] = 0;
                        
                        tpTotals[tp] += counts.total || 0;
                        docTypeTotals[docType] += counts.total || 0;
                    }
                }
            }
        }
        
        if (Object.keys(allPeriodsMatrix).length === 0) {
            htmlParts.push(`<p style="text-align: center; color: #718096;">No matrix data available.</p></div>`);
            return htmlParts.join('');
        }
        
        // Sort and filter items - limit to top contributors to reduce matrix size
        let allTPs = Object.entries(tpTotals)
            .filter(([, total]) => total > 0) // Remove TPs with no documents
            .sort(([, a], [, b]) => b - a)
            .map(([tp]) => tp);
        
        let allDocTypes = Object.entries(docTypeTotals)
            .filter(([, total]) => total > 0) // Remove unused document types
            .sort(([, a], [, b]) => b - a)
            .map(([docType]) => docType);
        
        // If matrix is too large, limit to top contributors
        const MAX_MATRIX_SIZE = 10000; // Max cells to prevent memory issues
        const matrixSize = allTPs.length * allDocTypes.length;
        
        if (matrixSize > MAX_MATRIX_SIZE) {
            // Calculate how many items we can show
            const maxItems = Math.floor(Math.sqrt(MAX_MATRIX_SIZE));
            const tpLimit = Math.min(allTPs.length, maxItems);
            const docTypeLimit = Math.min(allDocTypes.length, Math.floor(MAX_MATRIX_SIZE / tpLimit));
            
            allTPs = allTPs.slice(0, tpLimit);
            allDocTypes = allDocTypes.slice(0, docTypeLimit);
            
            htmlParts.push(`<div style="background: #fff3cd; border: 1px solid #ffeaa7; padding: 15px; margin-bottom: 20px; border-radius: 5px;">
                <strong>⚠️ Large Dataset Notice:</strong> Showing top ${tpLimit} Trading Partners and ${docTypeLimit} Document Types 
                (${(tpLimit * docTypeLimit).toLocaleString()} cells) to prevent performance issues. 
                Full dataset contains ${Object.keys(tpTotals).length} TPs and ${Object.keys(docTypeTotals).length} Document Types.
            </div>`);
        }
        
        // Add search filters
        htmlParts.push(`
        <div style="margin-bottom: 20px; display: flex; gap: 15px; flex-wrap: wrap;">
            <div>
                <label style="display: block; margin-bottom: 5px; color: #4a5568; font-size: 0.9em;">Search Trading Partner:</label>
                <input type="text" id="tp-search" placeholder="Enter TP ID..." 
                    style="padding: 8px 12px; border: 1px solid #e2e8f0; border-radius: 5px; width: 200px;"
                    onkeyup="filterTPDocMatrix()">
            </div>
            <div>
                <label style="display: block; margin-bottom: 5px; color: #4a5568; font-size: 0.9em;">Search Document Type:</label>
                <input type="text" id="doctype-search" placeholder="Enter Doc Type..." 
                    style="padding: 8px 12px; border: 1px solid #e2e8f0; border-radius: 5px; width: 200px;"
                    onkeyup="filterTPDocMatrix()">
            </div>
            <div style="align-self: flex-end;">
                <button onclick="clearTPDocFilters()" 
                    style="padding: 8px 16px; background: #718096; color: white; border: none; border-radius: 5px; cursor: pointer;">
                    Clear Filters
                </button>
            </div>
        </div>`);
        
        // Create the matrix table
        htmlParts.push(`
        <h5 style="color: #4a5568; margin-bottom: 15px;">All Periods Combined (${periods.length} periods: ${this.formatPeriodDisplay(periods[0])} to ${this.formatPeriodDisplay(periods[periods.length - 1])})</h5>
        <div style="overflow-x: auto;">
            <table class="matrix-table" id="tp-doc-matrix-table">
                <thead>
                    <tr>
                        <th style="background: #f7fafc; position: sticky; left: 0; z-index: 10;">TP / Doc Type</th>`);
        
        // Add document type headers
        const headerCells = [];
        allDocTypes.forEach(docType => {
            headerCells.push(`<th style="background: #f7fafc; writing-mode: vertical-rl; text-orientation: mixed; padding: 10px 5px;">
                        <div style="height: 100px; display: flex; align-items: center;">
                            <span>${docType}</span>
                        </div>
                    </th>`);
        });
        htmlParts.push(headerCells.join(''));
        
        htmlParts.push(`<th style="background: #f7fafc;">Total</th>
                    </tr>
                </thead>
                <tbody>`);
        
        // Fill the matrix - build rows in chunks to avoid memory issues
        const rowChunks = [];
        const maxCount = Math.max(...Object.values(docTypeTotals));
        
        allTPs.forEach((tp, i) => {
            let rowTotal = 0;
            const rowStyle = i % 2 === 1 ? 'background: #f7fafc;' : '';
            const rowCells = [];
            
            rowCells.push(`<tr style="${rowStyle}">
                        <td class="tp-id-cell" data-id="${tp}" style="position: sticky; left: 0; background: ${i % 2 === 1 ? '#f7fafc' : 'white'}; z-index: 5;">
                            <strong>${tp}</strong>
                        </td>`);
            
            // Build cells for this row
            const cells = [];
            allDocTypes.forEach(docType => {
                const count = allPeriodsMatrix[tp] && 
                             allPeriodsMatrix[tp][docType] ? 
                             allPeriodsMatrix[tp][docType].total : 0;
                
                rowTotal += count;
                
                // Color intensity based on count
                let cellStyle = '';
                if (count > 0) {
                    const intensity = Math.min(count / maxCount, 1);
                    const greenValue = Math.floor(255 - (intensity * 55)); // From 255 to 200
                    cellStyle = `background-color: rgb(200, ${greenValue}, 200);`;
                }
                
                cells.push(`<td style="text-align: center; ${cellStyle}">
                            ${count > 0 ? count.toLocaleString() : '-'}
                        </td>`);
            });
            
            rowCells.push(cells.join(''));
            rowCells.push(`<td style="text-align: right; font-weight: bold;">
                        ${rowTotal.toLocaleString()}
                    </td>
                </tr>`);
            
            rowChunks.push(rowCells.join(''));
        });
        
        // Add all rows at once
        htmlParts.push(rowChunks.join(''));
        
        htmlParts.push(`
                        </tbody>
                    </table>
                </div>
                <p class="matrix-note">
                    Values show document counts. Darker shades indicate higher volumes.
                    ${matrixSize > MAX_MATRIX_SIZE ? '<br><strong>Note:</strong> Showing top contributors only. Use export functions for complete data.' : ''}
                </p>
            </div>`);
        
        return htmlParts.join('');
        } catch (error) {
            console.error('Error generating TP-Doc Matrix:', error);
            // Return a fallback UI if matrix generation fails
            return `<div class="tp-doc-matrix-wrapper">
                <h4 style="color: #2d3748; margin: 0;">📊 TP-Document Type Matrix</h4>
                <div style="background: #fee; border: 1px solid #fcc; padding: 20px; margin: 20px 0; border-radius: 5px;">
                    <strong>⚠️ Matrix Generation Error:</strong> The dataset is too large to display the full matrix. 
                    <br><br>
                    <strong>Error Details:</strong> ${error.message}
                    <br><br>
                    <strong>Dataset Size:</strong> ${Object.keys(tpTotals || {}).length} Trading Partners × ${Object.keys(docTypeTotals || {}).length} Document Types
                    <br><br>
                    Please use the export functions to download the data for analysis in external tools.
                </div>
            </div>`;
        }
    }
    
    // Export methods for tables
    exportSummaryMetrics() {
        if (!this.reportData || !this.reportData.trends) return null;
        
        const data = [];
        const trends = this.reportData.trends.Date_Summary;
        if (!trends || !trends.periods) return null;
        
        const periods = trends.periods;
        const docValues = trends.metric_trends['TOTAL-DOC'] || [];
        const kcValues = trends.metric_trends['TOTAL-KCS'] || [];
        
        for (let i = 0; i < periods.length; i++) {
            const row = {
                Period: periods[i],
                'Total Documents': docValues[i] || 0,
                'Total KCs': kcValues[i] || 0,
                'Docs Change': i > 0 && docValues[i-1] ? 
                    ((docValues[i] - docValues[i-1]) / docValues[i-1] * 100).toFixed(1) + '%' : '-',
                'KCs Change': i > 0 && kcValues[i-1] ? 
                    ((kcValues[i] - kcValues[i-1]) / kcValues[i-1] * 100).toFixed(1) + '%' : '-',
                'Efficiency (Docs/KC)': kcValues[i] > 0 ? 
                    (docValues[i] / kcValues[i]).toFixed(2) : '0.00'
            };
            data.push(row);
        }
        
        return data;
    }
    
    exportTPMonthlyDocs() {
        if (!this.reportData || !this.reportData.tp_data) return null;
        
        const data = [];
        const tpTotals = {};
        const periods = Object.keys(this.reportData.summary).sort();
        
        // Collect all TP data
        for (const period of periods) {
            if (this.reportData.tp_data[period] && this.reportData.tp_data[period]['TP_Summary']) {
                for (const row of this.reportData.tp_data[period]['TP_Summary']) {
                    const tpId = row['TP ID'] || row['Trading Partner'] || row['TP'];
                    if (tpId) {
                        if (!tpTotals[tpId]) {
                            tpTotals[tpId] = {};
                        }
                        tpTotals[tpId][period] = parseFloat(row['TOTAL-DOC'] || 0);
                    }
                }
            }
        }
        
        // Create export data
        for (const [tpId, periodData] of Object.entries(tpTotals)) {
            const row = { 'Trading Partner': tpId };
            let total = 0;
            
            for (const period of periods) {
                row[period] = periodData[period] || 0;
                total += periodData[period] || 0;
            }
            
            row['Total'] = total;
            data.push(row);
        }
        
        // Sort by total descending
        data.sort((a, b) => b.Total - a.Total);
        
        return data;
    }
    
    exportTPMonthlyKCs() {
        if (!this.reportData || !this.reportData.tp_data) return null;
        
        const data = [];
        const tpTotals = {};
        const periods = Object.keys(this.reportData.summary).sort();
        
        // Collect all TP KC data
        for (const period of periods) {
            if (this.reportData.tp_data[period] && this.reportData.tp_data[period]['TP_Summary']) {
                for (const row of this.reportData.tp_data[period]['TP_Summary']) {
                    const tpId = row['TP ID'] || row['Trading Partner'] || row['TP'];
                    if (tpId) {
                        if (!tpTotals[tpId]) {
                            tpTotals[tpId] = {};
                        }
                        tpTotals[tpId][period] = parseFloat(row['TOTAL-KCS'] || 0);
                    }
                }
            }
        }
        
        // Create export data
        for (const [tpId, periodData] of Object.entries(tpTotals)) {
            const row = { 'Trading Partner': tpId };
            let total = 0;
            
            for (const period of periods) {
                const value = periodData[period] || 0;
                row[period] = value.toFixed(1);
                total += value;
            }
            
            row['Total KCs'] = total.toFixed(1);
            data.push(row);
        }
        
        // Sort by total descending
        data.sort((a, b) => parseFloat(b['Total KCs']) - parseFloat(a['Total KCs']));
        
        return data;
    }
    
    // Generic table export methods
    exportTableToJSON(tableId, filename) {
        // Try to find the table in the iframe first
        const reportFrame = document.getElementById('reportFrame');
        let table = null;
        
        if (reportFrame && reportFrame.contentDocument) {
            table = reportFrame.contentDocument.getElementById(tableId);
        }
        
        // If not found in iframe, try main document
        if (!table) {
            table = document.getElementById(tableId);
        }
        
        if (!table) {
            console.error('Table not found:', tableId);
            return;
        }
        
        const data = this.extractTableData(table);
        const jsonString = JSON.stringify(data, null, 2);
        
        // Create download
        const blob = new Blob([jsonString], { type: 'application/json' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(link.href);
    }
    
    exportTableToCSV(tableId, filename) {
        // Try to find the table in the iframe first
        const reportFrame = document.getElementById('reportFrame');
        let table = null;
        
        if (reportFrame && reportFrame.contentDocument) {
            table = reportFrame.contentDocument.getElementById(tableId);
        }
        
        // If not found in iframe, try main document
        if (!table) {
            table = document.getElementById(tableId);
        }
        
        if (!table) {
            console.error('Table not found:', tableId);
            return;
        }
        
        const data = this.extractTableData(table);
        const csv = this.convertToCSV(data);
        
        // Create download
        const blob = new Blob([csv], { type: 'text/csv' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(link.href);
    }
    
    extractTableData(table) {
        const data = [];
        const headers = [];
        
        // Get headers
        const headerCells = table.querySelectorAll('thead th');
        headerCells.forEach(cell => {
            headers.push(cell.textContent.trim());
        });
        
        // Get data rows
        const rows = table.querySelectorAll('tbody tr');
        rows.forEach(row => {
            const rowData = {};
            const cells = row.querySelectorAll('td');
            cells.forEach((cell, index) => {
                if (index < headers.length) {
                    rowData[headers[index]] = cell.textContent.trim();
                }
            });
            if (Object.keys(rowData).length > 0) {
                data.push(rowData);
            }
        });
        
        return data;
    }
    
    convertToCSV(data) {
        if (!data || data.length === 0) return '';
        
        // Get headers
        const headers = Object.keys(data[0]);
        const csvHeaders = headers.join(',');
        
        // Convert data rows
        const csvRows = data.map(row => {
            return headers.map(header => {
                const value = row[header] || '';
                // Escape quotes and wrap in quotes if contains comma
                if (typeof value === 'string' && (value.includes(',') || value.includes('"') || value.includes('\n'))) {
                    return '"' + value.replace(/"/g, '""') + '"';
                }
                return value;
            }).join(',');
        });
        
        return [csvHeaders, ...csvRows].join('\n');
    }
}

/**
 * Main entry point for file analysis
 * Processes uploaded files and generates comprehensive analysis report
 */
async function analyzeFiles() {
    // Validate files are uploaded
    if (uploadedFiles.length === 0) {
        showStatus('Please upload files first', 'error');
        return;
    }
    
    // Initialize progress tracker
    initializeProgress();
    
    try {
        updateProgress(5, 'Initializing analyzer...', 'Initialize Analyzer');
        analyzer = new DynamicDataAnalyzer();
        window.analyzer = analyzer;
        
        // Detect customer and pattern
        updateProgress(15, 'Detecting customer pattern...', 'Detect Customer Pattern');
        if (!await analyzer.detectCustomerAndPattern(uploadedFiles)) {
            throw new Error('Failed to detect customer pattern');
        }
        
        // Detect sheet names
        updateProgress(25, 'Detecting sheet structure...', 'Detect Sheet Names');
        if (!await analyzer.detectSheetNames(uploadedFiles)) {
            throw new Error('Failed to detect sheet names');
        }
        
        // Process all files
        updateProgress(35, 'Processing files...', 'Process Files');
        await analyzer.processAllFiles(uploadedFiles);
        
        // Save analysis data
        updateProgress(70, 'Saving analysis data...', 'Save Analysis Data');
        const analysisData = analyzer.saveAnalysisData();
        
        // Generate Claude analysis
        updateProgress(80, 'Generating insights...', 'Generate Insights');
        const insights = await analyzer.generateClaudeAnalysis(analysisData);
        
        // Generate HTML report
        updateProgress(90, 'Generating report...', 'Generate Report');
        const reportHtml = analyzer.generateHtmlReport(analysisData, insights);
        
        // Display report in iframe
        updateProgress(95, 'Loading report...', 'Display Report');
        const reportFrame = document.getElementById('reportFrame');
        reportFrame.style.display = 'block';
        reportFrame.srcdoc = reportHtml;
        
        // Inject export functions after iframe loads
        reportFrame.onload = function() {
            const iframeWindow = reportFrame.contentWindow;
            
            // Pass data to iframe
            iframeWindow.analyzerData = analysisData;
            iframeWindow.docData = analyzer.docData;
            
            // Define export functions in iframe context
            iframeWindow.exportTableData = function(tableId, format) {
                let data;
                let filename;
                const date = new Date().toISOString().split('T')[0];
                
                // Get table data based on ID
                if (tableId === 'summary-metrics') {
                    data = iframeWindow.exportSummaryMetrics();
                    filename = 'Summary_Metrics_Comparison_' + date;
                } else if (tableId === 'tp-monthly-docs') {
                    data = iframeWindow.exportTPMonthlyDocs();
                    filename = 'Trading_Partners_Monthly_Performance_' + date;
                } else if (tableId === 'tp-monthly-kcs') {
                    data = iframeWindow.exportTPMonthlyKCs();
                    filename = 'Trading_Partners_Monthly_KC_Performance_' + date;
                } else if (tableId === 'tp-doc-volume') {
                    data = iframeWindow.exportTPDocVolume();
                    filename = 'Trading_Partners_Document_Volume_' + date;
                } else if (tableId === 'tp-doc-types') {
                    data = iframeWindow.exportTPDocTypes();
                    filename = 'Trading_Partners_Document_Types_' + date;
                } else if (tableId === 'tp-doc-matrix') {
                    data = iframeWindow.exportTPDocMatrix();
                    filename = 'TP_Document_Type_Matrix_' + date;
                }
                
                if (!data || data.length === 0) return;
                
                let blob;
                if (format === 'json') {
                    blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                    filename += '.json';
                } else if (format === 'csv') {
                    const csv = iframeWindow.convertToCSV(data);
                    blob = new Blob([csv], { type: 'text/csv' });
                    filename += '.csv';
                }
                
                // Create download link
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(link.href);
            };
            
            iframeWindow.convertToCSV = function(data) {
                if (!data || data.length === 0) return '';
                
                // Get headers
                const headers = Object.keys(data[0]);
                const csvHeaders = headers.join(',');
                
                // Convert data rows
                const csvRows = data.map(row => {
                    return headers.map(header => {
                        const value = row[header];
                        // Escape quotes and wrap in quotes if contains comma
                        if (typeof value === 'string' && (value.includes(',') || value.includes('"'))) {
                            return '"' + value.replace(/"/g, '""') + '"';
                        }
                        return value;
                    }).join(',');
                });
                
                return [csvHeaders, ...csvRows].join('\n');
            };
            
            // Export methods
            iframeWindow.exportSummaryMetrics = function() {
                const analyzerData = iframeWindow.analyzerData;
                if (!analyzerData) return null;
                
                const data = [];
                let periods = [];
                
                // Check if we have trends data
                if (analyzerData.trends && analyzerData.trends.Date_Summary) {
                    const trends = analyzerData.trends.Date_Summary;
                    if (trends.periods && trends.metric_trends) {
                        periods = trends.periods;
                        
                        // For each period, get the metrics
                        for (let i = 0; i < periods.length; i++) {
                            const period = periods[i];
                            
                            // Get total documents and KCs from metric_trends
                            let totalDocs = (trends.metric_trends['TOTAL-DOC'] || [])[i] || 0;
                            let totalKCs = (trends.metric_trends['TOTAL-KCS'] || [])[i] || 0;
                            
                            // If no data found, try docData (for cases like May 2022)
                            if (totalDocs === 0 && analyzerData.docData && analyzerData.docData[period]) {
                                const periodDocData = analyzerData.docData[period];
                                if (periodDocData && periodDocData.documents_by_tp) {
                                    totalDocs = Object.values(periodDocData.documents_by_tp).reduce((sum, tp) => sum + tp.total_docs, 0);
                                    totalKCs = Object.values(periodDocData.documents_by_tp).reduce((sum, tp) => sum + tp.total_kcs, 0);
                                }
                            }
                            
                            const row = {
                                'Period': period,
                                'Total Documents': totalDocs,
                                'Total KCs': totalKCs,
                                'Docs Change': '-',
                                'KCs Change': '-',
                                'Efficiency (Docs/KC)': totalKCs > 0 ? (totalDocs / totalKCs).toFixed(2) : '0.00'
                            };
                            
                            // Calculate changes
                            if (i > 0) {
                                const prevDocs = (trends.metric_trends['TOTAL-DOC'] || [])[i-1] || 0;
                                const prevKCs = (trends.metric_trends['TOTAL-KCS'] || [])[i-1] || 0;
                                
                                if (prevDocs > 0) {
                                    const docChange = ((totalDocs - prevDocs) / prevDocs * 100);
                                    row['Docs Change'] = (docChange >= 0 ? '+' : '') + docChange.toFixed(1) + '%';
                                }
                                if (prevKCs > 0) {
                                    const kcChange = ((totalKCs - prevKCs) / prevKCs * 100);
                                    row['KCs Change'] = (kcChange >= 0 ? '+' : '') + kcChange.toFixed(1) + '%';
                                }
                            }
                            
                            data.push(row);
                        }
                        
                        return data;
                    }
                }
                
                // Fallback: try to get from summary
                if (!periods.length && analyzerData.summary) {
                    periods = Object.keys(analyzerData.summary).sort();
                    
                    for (let i = 0; i < periods.length; i++) {
                        const period = periods[i];
                        const periodSummary = analyzerData.summary[period];
                        
                        const row = {
                            'Period': period,
                            'Total Documents': periodSummary.total_docs || 0,
                            'Total KCs': periodSummary.total_kcs || 0,
                            'Docs Change': '-',
                            'KCs Change': '-',
                            'Efficiency (Docs/KC)': periodSummary.total_kcs > 0 ? 
                                (periodSummary.total_docs / periodSummary.total_kcs).toFixed(2) : '0.00'
                        };
                        
                        if (i > 0) {
                            const prevSummary = analyzerData.summary[periods[i-1]];
                            if (prevSummary && prevSummary.total_docs > 0) {
                                const docChange = ((periodSummary.total_docs - prevSummary.total_docs) / prevSummary.total_docs * 100);
                                row['Docs Change'] = (docChange >= 0 ? '+' : '') + docChange.toFixed(1) + '%';
                            }
                            if (prevSummary && prevSummary.total_kcs > 0) {
                                const kcChange = ((periodSummary.total_kcs - prevSummary.total_kcs) / prevSummary.total_kcs * 100);
                                row['KCs Change'] = (kcChange >= 0 ? '+' : '') + kcChange.toFixed(1) + '%';
                            }
                        }
                        
                        data.push(row);
                    }
                }
                
                return data;
            };
            
            iframeWindow.exportTPMonthlyDocs = function() {
                const analyzerData = iframeWindow.analyzerData;
                if (!analyzerData || !analyzerData.tp_data) return null;
                
                const data = [];
                const periods = Object.keys(analyzerData.summary || {}).sort();
                const tpTotals = {};
                
                // Collect all TP data across periods
                for (const period of periods) {
                    if (analyzerData.tp_data[period] && analyzerData.tp_data[period]['TP_Summary']) {
                        const tpSummary = analyzerData.tp_data[period]['TP_Summary'];
                        tpSummary.forEach(row => {
                            const tpId = row['TP ID'] || row['Trading Partner'] || row['TP'];
                            const tpName = row['Trading Partner'] || row['TP Name'] || tpId;
                            
                            if (!tpTotals[tpId]) {
                                tpTotals[tpId] = {
                                    name: tpName,
                                    periods: {}
                                };
                            }
                            
                            tpTotals[tpId].periods[period] = parseFloat(row['TOTAL-DOC'] || 0);
                        });
                    }
                }
                
                // Create export data
                Object.entries(tpTotals).forEach(([tpId, tpData]) => {
                    const row = { 'Trading Partner': tpData.name };
                    let total = 0;
                    
                    periods.forEach(period => {
                        row[period] = tpData.periods[period] || 0;
                        total += tpData.periods[period] || 0;
                    });
                    
                    row['Total'] = total;
                    data.push(row);
                });
                
                // Sort by total descending
                data.sort((a, b) => b.Total - a.Total);
                
                return data;
            };
            
            iframeWindow.exportTPMonthlyKCs = function() {
                const analyzerData = iframeWindow.analyzerData;
                if (!analyzerData || !analyzerData.tp_data) return null;
                
                const data = [];
                const periods = Object.keys(analyzerData.summary || {}).sort();
                const tpTotals = {};
                
                // Collect all TP KC data across periods
                for (const period of periods) {
                    if (analyzerData.tp_data[period] && analyzerData.tp_data[period]['TP_Summary']) {
                        const tpSummary = analyzerData.tp_data[period]['TP_Summary'];
                        tpSummary.forEach(row => {
                            const tpId = row['TP ID'] || row['Trading Partner'] || row['TP'];
                            const tpName = row['Trading Partner'] || row['TP Name'] || tpId;
                            
                            if (!tpTotals[tpId]) {
                                tpTotals[tpId] = {
                                    name: tpName,
                                    periods: {}
                                };
                            }
                            
                            tpTotals[tpId].periods[period] = parseFloat(row['TOTAL-KCS'] || 0);
                        });
                    }
                }
                
                // Create export data
                Object.entries(tpTotals).forEach(([tpId, tpData]) => {
                    const row = { 'Trading Partner': tpData.name };
                    let total = 0;
                    
                    periods.forEach(period => {
                        row[period] = tpData.periods[period] || 0;
                        total += tpData.periods[period] || 0;
                    });
                    
                    row['Total'] = total;
                    data.push(row);
                });
                
                // Sort by total descending
                data.sort((a, b) => b.Total - a.Total);
                
                return data;
            };
            
            // Export All Trading Partners by Document Volume
            iframeWindow.exportTPDocVolume = function() {
                const analyzerData = iframeWindow.analyzerData;
                if (!analyzerData || !analyzerData.tp_data) return null;
                
                const data = [];
                const tpTotals = {};
                
                // Extract TP data from all periods
                for (const [period, periodData] of Object.entries(analyzerData.tp_data)) {
                    for (const [sheetName, sheetRows] of Object.entries(periodData)) {
                        if (sheetName === 'TP_Summary' && Array.isArray(sheetRows)) {
                            sheetRows.forEach(row => {
                                const tpId = row['TP ID'] || row['Trading Partner'] || row['TP'];
                                if (!tpId) return;
                                
                                if (!tpTotals[tpId]) {
                                    tpTotals[tpId] = {
                                        total_docs: 0,
                                        inbound_docs: 0,
                                        outbound_docs: 0,
                                        periods: []
                                    };
                                }
                                
                                const totalDocs = parseFloat(row['TOTAL-DOC'] || 0);
                                const inboundDocs = parseFloat(row['INB-DOC'] || 0);
                                const outboundDocs = parseFloat(row['OUT-DOC'] || 0);
                                
                                tpTotals[tpId].total_docs += totalDocs;
                                tpTotals[tpId].inbound_docs += inboundDocs;
                                tpTotals[tpId].outbound_docs += outboundDocs;
                                tpTotals[tpId].periods.push({ period, docs: totalDocs });
                            });
                        }
                    }
                }
                
                // Calculate growth and sort by document volume
                const sortedTPs = Object.entries(tpTotals)
                    .map(([tpId, info]) => {
                        let growth = 0;
                        if (info.periods.length >= 2) {
                            // Calculate average month-over-month growth (same as in analyzeTPData)
                            const sortedPeriods = info.periods.sort((a, b) => a.period.localeCompare(b.period));
                            const docValues = sortedPeriods.map(p => p.docs);
                            const docChanges = [];
                            
                            for (let i = 1; i < docValues.length; i++) {
                                if (docValues[i-1] > 0) {
                                    docChanges.push((docValues[i] - docValues[i-1]) / docValues[i-1] * 100);
                                }
                            }
                            
                            growth = docChanges.length > 0 ? docChanges.reduce((a, b) => a + b, 0) / docChanges.length : 0;
                        }
                        return { tpId, ...info, growth };
                    })
                    .sort((a, b) => b.total_docs - a.total_docs);
                
                // Create export data
                sortedTPs.forEach((tp, index) => {
                    const growthSymbol = tp.growth > 0 ? '↑' : tp.growth < 0 ? '↓' : '→';
                    data.push({
                        'Rank': index + 1,
                        'TP ID': tp.tpId,
                        'Total Documents': tp.total_docs,
                        'Inbound': tp.inbound_docs,
                        'Outbound': tp.outbound_docs,
                        'Growth Trend': Math.abs(tp.growth).toFixed(1) + '%'
                    });
                });
                
                return data;
            };
            
            // Export Document Types by Trading Partner
            iframeWindow.exportTPDocTypes = function() {
                const analyzerData = iframeWindow.analyzerData;
                if (!analyzerData || !analyzerData.tp_data) return null;
                
                const data = [];
                const docTypesByTP = {};
                
                // Extract document types from TP_Doc_Summary sheets
                for (const [period, periodData] of Object.entries(analyzerData.tp_data)) {
                    for (const [sheetName, sheetRows] of Object.entries(periodData)) {
                        if (sheetName === 'TP_Doc_Summary' && Array.isArray(sheetRows)) {
                            sheetRows.forEach(row => {
                                const tpId = row['TP ID'] || row['Trading Partner'] || row['TP'];
                                const docType = row['DOCS'] || row['DOC'] || row['Document Type'];
                                
                                if (tpId && docType) {
                                    if (!docTypesByTP[tpId]) {
                                        docTypesByTP[tpId] = new Set();
                                    }
                                    docTypesByTP[tpId].add(docType.toString().trim());
                                }
                            });
                        }
                    }
                }
                
                // Prepare data for export
                const tpsWithDocTypes = Object.entries(docTypesByTP)
                    .map(([tpId, typesSet]) => ({
                        tpId,
                        types: Array.from(typesSet).sort(),
                        typeCount: typesSet.size
                    }))
                    .filter(tp => tp.typeCount > 0)
                    .sort((a, b) => b.typeCount - a.typeCount);
                
                tpsWithDocTypes.forEach(tp => {
                    data.push({
                        'TP ID': tp.tpId,
                        'Document Types': tp.types.join(', '),
                        'Type Count': tp.typeCount
                    });
                });
                
                return data;
            };
            
            // Export TP-Document Type Matrix
            iframeWindow.exportTPDocMatrix = function() {
                const analyzerData = iframeWindow.analyzerData;
                const docData = iframeWindow.docData;
                if (!analyzerData || !docData) return null;
                
                const data = [];
                const allPeriodsMatrix = {};
                const tpTotals = {};
                const docTypeTotals = {};
                const allDocTypesSet = new Set();
                
                // Use the already processed tp_type_matrix data (same as generateTPDocMatrixTables)
                const periods = Object.keys(docData).sort();
                
                // Combine data from all periods
                for (const period of periods) {
                    const periodData = docData[period];
                    if (periodData && periodData.tp_type_matrix) {
                        for (const [tp, types] of Object.entries(periodData.tp_type_matrix)) {
                            if (!allPeriodsMatrix[tp]) {
                                allPeriodsMatrix[tp] = {};
                            }
                            
                            for (const [docType, counts] of Object.entries(types)) {
                                if (!allPeriodsMatrix[tp][docType]) {
                                    allPeriodsMatrix[tp][docType] = { total: 0 };
                                }
                                
                                // Sum the counts across all periods
                                const total = counts.total || 0;
                                allPeriodsMatrix[tp][docType].total += total;
                                
                                // Update totals
                                if (!tpTotals[tp]) tpTotals[tp] = 0;
                                if (!docTypeTotals[docType]) docTypeTotals[docType] = 0;
                                
                                tpTotals[tp] += total;
                                docTypeTotals[docType] += total;
                                allDocTypesSet.add(docType.toString().trim());
                            }
                        }
                    }
                }
                
                // Sort TPs and document types
                const sortedTPs = Object.entries(tpTotals)
                    .sort(([, a], [, b]) => b - a)
                    .map(([tp]) => tp);
                
                const sortedDocTypes = Array.from(allDocTypesSet).sort();
                
                // Create export data
                sortedTPs.forEach(tp => {
                    const row = { 'Trading Partner': tp };
                    let rowTotal = 0;
                    
                    // Add count for each document type
                    sortedDocTypes.forEach(docType => {
                        const count = allPeriodsMatrix[tp] && 
                                     allPeriodsMatrix[tp][docType] ? 
                                     allPeriodsMatrix[tp][docType].total : 0;
                        row[docType] = count;
                        rowTotal += count;
                    });
                    
                    row['Total'] = rowTotal;
                    data.push(row);
                });
                
                // Add totals row
                if (data.length > 0) {
                    const totalsRow = { 'Trading Partner': 'TOTAL' };
                    sortedDocTypes.forEach(docType => {
                        totalsRow[docType] = docTypeTotals[docType] || 0;
                    });
                    totalsRow['Total'] = Object.values(docTypeTotals).reduce((sum, val) => sum + val, 0);
                    data.push(totalsRow);
                }
                
                return data;
            };
        };
        
        // Show maximize and export buttons, and minimize analyzer section
        document.getElementById('maximizeBtn').classList.add('visible');
        document.getElementById('exportBtn').style.display = 'flex';
        toggleAnalyzerSection(); // Minimize the analyzer section
        
        // Complete progress
        updateProgress(100, 'Analysis complete!', 'Complete');
        
        // Hide progress after a short delay
        setTimeout(() => {
            hideProgress();
            showStatus('Analysis complete!', 'success');
        }, 1500);
        
        // Scroll to report
        reportFrame.scrollIntoView({ behavior: 'smooth' });
        
    } catch (error) {
        console.error('Analysis error:', error);
        hideProgress();
        showStatus(`Error: ${error.message}`, 'error');
    }
}

// Export the generated report
function exportGeneratedReport() {
    const reportFrame = document.getElementById('reportFrame');
    if (!reportFrame || !reportFrame.srcdoc) {
        alert('No report to export. Please generate a report first.');
        return;
    }
    
    // Get the report HTML from the iframe
    const reportHTML = reportFrame.srcdoc;
    
    // Create a Blob with the HTML content
    const blob = new Blob([reportHTML], { type: 'text/html' });
    
    // Create a download link
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    
    // Generate filename with customer name and date
    const customerName = analyzer && analyzer.customerName ? analyzer.customerName : 'Report';
    const date = new Date().toISOString().split('T')[0];
    link.download = `${customerName.replace(/[^a-z0-9]/gi, '_')}_Report_${date}.html`;
    
    // Trigger download
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    
    // Clean up
    URL.revokeObjectURL(link.href);
    
    showStatus('Report exported successfully!', 'success');
}

// Menu functionality
/**
 * Toggle main menu dropdown visibility
 */
function toggleMenu() {
    const dropdown = document.getElementById('menuDropdown');
    dropdown.classList.toggle('show');
}

/**
 * Show a modal dialog and close the menu
 * @param {string} modalId - ID of the modal to show
 */
function showModal(modalId) {
    document.getElementById(modalId).classList.add('show');
    document.getElementById('menuDropdown').classList.remove('show');
}

/**
 * Close a modal dialog
 * @param {string} modalId - ID of the modal to close
 */
function closeModal(modalId) {
    document.getElementById(modalId).classList.remove('show');
}

/**
 * Toggle converter submenu visibility
 * @param {Event} event - Click event to stop propagation
 */
function toggleConverterSubmenu(event) {
    event.stopPropagation();
    const submenu = document.getElementById('converterSubmenu');
    if (submenu.style.display === 'block') {
        submenu.style.display = 'none';
    } else {
        submenu.style.display = 'block';
    }
}

/**
 * Close menu when clicking outside
 * Handles click events on the document to close menu dropdowns
 */
window.addEventListener('click', function(event) {
    if (!event.target.matches('.menu-button') && !event.target.closest('.menu-dropdown')) {
        const dropdown = document.getElementById('menuDropdown');
        if (dropdown && dropdown.classList.contains('show')) {
            dropdown.classList.remove('show');
        }
    }
    // Close submenu when clicking outside
    if (!event.target.closest('#converterSubmenu') && !event.target.closest('.menu-item')) {
        const submenu = document.getElementById('converterSubmenu');
        if (submenu) {
            submenu.style.display = 'none';
        }
    }
});

// Document Analysis Filter Functions
function toggleDocFilters() {
    const panel = document.getElementById('docFilterPanel');
    if (panel) {
        panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
    }
}

function applyDocFilters() {
    // This would filter the displayed data based on selected criteria
    // Implementation would depend on how data is stored and displayed
}

function resetDocFilters() {
    document.getElementById('docTypeFilter').value = '';
    document.getElementById('periodRangeFilter').value = '';
    document.getElementById('minVolumeFilter').value = '';
    applyDocFilters();
}

function exportDocumentAnalysis() {
    // Get the document analysis content
    const docAnalysisTab = document.getElementById('documentsTab');
    if (!docAnalysisTab) return;
    
    // Create a standalone HTML with just the document analysis
    const exportHTML = `
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Document Analysis Export - ${analyzer.customerName || 'Report'}</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></scr` + `ipt>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        table { border-collapse: collapse; width: 100%; margin: 20px 0; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #f2f2f2; }
        .chart-container { margin: 20px 0; }
        @media print { .no-print { display: none; } }
    </style>
</head>
<body>
    <h1>Document Analysis - ${analyzer.customerName || 'Report'}</h1>
    <p>Generated: ${new Date().toLocaleString()}</p>
    ${docAnalysisTab.innerHTML}
</body>
</html>`;
    
    // Create blob and download
    const blob = new Blob([exportHTML], { type: 'text/html' });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = `Document_Analysis_${analyzer.customerName || 'Report'}_${new Date().toISOString().split('T')[0]}.html`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(link.href);
    
    showStatus('Document Analysis exported successfully!', 'success');
}

// Make tables sortable
function makeTableSortable(tableId) {
    const table = document.getElementById(tableId);
    if (!table) return;
    
    const headers = table.querySelectorAll('th');
    headers.forEach((header, index) => {
        if (!header.classList.contains('no-sort')) {
            header.style.cursor = 'pointer';
            header.classList.add('sortable');
            if (!header.innerHTML.includes('↕')) {
                header.innerHTML += ' <span class="sort-indicator">↕</span>';
            }
            header.onclick = () => sortTable(table, index);
        }
    });
}

// Make all tables sortable automatically
function makeAllTablesSortable() {
    // Find all tables in the document
    const tables = document.querySelectorAll('table');
    
    tables.forEach((table, tableIndex) => {
        // Give table an ID if it doesn't have one
        if (!table.id) {
            table.id = `sortable-table-${tableIndex}`;
        }
        
        const headers = table.querySelectorAll('thead th');
        
        headers.forEach((header, index) => {
            if (!header.classList.contains('no-sort') && !header.onclick) {
                header.style.cursor = 'pointer';
                header.classList.add('sortable');
                if (!header.innerHTML.includes('↕') && !header.innerHTML.includes('↑') && !header.innerHTML.includes('↓')) {
                    header.innerHTML += ' <span class="sort-indicator">↕</span>';
                }
                header.onclick = () => {
                    sortTable(table, index);
                };
            }
        });
    });
}

// Enhanced sort tracking
const tableSortStates = {};

function sortTable(table, column) {
    const tbody = table.querySelector('tbody');
    if (!tbody) return;
    
    const rows = Array.from(tbody.querySelectorAll('tr'));
    if (rows.length === 0) return;
    
    // Get or initialize sort state for this table
    const tableId = table.id || 'anonymous';
    if (!tableSortStates[tableId]) {
        tableSortStates[tableId] = {};
    }
    
    // Determine sort direction
    const currentSort = tableSortStates[tableId][column] || 'none';
    const newSort = currentSort === 'asc' ? 'desc' : 'asc';
    tableSortStates[tableId][column] = newSort;
    
    // Detect if column contains numeric data
    const isNumeric = rows.every(row => {
        const cellText = row.cells[column]?.textContent.trim() || '';
        // Remove common formatting characters
        const cleanedText = cellText.replace(/[$,%]/g, '').replace(/[()]/g, '');
        return !isNaN(parseFloat(cleanedText)) && isFinite(cleanedText);
    });
    
    rows.sort((a, b) => {
        const aCell = a.cells[column];
        const bCell = b.cells[column];
        if (!aCell || !bCell) return 0;
        
        let aVal = aCell.textContent.trim();
        let bVal = bCell.textContent.trim();
        
        if (isNumeric) {
            // Remove formatting characters and parse
            const aNum = parseFloat(aVal.replace(/[$,%()]/g, '').replace(/[^0-9.-]/g, ''));
            const bNum = parseFloat(bVal.replace(/[$,%()]/g, '').replace(/[^0-9.-]/g, ''));
            
            // Handle NaN values
            if (isNaN(aNum) && isNaN(bNum)) return 0;
            if (isNaN(aNum)) return 1;
            if (isNaN(bNum)) return -1;
            
            return newSort === 'asc' ? aNum - bNum : bNum - aNum;
        } else {
            // Handle date-like strings (YYYY-MM format)
            if (/^\d{4}-\d{2}$/.test(aVal) && /^\d{4}-\d{2}$/.test(bVal)) {
                return newSort === 'asc' ? aVal.localeCompare(bVal) : bVal.localeCompare(aVal);
            }
            // Standard string comparison
            return newSort === 'asc' ? aVal.localeCompare(bVal) : bVal.localeCompare(aVal);
        }
    });
    
    // Re-append sorted rows
    rows.forEach(row => tbody.appendChild(row));
    
    // Update sort indicators
    const headers = table.querySelectorAll('thead th');
    headers.forEach((header, idx) => {
        const indicator = header.querySelector('.sort-indicator');
        if (indicator) {
            if (idx === column) {
                indicator.textContent = newSort === 'asc' ? '↑' : '↓';
                header.classList.add('sorted');
            } else {
                indicator.textContent = '↕';
                header.classList.remove('sorted');
            }
        }
    });
}
</script>
</body>
</html>